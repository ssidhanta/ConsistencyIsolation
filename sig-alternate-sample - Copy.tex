% This is "sig-alternate.tex" V2.1 April 2013d
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

%\documentclass{sig-alternate-05-2015}
\documentclass{vldb}
\usepackage{subfigure}
\usepackage{amsmath,amssymb}
\usepackage{marvosym}
\usepackage{mathtools}
\usepackage{textcomp}
%\pagestyle{empty}
\usepackage{algpseudocode}
\usepackage{algorithm}
\DeclarePairedDelimiterX\Set[2]{\lbrace}{\rbrace}%
{ #1 \,\delimsize|\,\mathopen{} #2 }
\newsavebox{\ieeealgbox}
\newenvironment{boxedalgorithmic}
  {\begin{lrbox}{\ieeealgbox}
   \begin{minipage}{\dimexpr\columnwidth-2\fboxsep-2\fboxrule}
   \begin{algorithmic}}
  {\end{algorithmic}
   \end{minipage}
   \end{lrbox}\noindent\fbox{\usebox{\ieeealgbox}}}

\begin{document}

% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
%\doi{10.475/123_4}

% ISBN
%\isbn{123-4567-24-567/08/06}

%Conference
%\conferenceinfo{PLDI '13}{June 16--19, 2013, Seattle, WA, USA}

%\acmPrice{\$15.00}

%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{A Generalized Model of Consistency and Isolation Levels%Alternate {\ttlit ACM} SIG Proceedings Paper in LaTeX
%Format\titlenote{(Produces the permission block, and
%copyright information). For use with
%SIG-ALTERNATE.CLS. Supported by ACM.}
}
%\subtitle{[Extended Abstract]
%\titlenote{A full version of this paper is available as
%\textit{Author's Guide to Preparing ACM SIG Proceedings Using
%\LaTeX$2_\epsilon$\ and BibTeX} at
%\texttt{www.acm.org/eaddress.htm}}}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

%\numberofauthors{2} %  in this sample file, there are a *total*
%% of EIGHT authors. SIX appear on the 'first-page' (for formatting
%% reasons) and the remaining two appear in the \additionalauthors section.
%%
%\author{
%% You can go ahead and credit any number of authors here,
%% e.g. one 'row of three' or two rows (consisting of one row of three
%% and a second row of one, two or three).
%%
%% The command \alignauthor (no curly braces needed) should
%% precede each author name, affiliation/snail-mail address and
%% e-mail address. Additionally, tag each line of
%% affiliation/address with \affaddr, and tag the
%% e-mail address with \email.
%%
%% 1st. author
%\alignauthor
%Subhajit Sidhanta\\%\titlenote{Dr.~Trovato insisted his name be first.}\\
%       \affaddr{Louisiana State University}\\
%       %\affaddr{1932 Wallamaloo Lane}\\
%       %\affaddr{Wallamaloo, New Zealand}\\
%       \email{ssidha1@lsu.edu}
%% 2nd. author
%\alignauthor
%Rodrigo Rodrigues\\%Tobin\titlenote{The secretary disavows
%%any knowledge of this author's actions.}\\
%       \affaddr{INESC-ID, University of Lisbon}\\
%       %\affaddr{P.O. Box 1212}\\
%       %\affaddr{Dublin, Ohio 43017-6221}\\
%       \email{rodrigo.miragaia.rodrigues@tecnico.ulisboa.pt}
% 3rd. author
%\alignauthor Lars Th{\o}rv{\"a}ld\titlenote{This author is the
%one who did all the really hard work.}\\
%       \affaddr{The Th{\o}rv{\"a}ld Group}\\
%       \affaddr{1 Th{\o}rv{\"a}ld Circle}\\
%       \affaddr{Hekla, Iceland}\\
%       \email{larst@affiliation.org}
%\and  % use '\and' if you need 'another row' of author names
%% 4th. author
%\alignauthor Lawrence P. Leipuner\\
%       \affaddr{Brookhaven Laboratories}\\
%       \affaddr{Brookhaven National Lab}\\
%       \affaddr{P.O. Box 5000}\\
%       \email{lleipuner@researchlabs.org}
%% 5th. author
%\alignauthor Sean Fogarty\\
%       \affaddr{NASA Ames Research Center}\\
%       \affaddr{Moffett Field}\\
%       \affaddr{California 94035}\\
%       \email{fogartys@amesres.org}
%% 6th. author
%\alignauthor Charles Palmer\\
%       \affaddr{Palmer Research Laboratories}\\
%       \affaddr{8600 Datapoint Drive}\\
%       \affaddr{San Antonio, Texas 78229}\\
%       \email{cpalmer@prl.com}
%}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
%\additionalauthors{Additional authors: John Smith (The Th{\o}rv{\"a}ld Group,
%email: {\texttt{jsmith@affiliation.org}}) and Julius P.~Kumquat
%(The Kumquat Consortium, email: {\texttt{jpkumquat@consortium.net}}).}
%\date{30 July 1999}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
 The main contribution of this paper is a specification language \emph{ConSpec}, that enables formalization of
 any possible consistency model or isolation level that a storage system may provide, in a uniform syntax and form,
  irrespective of the design and implementation of the target storage system.   Prior to ConSpec, definitions of
  consistency models were tightly coupled with the specific design and implementation of the target storage system.
  Each new datastore would redefine a consistency model in terms of its design and implementation. The absence of a uniform
   definition makes it impossible to compare and verify the consistency provided by a given target datastore. Existing
   definitions of consistency models and isolation levels either use textual descriptions or graphical representation of
   proscribed anomalies and allowed dependencies between operations, making
   automated verification even more difficult. To the best of our knowledge, this is the first work that expresses both
   consistency and isolation levels in terms of ConSpec, a language that extends Linear Temporal Logic (LTL). Use
   of LTL ushers in the possibility of leveraging existing tools like satisfiability solvers and theorem provers to build
   automated verifiers. We present SpecCheck, an  automated verification tool that is used %leverages of static analysis techniques
  to  verify whether a storage system satisfies a consistency model or isolation level, specified using ConSpec.
  %Using the following approach, specifications derived using ConSpec can be used to subsequently  verify whether a given storage system satisfies a given consistency model or isolation level.
 %SpecCheck accepts as input: 1) a ConSpec expression corresponding to a consistency model or isolation level that a
% target datastore claims to provide, and 2) a trace collected by executing a client application on the target datastore.
  %For the simplified case, we consider that the target system can only performs simple read and write operations.
%The target system can work under any possible consistency model that can be defined with respect to storage operations that can be modelled using simple read and write operations.
  %Client applications, transactions, or client sessions executing on the target system can comprise a sequence of storage operations, optionally enclosed within
%  the application scope.
 %For transactional datastores, we consider only committed transactions; analyzing uncommitted transactions is beyond the scope of this paper.
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
%\begin{CCSXML}
%<ccs2012>
% <concept>
%  <concept_id>10010520.10010553.10010562</concept_id>
%  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%  <concept_significance>500</concept_significance>
% </concept>
% <concept>
%  <concept_id>10010520.10010575.10010755</concept_id>
%  <concept_desc>Computer systems organization~Redundancy</concept_desc>
%  <concept_significance>300</concept_significance>
% </concept>
% <concept>
%  <concept_id>10010520.10010553.10010554</concept_id>
%  <concept_desc>Computer systems organization~Robotics</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
% <concept>
%  <concept_id>10003033.10003083.10003095</concept_id>
%  <concept_desc>Networks~Network reliability</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
%</ccs2012>
%\end{CCSXML}
%
%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}


%
% End generated code
%

%
%  Use this command to print the description
%
%\printccsdesc

% We no longer use \terms command
%\terms{Theory}

%\keywords{ACM proceedings; \LaTeX; text tagging}

\section{Introduction}
 %Internet services and applications that use datastores as backends to store service and application states and
 %A consistency model \cite{Burckhardt:2014:PEC:2693641.2693642} specifies constraints on the manner that objects
% (i.e., data items) in a storage system are allowed to be modified by operations invoked from a client application.
% An isolation level \cite{DBLP:conf/icde/AdyaLO00}  specifies constraints regarding the manner in which results of
% operations performed on the storage system from a client application is visible from other concurrent client applications
% or sessions.
 %For users and developers of modern internet-based applications and services, which handle large volume of data, and are
% accessed by concurrent users spread out across the globe, consistency model \cite{Burckhardt:2014:PEC:2693641.2693642}
% and isolation level \cite{DBLP:conf/icde/AdyaLO00}  of the underlying
% datastore are important factors to be considered. %, as discussed below.
  %We denote the respective client application, session, or transaction, that a storage operation is invoked from, as
%  \emph{application scope} of that storage operation. Depending on the nature and domain of the application, datastore
%  operations may be invoked from special-purpose application scopes, like session, transaction, or client application.
 % Concurrent applications and services invoke storage operations, like read or write, on the underlying datastore, from
%   geographically distributed client locations.
  Development of modern internet-based applications and services requires application developers to take into
   account the consistency \cite{Burckhardt:2014:PEC:2693641.2693642} and isolation level \cite{DBLP:conf/icde/AdyaLO00} provided by the underlying datastore, to ensure correctness and performance
   guarantees. %We denote the respective client application, session, or transaction, that a storage operation is invoked from, as  \emph{application scope} of that storage operation. Within a given application scope, operations are executed in a synchronous manner, i.e., an operation is executed once the result from the previous operation in the program order is received.
 % A stronger consistency or a higher isolation level enforces a higher degree of coordination among
%  replicas in a replicated datastore, resulting in increased observed latency, while guaranteeing that an operation always
%   sees latest updated versions of any object in the datastore. This ensures that there are no anomalies in the observed
%   results, at the cost of higher latencies. On the other hand, a weaker consistency or a lower isolation level may
%   result in anomalies in the observed results, but cause lower observed latency.
 Currently, there is a large number of possible consistency models and isolation levels, many of which are not
    clearly defined using formal semantics. The universe of consistency models and isolation levels is, in fact, expanding
     constantly. Newer consistency models are coming up regularly to address specific QOS (quality of service) and
     performance  requirement of different applications and services. Existing consistency definitions are tied to
     specific datastore implementations, and not generic enough to be used in the context of a different (newer) datastore.
      It is important for consistency and isolation definitions to be implementation-independent, because a particular
      datastore implementation may not be suitable for different application domains. A relational datastore, like MySQL
      or Oracle, may be unsuitable for an application that operates in the scale of millions of concurrent executions,
      serving clients that are geographically distributed across different continents. In the latter case, a
      geo-distributed datastore like Cassandra may prove to be more be more efficient, producing lower latency, while
      compromising on serializabilty and strict isolation.  Hence, research papers and projects often end up  re-defining
       existing consistency models using disparate semantics and notations.
       \par Disparities among multiple definitions of the
      same model may result in ambiguities and confusion, which in turn, may result in incorrect design and implementations
        of applications built upon such definitions.
 Also, with such ambiguous definitions, it is difficult to compare consistency models of different datastores, and choose
 a suitable datastore for a given application. Though Adya et al. claim that their definitions are implementation agnostic,
 they assume that the system is able to track version histories of each object; hence, we argue that these definitions
 will not be applicable to systems that do not persist version histories.
 Further, they use graphical representation of proscribed
   anomalies and allowed dependencies between operations; making it difficult to automatically verify such definitions.
   Existing definitions of consistency models  used either textual descriptions or graphical representations, making
   automated verification even more difficult. The goal of this paper is to specify consistency and isolation definitions
    using a uniform syntax in an implementation agnostic manner.
   \par Traditionally, specifications of consistency models or isolation levels are comprised of the following components:
   \emph{rules} that restrict the order in which results of operations can be observed, specified using axiomatic expressions,
   \emph{anomalies} precluded by the models, expressed using directed serialization graphs (DSGs), where vertices in a DSG
   represent operations, and edges represent the dependency relations among operations corresponding to the connecting
   vertices. %The above definitions, comprising a combination of axiomatic rules and DSGs, can be difficult to comprehend, and subsequently may result in ambiguous interpretations of the model. This, in turn, may lead to incorrectly implemented storage systems, which do not conform to the correct specifications of the intended consistency models or intended isolation levels which the systems claim to provide. Further, state-of-the-art definitions of consistency and isolation models are tied to specific datastore implementations; making it impossible to apply a particular definition to the context of a different datastore, which is built according to different design principles.
 The rules in state-of-the-art consistency and isolation definitions specify the valid order of execution among operations
  in terms of dependency relations, like write-write (ww), write-read (wr) dependency, etc. Such dependency relations
  belong to two categories - explicit dependencies, like ww dependency, and implicit dependencies, like read-write (rw)
  dependency, that are expressed in terms of one or more explicit dependencies. %An axiomatic rule in a state-of-the-art
%   definition specifies a combination of valid dependency relations comprising operations on datastore objects.
 These dependency relations are not apparent from the statement of consistency and isolation definition, especially
 implicit dependencies, since those are further described in terms of explicit dependencies. %The anomaly DSGs in a
% state-of-the-art definition depict proscribed anomalies. Each DSG depicts the proscribed dependency relations among
%  operations in a specific invalid execution sequence. Each operation in a proscribed execution sequence is represented
%  as a vertex in the DSG, and the edge labels specify the proscribed dependency relations. Such anomaly DSGs can not be
%  derived directly from consistency definitions of consistency and isolation.
\par However, a given consistency or isolation level specifies a valid relative temporal order among operations. Such
temporal order can be directly expressed using LTL \cite{Lamport:1994:TLA:177492.177726} operators, like next, eventually, etc.
We argue that consistency and isolation levels can be readily expressed in term of LTL-like expressions
 that specify required temporal order among operations according to given consistency or isolation level.
 Hence, we follow in the footsteps of \cite{DBLP:journals/corr/EhlersR14} to develop a specification language
 \emph{ConSpec} that is an extension of Linear Temporal Logic (LTL). LTL is a natural choice for specifying relative
 temporal ordering among operations in different consistency and isolation definitions. ConSpec uses LTL-like semantics to
  express the rules that specify the allowed order in which results of operations can be visible to a client application. %,
   %with respect to an observed session trace.
   % ConSpec acts as a  unified modelling language that
%can be used to specify any consistency model or isolation level that is not specific to any particular target datastore.
% For a given consistency model or isolation level, we derive
% a single ConSpec expression that specifies the order in which results of operations invoked from a given client application can be observed from a client application.
  The ConSpec expressions specify the allowed temporal order (i.e., ``happens before" order \cite{Bailis:2013:BCC:2463676.2465279}) in which operations within a client application return results, and restricts the manner in which these results are visible to subsequent operations in the client application.
  \par We argue that specifications expressed in terms of ConSpec are much easier to reason about than the state-of-the-art definitions, which require an understanding
 of the various dependency relationships; the implicit dependencies can be particularly complex to express and
 comprehend. The main contributions of this paper are as follows.
   %\section{Contributions}
    %In this paper, we propose a generalized semantics for formally defining consistency models and isolation levels,
%   which can be used to unify definitions of all possible consistency models and isolation levels under a single
%   formalization framework.
   % We present the detailed derivation
% of ConSpec specifications for consistency models and isolation levels that exist in the literature of database systems.
%  ConSpec specifications are implementation agnostic; a target datastore can be anything ---
%  a stand-alone relational database, a transactional database, or a distributed ``NOSQL'' datastore.
  %Apart from eliminating the risks with ambiguous definitions, this approach further allows
% us to build a automated framework for verifying whether a system satisfies the definition of a given consistency model or i
% solation level.
 \begin{itemize}
 \item It present the syntax and design of ConSpec, a language for formally specifying the consistency
 models and isolation levels that a storage system supports.
 ConSpec specifications are expressed in terms of Linear Temporal Logic (LTL), thus enabling us to leverage
   existing body of Satisfiability solvers and Theorem provers to build automated verifiers.
    %Definitions specified with ConSpec are simpler, easier to
% understand, verifiable, thus making lives of application developers and database developers easier.
   \item It also presents SpecCheck, a prototype  automated verification tool that is used %leverages of static analysis techniques
  to  verify whether a storage system satisfies a consistency model or isolation level, specified using ConSpec.
  %Using the following approach, specifications derived using ConSpec can be used to subsequently  verify whether a given storage system satisfies a given consistency model or isolation level.
 SpecCheck accepts as input: 1) a ConSpec expression corresponding to a consistency model or isolation level that a
 target datastore claims to provide, and 2) a trace collected by executing a client application on the target datastore.
 We argue that the complexity of the verification of execution histories using SpecCheck beats the state-of-the-art.
 Traditional \emph{server trace analysis} approaches perform trace analysis on server level execution traces, i.e.,
 execution traces collected from the server nodes comprising the underlying datastore. As such, they are dependent on the
 implementation and configuration
  of a specific datastore instance, such as replication factor, partitioning scheme, etc.% They analyze server traces to
%  check if any portion of the server traces matches the specified anomalies that a given consistency model or isolation
%  level proscribes; process terminates with a failure once a match is found against any of the proscribed anomalies.
  Contrastingly, SpecCheck analyzes traces collected at the end of the client application, making it completely implementation agnostic.
%\section{Contributions}
%   We present a generalised specification language \emph{ConSpec}, that enables formalization of any possible consistency model or isolation level that a storage system may follow, irrespective of the design and implementation of the target storage system. Using the following approach, ConSpec enables application of static analysis techniques to verify whether a storage system satisfies a consistency model or isolation level, specified using the formal semantics of ConSpec.
%  %Using the following approach, specifications derived using ConSpec can be used to subsequently  verify whether a given storage system satisfies a given consistency model or isolation level.
%  We can execute client applications on a target datastore, and analyze results returned by operations invoked from a particular application scope. We compare these results with the results expected according to specifications of the consistency model or isolation level for the underlying datastore, specified using ConSpec. The models specified using ConSpec are implementation agnostic; a target datastore can be anything --- a stand-alone relational database, a transactional database, or a distributed ``NOSQL'' datastore. %For the simplified case, we consider that the target system can only performs simple read and write operations.
%%The target system can work under any possible consistency model that can be defined with respect to storage operations that can be modelled using simple read and write operations.
%  %Client applications, transactions, or client sessions executing on the target system can comprise a sequence of storage operations, optionally enclosed within
%%  the application scope.
 For transactional datastores, we consider only committed transactions; analyzing uncommitted transactions is beyond the scope of this paper.
\end{itemize}
%We specify any given consistency model or isolation level with a dependency graph, where vertices represent operations and edges represent dependency relations. We derive a dependency graph for the given consistency model or isolation level, depicting the possible dependency relations between storage operations.
\begin{figure}[!htbp]
        \centering
        \includegraphics[width=3in,height=2in]
                    {system.eps}
        \caption{System Model}
        \label{fig:System}
\end{figure}

  \section{System Model}
  We do not assume anything regarding the internal organization of the object in the storage system. For the intent and purpose of this paper, an object $o_j$ is a variable comprising: 1) a unique name, given by the string $o_j$, and 2) a value $v_j$, which can be of any datatype, such as float, double, string, etc. We consider a simple execution model where client applications perform only read and write operations.  More complex execution models  can simply be expressed as specialised versions of basic read and write operations.
  A \emph{session trace} is a trace comprising the results of operations invoked from a client application, observed from
  the client machine. A given client application is executed on a target datastore. In the course of execution of the client application, we collect session traces over a pre-defined sliding window over time from the client machine (i.e., the machine that hosts the client application). We perform \emph{session trace analysis} on the above session traces to determine whether the target system satisfies a given consistency model or an isolation level.
 Let $j$ be the index of the read operation in the execution sequence of  $\mathit{Cl}$ observed in a session trace.  An operation $\mathit{op}_j$ is identified by the unique signature of the operation, which is a string that formally describes the operation.  The signature of a write operation $\mathit{op}_j$, that writes a value $v_l$ to an object $o$, is given as $w^j(o,v_l)$, where $o$ is a string that denotes the unique name of an object $o$, and $v_l$ is a string that denotes the value that the operation writes to $o$. Similarly, the signature of a read operation $\mathit{op}_k$, that reads a value $v_m$ from an object $o$,  is $r^k(o){v_m}$.
 \def\tuple#1{\langle #1\rangle}
 \par A session trace $\mathit{st}$ is a collection of tuples $\mathit{tup}_i$, where each tuple is denoted as $\tuple{w^i, {v_i}^{'},T^j}$ or
 $\tuple{r^i, {v_i}^{'},T^j}$. The fields comprising each tuple $\mathit{tup}_i$ are: 1) $w^i$  and $r^i$ are abbreviated signatures of write and read
 operations performed from a client application $\mathit{Cl}$, 2) ${v_i}^{'}$ is the value written or read by the above operation,
 3) $T^j$ is the timestamp of the operation execution, i.e., the timestamp when the operation was logged in the
  session trace. The \emph{global session trace} $\mathit{St}$ denotes the set of all
   session traces, which is equivalent to the global execution order $\sigma$ of Chockler et al. $\mathit{St}$ is a total
    order comprising all session traces collected from all clients executing in a system, arranged
    according to their temporal order of execution.  $\mathit{St}$ collates
    all the tuples  $\mathit{tup}_i$ from all individual session  traces, and orders the tuples according to
   according to descending order of the timestamp field $T^j$.
    Figure \ref{fig:System} illustrates the above system model.
   \par We do not assume anything regarding how these operations are internally handled by the datastore. For all intents and purposes, the datastore is a black box component on which read and write operations get executed. A client application executes these storage operations as high level API methods invoked from the application code. These API methods are translated into datastore specific native commands by the datastore driver which acts as an interface between the client application and the underlying datastore. %Within a given application scope, operations are invoked by the client application in a synchronous manner, i.e., an operation is invoked only once the result from the previous operation in the execution sequence is received.
    Optionally, read and write operations invoked from a transaction $tx$ are denoted as $r^k_{tx}(o){v_m}$ and $w^j_{tx}(o,v_l)$, respectively. %, passing values of objects as method parameters.
  Further, we do not assume anything regarding the nature of the datastore --- whether it is a standalone database, a transactional store, or a distributed datastore. Also, we do not make any assumptions regarding the configuration of the datastore, e.g., we do not assume what partitioning scheme or what normalization form (in case of RDBMS) a datastore follows. Our specifications restrict how client applications view results of storage operations, and is independent of how the underlying datastore internally processes storage operations. By not assuming anything regarding the implementation details, we render our specifications implementation independent, i.e., not specific to any particular datastore implementation. We further assume that a read operation $r^k_{tx}(o){v_m}$ always returns a unique value $v_m$ for an object $o$, and a write operation $w^j_{tx}(o,v_l)$ updates the value of an object $o$ to a unique value $v_l$.  This allows us to identify the particular write operation responsible for a particular value observed from a client application.
   %We consider concurrent read/write operations performed from a given application scope on a storage system that is configured to operate under a particular consistency model or a particular isolation level.
   %We develop a formal system for specifying the consistency and isolation models of a storage system.
%
%\section{Design of ConSpec}
%%We formally define a consistency model or isolation level with axiomatic rules that specify the manner in
%%which results of operations invoked from a given application can be observed by users or other client applications,
%% with respect to the session trace of the client application.
%
%Traditionally, specifications of consistency models or isolation levels are comprised of the following components: 1) rules that restrict the order in which results of operations can be observed, specified using axiomatic expressions, 2) anomalies precluded by the models, expressed using directed serialization graphs (DSGs), where vertices in a DSG represent operations, and edges represent the dependency relations among operations corresponding to the connecting vertices. The above definitions, comprising a combination of axiomatic rules and DSGs, can be difficult to comprehend, and subsequently may result in ambiguous interpretations of the model. This, in turn, may lead to incorrectly implemented storage systems, which do not conform to the correct specifications of the intended consistency models or intended isolation levels which the systems claim to provide. Further, state-of-the-art definitions of consistency and isolation models are tied to specific datastore implementations; making it impossible to apply a particular definition to the context of a different datastore, which is built according to different design principles.
%\par Further, axiomatic rules in state-of-the-art consistency and isolation definitions specify the valid order of execution among operations in terms of dependency relations, like write-write (ww), write-read (wr) dependency, etc. Such dependency relations belong to two categories - explicit dependencies, like ww dependency, and implicit dependencies, like read-write (rw) dependency, that are expressed in terms of one or more explicit dependencies. An axiomatic rule in a state-of-the-art definition specifies a combination of valid dependency relations comprising operations on datastore objects. These dependency relations are not apparent from the statement of consistency and isolation definition, especially implicit dependencies, since those are further described in terms of explicit dependencies. The anomaly DSGs in a state-of-the-art definition depict proscribed anomalies. Each DSG depicts the proscribed dependency relations among operations in a specific invalid execution sequence. Each operation in a proscribed execution sequence is represented as a vertex in the DSG, and the edge labels specify the proscribed dependency relations. Such anomaly DSGs can not be derived directly from consistency definitions of consistency and isolation.
%\par However, a given consistency or isolation level specifies a valid relative temporal order among operations. Such temporal order can be directly expressed using LTL operators, like next, eventually, etc.
%We argue that consistency and isolation levels can be readily expressed in term of LTL-like expressions
% that specify required temporal order among operations according to given consistency or isolation level.
% Hence, we follow in the footsteps of \cite{DBLP:journals/corr/EhlersR14} to develop a specification language
% \emph{ConSpec} that is an extension of Linear Temporal Logic (LTL). LTL is a natural choice for specifying relative temporal ordering among operations in different consistency and isolation definitions. ConSpec uses LTL-like semantics to express the rules that specify the allowed order in which results of operations can be visible to a client application, with respect to an observed session trace. ConSpec acts as a  unified modelling language that
%can be used to specify any consistency model or isolation level that is not specific to any particular target datastore. For a given consistency model or isolation level, we derive
% a single ConSpec expression that specifies the order in which results of operations invoked from a given client application can be observed from a client application. The ConSpec expressions specify the allowed temporal order (i.e., ``happens before" order \cite{Bailis:2013:BCC:2463676.2465279}) in which operations within a client application return results, and restricts the manner in which these results are visible to subsequent operations in the client application.
% \par We argue that our specifications are much easier to reason about than the state-of-the-art definitions, which require an understanding
% of the various dependency relationships; the implicit dependencies can be particularly complex to express and
% comprehend. Further, we also prove that the complexity of the analysis of session histories and verification of models
%  specified using ConSpec beats the state-of-the-art.
% Traditional \emph{server trace analysis} approaches perform trace analysis on server level execution traces, i.e.,
% execution traces collected from the server nodes comprising the underlying datastore.  Since the such approaches
% analyze \emph{server traces} (i.e., server level execution traces), they are dependent on the implementation and configuration
%  of a specific datastore instance, such as replication factor, partitioning scheme, etc. They analyze server traces to
%  check if any portion of the server traces matches the specified anomalies that a given consistency model or isolation
%  level proscribes; process terminates with a failure once a match is found against any of the proscribed anomalies.
%  Contrastingly, our approach analyzes session traces, making it completely implementation agnostic.

% %If every path in a given execution trace can be mapped to a path in the dependency graph corresponding to the given consistency model or isolation level, the execution trace is said to satisfy the above model.
% If every path in a given session trace can be mapped to the ConSpec formula corresponding to the given consistency model or isolation level, the session trace is said to satisfy the above model.

  \section{Syntax of ConSpec}
  Using the ConSpec modelling language, we develop specifications for commonly used consistency models and standardized isolation levels. Here, we present the ConSpec specifications for most common consistency models and isolation levels documented till date in the literature \cite{Chockler2000, Terry:1994:SGW:645792.668302, Burckhardt:2014:PEC:2693641.2693642}. We provide the detailed derivation of these specifications later in Section \ref{sec:derive}.
   The specifications comprise some special purpose LTL operators. Such operators are often qualified by scope operators
   that specify the context within which expression is
  restricted. For example, we define a special-purpose operator  $X^{o}$, which is derived
  from the  LTL modal operator ``next", i.e., $X$. The superscript ${o}$ in the above operator is used to specify that the
   operator defines the LTL relationship ``next" among only the operations performed specifically on the object ${o}$. The
    subscript $o$ specifies the context of an object $o$ for the enclosed relation; $o$ is equivalent to an operand for a
     storage operation. An expression ${W^j}^{'} X^{o} {R^k}^{'}$ denotes that among operations performed on the object
     ${o}$, an execution of the operation $r^k(o){v_m}$ immediately follows an execution operation $w^j(o,v_l)$; the
      superscript $'$ denotes an instance of execution of a given operation in a session trace. We also use the  LTL
      operator ``eventually", i.e., $F$, do denote that an operation is preceded by the another operation in a given
      execution sequence. The superscript ${o}$ in the above operator is used to specify that the operator defines the
       LTL relationship ``eventually" among only the operations performed specifically on the object ${o}$.
   \newtheorem{definition}{Definition}
   \begin{definition}(Generalized Specification)
   A ConSpec specification is a logical expression of the general form $\mathcal{E}$ = $<E^s = A \rightarrow B>; \mathcal{C}$, where $A$, $B$, and $C$ are LTL-like expressions comprising propositional logic variables which represent execution of storage operation, composed with both traditional LTL operators and specialised LTL-like operators. $\wedge$ is the logical conjunction operator, $\rightarrow$ is  the traditional ``implies" operator, and $<...>$ is a qualifier which denotes that the expression enclosed within the qualifier is optional, i.e., the condition represented by  enclosed expression is not a necessary condition.
    \end{definition}\label{def:long}
    %In a given specification $\mathcal{E}$, all operations referred to in  $A$ and $B$ are invoked from the same client application.
    %$A$ and $B$ can be thought of as the pre-condition and post-condition for a specification $\mathcal{E}$.
    In the above generalized expression $\mathcal{E}$, $A$ is a precondition expressed in terms of the of precedence relation among operations observed in a given session trace, $B$ is the necessary and sufficient postcondition that specifies a valid legal serialization for the given consistency or isolation level, and $\mathcal{C}$ represents the anomaly proscribed by the concerned consistency or isolation level. In other words, $A$ expresses some conditions
    regarding the order of storage operations in an observed session trace. $B$
    expresses conditions regarding a valid legal serialization order comprising the storage operations observed in a given session trace.
     In this paper, we specify each consistency or isolation level by presenting the corresponding expressions for $E^s$, and $C$, respectively.
     Alternatively, since the condition $E^s$ is both necessary and sufficient to specify a consistency model, the
      specification $\mathcal{E}$ in Definition \ref{def:long} can be rewritten to include only the condition
      $\mathcal{E}^{s}$, omitting the condition $C$. On the other hand, it might suffice to consider only the anomaly condition $C$
      if there is an anomaly present in a given session trace.
     %\begin{definition}(Shorter Specification)
%      The shorter form of specification for a consistency or isolation level is given by an expression
%      $\mathcal{E}^{s}$ = $A \rightarrow B$, where $A$ is a precondition regarding a session trace,  and $B$ is a postcondition that imposes restriction
%     that specifies a legal serialization for the given consistency or isolation level.
%     \end{definition}\label{def:short}
     Typically, the length of the expression $C$ is considerably larger than that of $E^s$. As shown below, for some consistency models,
     like Total Store Order (TSO) or Processor Consistency (PC), the length of $C$ is 4 or 5 times that of $E^s$. Hence,
      there is a tradeoff that needs to be considered to decide whether to use $E^s$ or $C$ for specifying a given
      consistency model or isolation level. The expression
      $\mathcal{C}$ in  Definition \ref{def:long} is a conjunction of multiple restricting conditions, and the
      verification process terminates as soon as just one of the above restrictions fail on a given session trace.
  Thus, in presence of anomalies in a session trace, the verification terminates earlier when $C$ instead of using $E^s$.
  Hence, the anomaly condition $C$ can be used for verification of a given session trace
      as the complexity of verification (time complexity) is better while considering $C$ instead of $E^s$. However, some
      consistency levels, like TSO, and all isolation levels, that may not be
   expressed in terms of $\mathcal{E}^{s}$,
  because of the absence of notions of $A$ and $B$, are specified using a \emph{restrictive} form of specification, given below.
  \begin{definition}(Restrictive Specification)
  The restrictive form of specification for a consistency or isolation level is given by an expression
      $\mathcal{E}^r$ = $C$, where $A$ is a precondition regarding a session trace,  and $B$ is a postcondition that imposes restriction
     that specifies a legal serialization for the given consistency or isolation level.
     \end{definition}\label{def:restrict}
 %\par A serialization is a sequence in which a group of storage operations are  executed on a datastore. A serialization is said to be legal if every read operation returns the value written by the latest write operation preceding it in the serialization. Chockler et al. \cite{Chockler2000} define a consistency model in terms of a legal serialization,
% comprising a linear arrangement of the operations performed by a client application, that the model allows.
%   Following Chockler et al., we also define consistency models with respect to a \emph{legal serialization} of a
%  given sequence of operations executed in a session trace. We use the notation $\mathit{Si}$ to denote a legal serialization comprising all operations
%  executed from a given client application.
%   Let the symbol $\mathit{st}$ denotes a given session trace for a given client application. Let $\mathit{St}$ denote the set of all
%   session traces, which is equivalent to the global execution order $\sigma$ of Chockler et al. $\mathit{St}$ is a partial order comprising
%   all session traces executed in a system. The operations executed in each individual session trace comprised in ordered in $\mathit{St}$ are ordered in $\mathit{St}$ according to
%   their temporal order of execution. Let the propositional variable ${\mathit{Op}^i}^{'}$ denote an execution of the
%   i\textquotesingle th operation executed from a given client application in a session trace.
%   \begin{definition}(Serialization)
%   Formally, we define $\mathit{Si}$ as
%   a sequence of propositional variables ${\mathit{Op}^i}^{'}$, each variable ${\mathit{Op}^i}$ denoting an execution of a
%   specific operation ${\mathit{op}}^i$ in a session trace $\mathit{st} \in \mathit{St}$, as follows.
%    $\mathit{Si}$ = $\left( {\mathit{Op}^i}^{'} \right),$ ${\mathit{Op}^i}^{'} \in \mathit{st}$, such that
%  $\forall \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'} \right)
%  \big( \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \right) \wedge \\
%  \big(\not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \right) \big) \wedge \left( {v_j}^{'} = {v_i}^{'} \right) \big)$.
%   \end{definition}\label{def:ser}
%   \begin{definition}(Serialization of a Partial Execution)
%   The notation $\mathit{Si}_p$ is used to denote a legal serialization of a partial execution comprising all    operations
%   performed by a given client application and all write
%  operations  executed from all other concurrent client applications; the above partial execution is denoted as $\sigma |i + w$ by Chockler et al.. Thus, we formally denote $\mathit{Si}_p$ as
%  \\ $\mathit{Si}_p$ = $\left( {\mathit{Op}^i}^{'} \right),$ $\left( {\mathit{Op}^i}^{'} \in \mathit{st} \right) \vee \left(
%  {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^i}^{'} \not\in \mathit{st} \right),$ such that
%  $\forall \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'} \right)
%  \big( \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \right) \wedge \\
%  \big( \not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \right) \big) \wedge \left( {v_j}^{'} = {v_i}^{'} \right) \big)$.
%  \end{definition}\label{def:parser}

\par State-of-the-art consistency levels and isolation levels have been defined in different forms. Consistency levels have been
 described in terms of valid legal serialization orders equivalent to a given execution by Chockler et al.
 \cite{Chockler2000}. A serialization is a sequence in which a group of storage operations are  executed on a datastore. A serialization is said to be legal if every read operation returns the value written by the latest write operation preceding it in the serialization. Chockler et al. \cite{Chockler2000} define a consistency model in terms of a legal serialization,
 comprising a linear arrangement of the operations performed by a client application, that the model allows.
   Following Chockler et al., we also define consistency models with respect to a \emph{legal serialization} of a
  given sequence of operations executed in a session trace. We use the notation $\mathit{Si}$ to denote a legal
  serialization comprising execution of all operations executed from all client applications on a system.
   Let the symbol $\mathit{st}$ denotes a given session trace for a given client application. %Let $\mathit{St}$ denote the set of all
%   session traces, which is equivalent to the global execution order $\sigma$ of Chockler et al. $\mathit{St}$ is a total
%    order comprising all session traces collected from all clients executing in a system. The operations executed in each individual session
%   trace comprised in ordered in $\mathit{St}$ are ordered in $\mathit{St}$ according to
%   their temporal order of execution.
 Let the propositional variable ${\mathit{Op}^i}^{'}$ denote an execution of the
   i\textquotesingle th operation executed from a given client application in a session trace.
   \begin{definition}(Serialization)
   Formally, we define $\mathit{Si}$ as
   a sequence of propositional variables ${\mathit{Op}^i}^{'}$, each variable ${\mathit{Op}^i}$ denoting an execution of an
    operation ${\mathit{op}}^i$ in a global session trace $\mathit{St}$, as follows.
    $\mathit{Si}$ = $\left( {\mathit{Op}^i}^{'} \right),$ ${\mathit{Op}^i}^{'} \in \mathit{St}$, such that
  $\forall \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'} \right)
  \big( \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \right) \wedge \\
  \big(\not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \right) \big) \wedge \left( {v_j}^{'} = {v_i}^{'} \right) \big)$.
   \end{definition}\label{def:ser}
   \begin{definition}(Serialization of a Client)
   We formally define serialization of a client, $\mathit{Si}_i$, as the restriction of the serialization to  the operations invoked by a particular client application, which in turn,
   corresponds to operations observed in a particular session trace $\mathit{st}$.
    $\mathit{Si}_i$ = $\left( {\mathit{Op}^i}^{'} \right),$ \\
     $\left( {\mathit{Op}^i}^{'} \in \mathit{Si} \wedge {\mathit{Op}^i}^{'} \in \mathit{st} \right)$.
   \end{definition}\label{def:clientser}
   \begin{definition}(Serialization of a Partial Execution)
   The notation $\mathit{Si}_p$ is used to denote a legal serialization of a partial execution comprising all    operations
   performed by a given client application and all write
  operations  executed from all other concurrent client applications; the above partial execution is denoted as $\sigma |i + w$ by Chockler et al.. Thus, we formally denote $\mathit{Si}_p$ as
  \\ $\mathit{Si}_p$ = $\left( {\mathit{Op}^i}^{'} \right),$ $\left( {\mathit{Op}^i}^{'} \in \mathit{st} \right) \vee \left(
  {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^i}^{'} \not\in \mathit{st} \right),$ such that
  $\forall \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'} \right)
  \big( \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \right) \wedge \\
  \big( \not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \right) \big) \wedge \left( {v_j}^{'} = {v_i}^{'} \right) \big)$.
  \end{definition}\label{def:parser}

 \section{List of ConSpec Specifications for Various Consistency and Isolation Levels}
  The Read Your Writes (RYW) model is stated as follows. Let us consider that a client application performs
    a write operation followed by a read operation on an object $o$, observed in any given session trace, obtained by executing the above client application.
    According to RYW, a read operation in the session trace must not observe the result of an earlier write
    operation, ie., it may not observe a value written before the occurrence of the write operation which
    immediately precedes the read. In other words, RYW specifies: if an operation $r^j$ reads an object $o$
    that was written by a  write $w^i$,  the $r^j$ must not return the value written by write operation $w^k$ that
    may have preceded $w^i$.
     In other words, it requires that $v_i \not= v_k$, where $\not=$ denotes the traditional arithmetic operator not equals.
  Let $\wedge$ be the logical operator for conjunction. An expression $A \wedge B$ denotes that both the conditions represented by the propositional logic variables $A$ and $B$ must hold.
  %Similarly, let $\oplus$ be the logical operator ``exclusive-or" (x-or). An expression $C \oplus D$ denotes that either $C$ is true or $D$ is true, but both $C$ and $D$ can not be true or false simultaneously.
    %RYW states: if there exist multiple writes in the session trace preceding the read $r^k(o){v_m}$, $r^k(o){v_m}$ must reflect the result of the most recent write $w^j(o,v_l)$ preceding $r^k(o){v_m}$. Let the propositional logic variables $W^j(v_l)$ and $R^k{v_m}$ represent the events that results of a write operation $w^j(o,v_l)$ and a read operation $r^k(o){v_m}$, respectively, are either observed (or not) in a session trace or the above operations occur in a program order (indicated by the value of the above variables being TRUE or FALSE). Let the wild card character $\star$ is a ``placeholder" for any combination of propositional variables (or none). For example, the expression $* A$ denotes that the propositional variable $A$ maybe preceded by any number of propositional variables, or maybe preceded by nothing.
  We use $\mathit{Si}_p$, specified in Definition \ref{def:parser}, to denote a legal serialization of all operations comprising a given client
  application, as well as all write
  operations  executed from all other concurrent client applications. In ConSpec format, the above RYW definitions are reduced to LTL-like expression, as follows.
  %\begin{align}\label{eqn:RYW}
%\begin{split}
% \forall i \left(\star w^j_{tx}(o,v_l)X^{o}r^k_{tx}(o){v_m} \star \right)_{o}^\mathit{po} \vdash \left(G\; \star w(o,v)X^{o}r(o) \star \right)_{o}^\mathit{st},
%  \end{split}
%  \end{align}
  %\begin{align}
%  \begin{split}
%\forall i, j, k, l, m, n, p, q \left(\star W^j(v_l)X^{o}R^k{v_m}\star\right)_{o}^\mathit{po}\\ \rightarrow \left(G\; \left( W^j(v_l) F^{o} W^p(v_q) F^{o} R^k{v_m} \right) \oplus \left( v_m = v_l \right) \right)_{o}^\mathit{st},
%  \end{split}
%  \end{align}\label{eqn:RYW}
  % \begin{align}
%  \begin{split}
%\forall i, j, k, l, m, n, p, q \left(\star W^j(v_m)F^{o}W^k(v_n)X^{o}R^l{v_p}\star\right)_{o}^\mathit{po}\\
%\rightarrow \big(G\; \left( \star W^j(v_m)F^{o}W^k(v_n)F^{o}R^l{v_p}\star \right) \\
% \oplus \left(  \star W^k(v_n)F^{o}W^j(v_m)F^{o}R^l{v_p}\star \right) \big)_{o}^\mathit{st},
%  \end{split}
%  \end{align}\label{eqn:RYW}
\begin{align}
  \begin{split}
%\forall i, j, o, S, \mathit{st} \big( \left( W^i F R^j \in \mathit{st} \right) \;
% \rightarrow \; \exists \mathit{Si}_p \left(  W^i F R^j \in \mathit{Si}_p \right)
%\\ \wedge  \not\exists W^k \in \mathit{st} \left( \left( W^k F W^i F R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( v^j = v^k \right) \right) \big).
% \mathcal{E}^{s} = \forall i, j, o, \mathit{St}, \mathit{st}\in \mathit{St} \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \\
% \rightarrow \; \exists \mathit{Si}_p \left(  {W^i}^{'} F {R^j}^{'} \in \mathit{Si}_p \right)\big)
%\\ C = \not\exists \left( \mathit{st}^{'} \in \mathit{St} \; \wedge \; {W^k}^{''} \in \mathit{st}^{'} \right) \\ \left( \left( {W^k}^{''} F {W^i}^{'} \in \mathit{St} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( {v^j}^{'} = {v^k}^{''} \right) \right).
  \mathcal{E}^{s} = \forall i, j, \mathit{st}
  \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right)
 \rightarrow \; \exists \mathit{Si}_p
 \left(  {W^i}^{'} F {R^j}^{'} \in \mathit{Si}_p \right)\big); \\
 C = \left( \not\exists {R^k}^{'}, {W^l}^{'} \in \mathit{St} \right)   \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right)   \\ \wedge
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^i}^{'} \in \mathit{St} \right)  %\big) \\
\wedge \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge  \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right)  \wedge
  \not\exists {W^m}^{'} \left( {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big).
  \end{split}
  \end{align}\label{eqn:RYW}.
   %where $G$ is the LTL operator globally.
    %The superscript $\mathit{st}$ specifies that the enclosed relation is given in the context of a session trace. %, representing the application scope of $\mathit{Cl}$.
\par Read/Session Monotonic (MR) specifies: read operations on a datastore object invoked from a client application or a session must always return results in an increasing order of recency as per their mutual order in the session trace.
 %Let $\gets$ be a logical operator which denotes the function ``returns", i.e., an expression $\mathit{val}_a \gets A$ denotes that an operation $\mathit{op}_A$, represented by the prostsitional variable $A$, returns a value $\mathit{val}_a$. For example, the expression $v_q \gets R^k(o){v_m}$ denotes that the read operation $r^k(o){v_m}$, represented by the propositional logic variable $R^k{v_m}$, returns a value $v_m$.
   MR is formally represented by the following expression.
\begin{align}\label{eqn:MR}
\begin{split}
%\forall i, j, k, l, m, n, q, r, s, t, u, x \big(\star ( W^j(v_l)X^{o}R^k{v_m} ) \\ \wedge ( W^n(v_q)X^{o}R^s{v_t} ) \wedge ( R^k{v_m}F^{o}R^s{v_t} ) \star \big)^\mathit{po}_{o} \\
%\rightarrow \big(G\; \star %\left( v_t = v_q \right) \wedge
%  (v_t = v_q ) \oplus ( W^n(v_q) F^{o} W^u(v_x) X^{o} R^s v_t ) \star \big)_{o}^\mathit{st}.
\mathcal{E}^{s} = \forall i, j, o, \mathit{St}, \mathit{st} \big( {R^i}^{'} F {R^j}^{'} \in \mathit{st}
 \rightarrow \;  \exists \mathit{Si}_p \left( {R^i}^{'} F {R^j}^{'} \in \mathit{Si}_p \right) \big); \\
 C = \left( \not\exists {W^m}^{''}, {W^n}^{''} \in \mathit{St} \right) \big( \left( {R^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \\ %\left( {\mathit{st}}^{'} \in \mathit{St} \right) \wedge
 \wedge \left( {W^m}^{''} F {W^n}^{''}  \in \mathit{St} \right) %\left( {W^m}^{''} F {W^n}^{''} F {R^i}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \\
  \wedge \left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \\ \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right)
 \wedge  \not\exists {W^p}^{'} \left( {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big)
\end{split}
\end{align}
 %According to the above equation, a session trace comprising an execution sequence that follows MR must return a value according to either of the following conditions: 1) according to the first expression $\left( R^k{v_m}F^{o}R^s{v_t} \right)$ comprising the exclusive-or in the RHS of the operator $\rightarrow$, it must return the value written by the latest write preceding the operation $r^s(o)v_t$, i.e., the value $v_q$ written by $w^n(o,v_q)$, or 2) according to the second expression $W^n(v_q) F^{o} W^u(v_x) X^{o} R^s v_t$ comprising the exclusive-or in the RHS, it must return the value $v_x$ written by the latest write $W^u(v_x)$ which overwrites $o$.
%\begin{align*}
%\begin{split}
%\forall i, j, k, l, m, n, q, r, s, t \big(\star \left( w^j(o,v_l)X^{o}r^k(o){v_m} \right) \\ \wedge \left( w^n(o,v_q)X^{o}r^s(o){v_t} \right) \wedge \left( r^k(o){v_m}F^{o}r^s(o){v_t} \right) \star \big)^\mathit{po}_{o} \\
%\vdash \big(G\; \star \left( v_m = v_l \right) \wedge \left( v_t = v_q \right) \\ \wedge \left( v_q \gets \left( r^k(o){v_m}F^{o}r^s(o){v_t} \right) \right) \star \big)_{o}^\mathit{st}.
%\end{split}
%\end{align*}\label{eqn:MR}
%\begin{align}\label{eqn:MR}
%\begin{split}
%\forall i, j, k, l, m, n, q, r, s, t, u, w, x, y, z \left(\star w^j(o,v_l)X^{o}r^k(o){v_m} \wedge w^n(o,v_q)X^{o}r^s(o){v_t} \wedge r^u(o){v_w}F^{o}r^x(o){v_y} \star \right)^\mathit{po}_{o} \\
%\vdash \left(G\; \star w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{st}.
% \end{split}
%  \end{align}
%. the operator $F$ is the LTL operator eventually.
 %In other words, Equation \ref{eqn:MR} mandates that $r^s(o){v_t}$ returns the value $v_q$ written by the latest write operation $w^n(o,v_q)$, or that written by another write $w^u(o,v_x)$ that overwrites $w^n(o,v_q)$). It does not allow $r^s(o){v_t}$ to return a value $v_l$ written by an earlier write operation  $w^j(o,v_l)$ which was invoked earlier than $w^n(o,v_q)$. The above constraint ensures that a read operation always views the latest version of the object $o$.
 \par Causal Consistency specifies: results of operations (in a given client application) that are bound by a causal relationship \cite{Bailis:2013:BCC:2463676.2465279} must be  visible in the session trace according to their mutual execution order with respect to an observed session trace. The ConSpec expression for Causal Consistency is given below.
 %\begin{align}\label{eqn:Causal}
%\begin{split}
%\forall i \left(\star w(o,v)F^{o}(w^{'}(o,v^{'})\oplus r(o)) \star \right)_{o}^\mathit{po} \\
%\vdash \left(G\; \star w(o,v)F^{o}(w^{'}(o,v^{'})\oplus r(o)) \star \right)_{o}^\mathit{st}.
%\end{split}
%  \end{align}
\begin{align}\label{eqn:Causal}
\begin{split}
%\forall i, j, k, l, m, n, p, q \big( \big( \left( mathit{Op}^j = \left( W^j(v_l) \oplus R^j{v_l} \right) \right) \\
%\wedge \left(   mathit{Op}^k = \left( W^k(v_m) \oplus R^k{v_m} \right) \right) \wedge \left( mathit{Op}^p = W^p(v_q)  \right) \big)
% \\ \wedge \big( \left( \left( mathit{Op}^j F^{o} mathit{Op}^k \right) \oplus \left( mathit{Op}^j X^{o} mathit{Op}^k \right) \right)  \\
% \vee \big( \left( \left( mathit{Op}^j F^{o} mathit{Op}^n \right) \oplus \left( mathit{Op}^j X^{o} mathit{Op}^n \right) \right)  \\
%\wedge \left( \left( mathit{Op}^n F^{o} mathit{Op}^k \right) \oplus \left( mathit{Op}^n X^{o} mathit{Op}^j \right) \right) \big) \big) \big)_{o}^\mathit{po} \\
%\rightarrow \big(G\;  \left( v_l = v_m \right) \oplus \left( mathit{Op}^j F^{o} mathit{Op}^p X^{o} mathit{Op}^k \right) \big)_{o}^\mathit{st}.
E^{s} = \forall i, j, k, o, \mathit{St}, \mathit{st} \big( \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right)
 \vee \big( \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \wedge \\
\left( {\mathit{Op}^j}^{'} = {R^j}^{'} \right) \wedge
   \left( v_i = v_j \right) \big) \rightarrow \exists \mathit{Si}_p \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{Si}_p \right) \big); \\
 C = \not\exists \left( {W^m}^{'} \in \mathit{St} \right) \big( %\left( \mathit{st}^{'} \in \mathit{St} \right) \wedge
   \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) %\left( {W^m}^{''} \in \mathit{St} \right)  \\
    \wedge \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \wedge \\
 \left( {W^m}^{'} F {\mathit{Op}^i}^{'}  \in \mathit{St} \right)
\wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee
 \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \\ \wedge
\not\exists  {W^n}^{'} \in \mathit{St} \left( {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big) \big) \big)
 \end{split}
  \end{align}
 %\begin{align*}
%\forall i, j, k, l, m, n, q, t, u, x, y, z, a \\
% \big(\star W^j(v_l) F^{o}  \left( W^n(v_q) X^{o} R^z{v_a}\oplus R^k{v_m} \right) \star \big)_{o}^\mathit{po} \\
%\rightarrow \big(G\; \star \left( v_q = v_l \right) \oplus \left( W^j(v_l) F^{o} W^t(v_u) F^{o} W^n(v_q)  \right) \\ \oplus \left( v_l = v_m \right) \oplus \left( W^j(v_l) F^{o} W^x(v_y) F^{o} R^k(v_m)  \right) \star \big)_{o}^\mathit{st}.
%  \end{align*}\label{eqn:Causal} %where $\oplus$ is the logical operator exclusive or (x-or). An expression $a \oplus b$ denotes that either $a$ is true or $b$ is true, but both $a$ and $b$ can not be true or false simultaneously.
  \par Strict Serializability specifies: any session trace must observe latest result of all operations in a client application. Using the notion of serialization of a client, given in Equation \ref{def:clientser},
  Strict Serializability is expressed as follows. \\
 %\begin{align}\label{eqn:Strict}
%\begin{split}
%\forall{i,j}\; \left(\star \mathit{op}_iX^{o}\mathit{op}_j \star \right)_{{o},{o_j}}^\mathit{po} \vdash \bigcap_{\mathit{st}\in \mathcal{S}} \left(G\; \star \mathit{op}_iX^{o}\mathit{op}_j \star \right)_{{o},{o_j}}^\mathit{st}c,
% \end{split}
%  \end{align}
 \begin{align}\label{eqn:Strict}
\begin{split}
%\forall{i, j, k, l, m, n, q, s, t}\; \big( \left( \mathit{Op}^j = \left(W^j(v_l) \oplus R^k{v_m} \right) \right) \\ \wedge \left(  \mathit{Op}^k = \left( W^n(v_q) \oplus R^s{v_t} \right) \right) \wedge \star \mathit{Op}^j X^{o} \mathit{Op}^k \star \big)_{o}^\mathit{po} \\ \rightarrow \big(G\; \star \left( v_q = v_l \right) \oplus \left( v_t = v_l \right) \oplus \left( v_t = v_m \right) \star \big)_{o}^\mathit{st}.
E^{s} =  \forall i, j, \mathit{st} \big( \mathit{Op}^i X^o {\mathit{Op}^j}^{'} \in \mathit{st}
\rightarrow \exists \mathit{Si}_i
 \left( {\mathit{Op}^i}^{'} X^o {\mathit{Op}^j}^{'} \in \mathit{Si}_i \right) \big); \\
%\vee \exists \left( \mathit{st}^{'} \in \mathit{St} \; \wedge \;  {\mathit{Op}^k}^{''} \in \mathit{st}^{'} \right)
% \\ \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^k}^{''} F {\mathit{Op}^j}^{'} \in \mathit{Si} \right) \big) \big) \\
 C =  \left( \not\exists {R^k}^{''} \in \mathit{St} \right)
 \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
 \left( {R^j}^{''} F {R^k}^{''} \in \mathit{St} \right)  \wedge \\
   \left( {v^k}^{''} = {v^i}^{'} \right)
   \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge
 \left( \not\exists {R^k}^{''}, {R^l}^{'}, {\mathit{Op}^i}^{'} \in \mathit{St} \right) \\
 \big( \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge
\left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathit{St} \right) \\ \wedge
   \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)
% \not\exists \big( \left( {R^i}^{'} F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \left( {R^i}^{''} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathit{St} \right) \big) \\
% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big) \wedge
% \not\exists \big( \left( {W^i}^{'} F {W^j}^{'} F {R^k}^{'} \in \mathit{st} \right) \wedge \\
% \left( {W^i}^{'} F {W^j}^{'} F {R^k}^{''} F {R^l}^{l'} \in \mathit{St} \right) \big)
% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{'} \not= {v^i}^{'} \right) \big)
%\forall \left( \left( {W^i}^{'}(x) F {R^j}^{'}(y) \in \mathit{st} \right) \wedge \left( {W^k}^{'}(y) F {R^l}^{'}(x) \in \mathit{st} \right) \right) \\
% \big( \not\exists \left( %\mathit{st}^{'} \in \mathit{St} \; \wedge \;
%  {W^m}^{''}(x) F {W^i}^{''}(x) F {R^l}^{''}(x) \in \mathit{st}  \right)
% \left( {v^l}^{''} = {v^m}^{''} \right) \wedge \\
% \not\exists \left( %\mathit{st}^{''} \in \mathit{St} \; \wedge \;
%  {W^n}^{'''}(y) F {W^k}^{'''}(y) F {R^j}^{'''}(y) \in \mathit{st}  \right)
% \left( {v^j}^{'''} = {v^n}^{'''} \right) \big)
% \wedge
%\big( \not\exists W^m(x), W^n(y) \in \mathit{st} \\ \big( \left( W^m(x) F W^i(x) F R^k(y) \in \mathit{st} \right) \wedge  \\
% \left( W^n(y) F W^l(y) F R^j(x) \in \mathit{st} \right) \wedge \left( v_k = v_l \right) \wedge \\
% \left( v_j = v_m \vee v_i = v_l \right) \big) \big) \big)  %\left( \mathit{Op}^i X^o \mathit{Op}^j \in \mathit{Si} \right) \\ \wedge \forall \mathit{st}  \left( \mathit{Op}^j X^o R^k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right) \big)
 \end{split}
  \end{align} %where $\mathit{op}_i$ is any operation (read or write), and $\mathcal{S}$ is the set of all session traces for a given client application. % scope.
  \par Write Follows Read (WFR) specifies: a write operation, that follows a read operation on a common datastore object, must happen while the object contains a value that is at least as old as the one  that was read by the preceding read operation. WFR is expressed as follow. \\
 \begin{align}\label{eqn:WFR}
\begin{split}
%\forall i, j, k, l, m, n, q, s, t, x, y \big( \star  W^j(v_l) F^{o}  R^k{v_m} \\ F^{o} W^n(v_q) F^{o} R^s{v_t} \star \big)_{o}^\mathit{st} \\
%\rightarrow \big(G \star %\left( v_m \gets \left( r^k(o){v_m} \right) \right)
% \left( v_t = v_q  \right) \oplus \left( W^n(v_q) F^{o} W^x(v_y) F^{o} R^s{v_t} \right) \star \big)_{o}^\mathit{st}.
E^{s} =  \forall i, j, \mathit{st} \big( \left( {R^i}^{'} F {W^j }^{'} \in \mathit{st} \right)
 \rightarrow \exists \mathit{Si}_p  \left(  {R^i}^{'} F {W^j}^{'} \in \mathit{Si}_p \right) \big); \\
 C = \not\exists \left( {R^k}^{'}, {W^l}^{'} \in \mathit{St} \right)   \big(%\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
\left( {R^i}^{'} F {R^k}^{'} \in \mathit{st} \right)   \wedge
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^j}^{'} \in \mathit{St} \right) \\ %\big) \\
\big( \left(  {v^k}^{'} = {v^l}^{'} \right)  \wedge
\big( \left( {v^i}^{'} = {v^l}^{'} \right) \vee  \
\big( \left( {R^i}^{'} F {W^j}^{'} \in \mathit{St} \right)  \wedge
 \not\exists  {W^m}^{'} \\ \left( {W^l}^{'} F {W^m}^{'} F {R^i}^{'} \in \mathit{St} \right)  \big) \big)  \wedge
 \left( \not\exists {R^i}^{''}, {W^j}^{''}, {R^k}^{''}, {W^m}^{''} \in \mathit{St} \right) \\ \big(
  \left( {R^i}^{''} F {W^j}^{''} F {R^k}^{''} \in \mathit{St} \right)
  \wedge \left(  {W^m}^{''}  F  {R^k}^{''} \in \mathit{St} \right) \wedge \\
 \left( {v^j}^{''} = {v^i}^{''} \right)
  \wedge \left( {v^m}^{''} = {v^k}^{''} \right)
   \wedge \left( {v^l}^{''} = {v^i}^{''} \right)  \wedge  \left( {v^m}^{''} = {v^l}^{''} \right) \\
  \vee \big( \left( {W^m}^{''} F { R^l}^{''} \in \mathit{St} \right)  \wedge
     \not\exists {W^n}^{''}  \left( {W^m}^{''} F {W^n}^{''} F { R^l}^{''} \in \mathit{St}  \right)  \big)  \big)
 %\big( %\left( \mathit{st}^{'}, \mathit{st}^{''} \in \mathit{St} \right) \wedge
% \left( {R^i}^{''} F {W^j}^{''} \in \mathit{st} \right) \wedge \left( {W^k}^{'} \in \mathit{St}  \right) \wedge \\
%  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge \left( {W^m}^{''} F {W^k}^{''} F {R^i}^{''} \in \mathit{st} \right) \big) \left( {v^m}^{'} = {v^i}^{'} \right) \\
%   \wedge \not\exists \big( \left( {R^i}^{'} F {R^n}^{'} \in \mathit{St} \right)  \wedge
%   \left( {W^p}^{''} F {W^j}^{''} \in \mathit{St} \right)  \wedge \left( {v^i}^{'} = {v^j}^{'} \right)   \big) \\
%     \left( {v^p}^{''} = {v^n}^{''} \right)
 %C = \not\exists \left( \mathit{st}^{'} \in \mathit{St} \; \wedge \; {R^n}^{''} \in \mathit{st}^{'} \right) \\
% \left( \left( {W^j}^{'} F {R^n}^{''} \in \mathit{St} \right) \wedge \left( {v^n}^{''} = {v^i}^{'} \right) \right)
\end{split}
  \end{align}
 %\begin{align}\label{eqn:WFR}
%\begin{split}
%\forall i \left( \star r(o)X^{o}w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{po} \\
%\rightarrow \left(\star w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{st}.
%\end{split}
%  \end{align}
 \par Monotonic Writes (MW) model is specified as: successive write operations invoked from a client application on a datastore object must occur according to their mutual order in the session trace.  MW is expressed as follows, in
 terms of a legal serialization for the given execution, specified in Definition \label{def:ser}.
  \begin{align}\label{eqn:MW}
\begin{split}
E^{s} = \forall i, j, \mathit{st} \big( {W^i}^{'} F {W^j}^{'} \in \mathit{st}  \rightarrow
  \exists \mathit{Si} \left( {W^i}^{'} F {W^j}^{'} \in \mathit{Si} \right) \big); \\
  C = \left( \not\exists {R^k}^{''}, {R^l}^{''}, {R^m}^{'} \in \mathit{St} \right)
   \big( \left( {W^j}^{'} F  {R^m}^{'} \in \mathit{st} \right) \wedge \\
   \left( {v_m}^{'} = {v_i}^{'} \right)
  \wedge \left( \not\exists  {R^k}^{'} F  {R^l}^{'} \in \mathit{St} \right) \big(
     \left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
   \left( {v_l}^{'} = {v_i}^{'} \right)  \big) \wedge
    \left( \not\exists  {W^p}^{'}, {R^n}^{'} \in \mathit{St}  \right)
    \big(  \left( {v_p}^{'} = {v_k}^{'} \right) \\
    \wedge  \left( {W^p}(x)^{'} F {R^k}(x)^{'} \in \mathit{St}  \right) \wedge
   \left(  {W^i}(x)^{'} F {R^n}(x)^{'} \in \mathit{St} \right) \\
    \wedge \left( {v_i}^{'} = {v_n}^{'} \right)   \wedge
    \left( {W^i}(x)^{'} F  {W^j}(y)^{'} \in \mathit{st} \right)  \wedge \\
    \left( {R^l}(y)^{'} F  {R^k}(x)^{'} \in \mathit{St} \right) \wedge
 \big(  \left( {v_p}^{''} = {v_n}^{''} \right)  \vee \\
 \big( \left( {W^p}^{'} F {R^n}^{'} \in \mathit{St} \right)  \wedge
      \not\exists {W^q}^{'} \left( {W^p}^{'} F {W^q}^{'} F {R^n}^{'} \in \mathit{St} \right)   \big) \big) \big)%\wedge \\
%\not\exists \left( %\mathit{st}^{'}, \mathit{st}^{''} \in \mathit{St} \; \wedge \;
% {W^t}^{'''} \in \mathit{St} \right)
%\big( \left( {W^i}^{'} = {W^m(x)}^{'} \wedge {W^j}^{'} =  {W^n(y)}^{'} \right) \\ \wedge \left( {R^p(y)}^{''} F {R^q(x)}^{''} \in \mathit{St} \right) \wedge
%\left( \left( {v_q}^{''} = {v_n}^{'} \right) \wedge \left( {v_p}^{''} =  {v_t}^{'''} \right) \right) \big)
\end{split}
  \end{align}.
   %\begin{align}\label{eqn:MW}
%\begin{split}
%\forall i \left(\star w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{po} \rightarrow \left(G\; \star w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{st}.
%\end{split}
%  \end{align}
 \par Owen et al. \cite{Owens:2009:BXM:1616077.1616107} specifies Total Store Order (TSO) as: read operations performed on the same datastore object by
  client applications can not return a subsequent (or newer) value unless the result of a given write is observed by all client applications, i.e., observed in all  session traces.
 A session trace for a client application can not view results of a sequence of write operations in an
 order which differs from the invokation order. %Let $\mathit{stores}$ be an integer term that denotes the total number of stores.
%  $\bigcap$ is equivalent to the logical operator union; an expression $\bigcap_{\mathit{store}_n}^{\mathit{stores}} A$
%  denotes that condition represented by the propositional logic variable $A$ must hold for any store $\mathit{store}_n$.
 % In the specification of TSO, we do not have a notion for the expressions $A$  and $B$.
  Following the format given in
  Definition \ref{def:restrict}, $E^r$ is specified in term
  of $C$ only. Thus, TSO can be expressed as follows.
 %\begin{align}\label{eqn:TSO}
%\begin{split}
%\forall i \left( \star (w(o,v)X^{o}r(o))\;F^{co}\; (w^{'}(o,v^{'})X^{o}r^{'}(o)) \star \right)_{o}^\mathit{po} \\ \rightarrow  \left( \bigcap_{\mathit{store}_j} (\star w(o,v)X^{o}r(o) \star) F^{o}\; w^{'}(o,v^{'})X^{o}r^{'}(o) \right)^\mathit{st}_{o}.
%\end{split}
%  \end{align}
  \begin{align}\label{eqn:TSO}
\begin{split}
%\forall{i, j, k, l, m, n, q, s, t, x, y, \mathit{store}_n}\;  \big( \left( \mathit{Op}^j = \left( W^j(v_l) \oplus R^k{v_m} \right) \right) \\
%\wedge \left( \mathit{Op}^k = \left( \left( W^n(v_q) X^{o} R^x{v_y} \right) \oplus R^s{v_t} \right) \right)
% \wedge \star  \mathit{Op}^j X^{o} \mathit{Op}^k \star \big)_{o}^\mathit{po}  \\
% \rightarrow  \big( \bigcap_{\mathit{store}_n}^{\mathit{stores}} (G\; \star \left( v_y = v_q \right) \oplus \left(  v_t = v_l \right) \oplus \left( v_t = v_m \right) \star \big)^\mathit{st}_{o}
%\forall i, j, o, \mathit{st}, \mathit{Si} \; \big( \mathit{Op}^i X W^j \in \mathit{st}
%\rightarrow \\ \bigcap_{\mathit{store}_n}^{\mathit{stores}} {\forall \mathit{Si} \left( \mathit{Op}^i X W^j \in \mathit{Si} \right) }
%\wedge \not\exists R^k  \left( \mathit{Op}^i X^o W^j X^o R^k \in \mathit{st} \right) \\ \wedge \left( v^k = v^i  \right) \big)
%\forall i, j, o, \mathit{st} \in \mathit{St} \big( {W^i}^{'} F {W^j}^{'} \in \mathit{st} \rightarrow  \exists \mathit{Si} \left( {W^i}^{'} F {W^j}^{'} \in \mathit{Si} \right) \wedge \\
 E^r = C = \forall \mathit{st} \not\exists  \big( \left({W^i}(x)^{'} \in \mathit{st} \right) \wedge \\
 \left({R^j}(x)^{''}, {R^k}(x)^{'} \in \mathit{St} \right) \big)
  \big( \left( {W^i}^{'}(x) F {R^j}^{''}(x) \in \mathit{St}  \right) \wedge \\
    \left( {v_j}^{''} \not= {v_i}^{'} \right)  \wedge
  %\big( \not\exists \big( \left({R^k}(x)^{'} \in \mathit{st}^{'} \right) \wedge  \\
  \left( {R^k}^{''}(x) F {R^j}^{''}(x) \in \mathit{St}  \right)
     \wedge \left( {v_k}^{''} \not= {v_i}^{'} \right) \big) \\
     \wedge
 %\not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
 \not\exists {W^l}^{'} \in \mathit{St} \big( \left(   {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right)  \wedge
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^i}^{'} \in \mathit{St} \right) \wedge \\ %\big) \\
 \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge
\big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right)  \wedge \\
 \not\exists  {W^m}^{'} \left( {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big) \big)
 %E^r = C = \\
% \forall \mathit{st}, \mathit{St} \; \big( \left( {W^i}(x)^{'} F {W^k}^{'}(y) \in \mathit{st} \right) \wedge \left( {W^l}(y)^{'} F {W^j}^{'}(x) \in \mathit{st} \right) \wedge \\
% \not\exists \left( %\mathit{st}^{'} \in \mathit{St} \; \wedge \;
%  {R^m}^{''}(y), {R^n}^{''}(x) \in \mathit{St} \right) \left( \left( {v_m}^{''} = {v_k}^{'} \right) \wedge \left( {v_n}^{''} = {v_l}^{'} \right)   \right) \wedge \\
% \forall \left( {W^i}(x)^{'} F {W^j}^{'}(y) \in \mathit{st} \; \wedge \; {R^k}(x)^{'} F {R^l}^{'}(y) \in \mathit{st} \right) \\
% \left( \not\exists \left( %\mathit{st}^{'} \in \mathit{St} \; \wedge \;
%  {W^m}(x)^{''} F {W^i}^{'}(y) F {R^k}^{'}(y) \in  \mathit{St}  \right)
% \left( {v_k}^{'} = {v_m}^{''}   \right) \right) \wedge \\
%  \forall \big( \left( {W^i}(x)^{'} F {W^j}^{'}(y) F {R^k}^{'}(z) \in \mathit{st} \right) \wedge \\
% \left( {R^l}^{'}(x) F {W^m}^{'}(v) F {W^p}^{'}(z) \in  \mathit{st} \right) \big) \\ \big( \not\exists \big( %\left( \mathit{st}^{''} \in \mathit{St} \right) \wedge
% \left( {W^m}(x)^{'''} F {R^l}^{'''}(x) \in \mathit{St} \right)    \wedge %\left( \mathit{st}^{''} \in \mathit{St} \right) \wedge
% \left( {W^t}(z)^{'''} F {W^p}^{'''}(z) \in \mathit{St}  \right) \big) \\
% \left( \left( {v_k}^{'''} = {v_t}^{'''}  \right) \wedge  \left(  {v_l}^{'''} = {v_q}^{'''}   \right) \right) \big) \big)
  %\forall i, j, o, \mathit{st}_x, \mathit{st}_y \big( W^i F W^j \in \mathit{st}_x, \mathit{st}_y
%\\ \rightarrow  \exists \mathit{Si} \left( W^i F W^j \in \mathit{Si} \right) \wedge
%\\ \not\exists R^m  \left( W^i F W^j F R^m \in \mathit{st}_x, \mathit{st}_y \right) \\
%\wedge \big( \left( \left( v^m = v^i \in \mathit{st}_x  \right) \wedge \left( v^m = v^j \in \mathit{st}_y \right) \right) \\
% \vee \left( \left( v^m = v^j \in \mathit{st}_x  \right) \wedge \left( v^m = v^i \in \mathit{st}_y \right) \right) \big) \big)
\end{split}
  \end{align}
 \par Processor Consistency specifies: operations in a client application must execute according to the invokation order
 across all processors; i.e., result of a preceding operation must be observed in all processors before result of a
 succeeding operation can be observed in any processor (or client application). Reads against  write operations should
  view the results of the writes
  according to the invokation order of these writes in a client application. % Let $\mathit{processors}$ be an  integer term that denotes the
% total number of processors. We can express the condition the propositional logic variable $A$ must hold for any store
% $\mathit{store}_n$ with the expression  $\bigcap_{\mathit{processor}_n}^{\mathit{processors}} A$.
  Thus, Processor Consistency can be expressed as follows.
 \begin{align}\label{eqn:PC}
\begin{split}
%\forall{i, j, k, l, m, n, q, s, t, x, y, \mathit{processor}_n} \\
% \big( \left( \mathit{Op}^j = \left(W^j(v_l) \oplus R^k{v_m} \right) \right) \wedge \\
%\left( \mathit{Op}^k = \left( \left( W^n(v_q) X^{o} R^x{v_y} \right) \oplus R^s{v_t} \right) \right) \wedge \\
%\star  \mathit{Op}^j X^{o} \mathit{Op}^k \star \big)_{o}^\mathit{po}
%\\ \rightarrow  \big( \bigcap_{\mathit{processor}_n}^{\mathit{processors}} (G\; \star \left( v_y = v_q \right) \oplus \left(  v_t = v_l \right) \oplus \left( v_t = v_m \right) \star \big)^\mathit{st}_{o}
E^{s} = C =   \forall \mathit{st} \not\exists \big( \left(  {W^i}^{'}, {W^j}^{'} \in \mathit{st}  \right)
\wedge \left( {R^k}^{'}, {R^l}^{'} \in \mathit{St} \right) \big) \\
\big( \left( {W^i}^{'} F {W^j}^{'} \in \mathit{st} \right) \wedge
  %\left( \mathit{st}^{'} \in \mathit{St} \right) \wedge \\
  \left( {R^k}^{'} F {R^l}^{'} \in \mathit{St} \right) \wedge
  \left( v_k^{''} = v_j^{'} \right)  \wedge \\
  \left( v_l^{'} = v_i^{'} \right) \big) \wedge
  \not\exists \left( {W^i}^{'}, {R^j}^{'}, {R^k}^{'}, {W^l}^{'}  \in \mathit{st}  \right)
  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \\ \wedge
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^i}^{'} \in \mathit{St} \right) \wedge  %\big) \\
 \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge
 \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big) \big)
 %\forall \big( %\left( \mathit{st} \in \mathit{St} \right) \wedge
% \left( {W^i}(x)^{'} F {W^j}(z)^{'} F {R^k}(y)^{'} \in \mathit{st} \right) \wedge \\
%  \left( {W^l}(y)^{'} F {W^m}(z)^{'} F {R^n}(x)^{'} \in \mathit{st} \right) \big) \\
%   \big( \not\exists \big( %\left( \mathit{st}^{'}, \mathit{st}^{''} \in \mathit{St}  \right) \wedge \\
%  \left( {W^p}(x)^{''} F {W^i}(x)^{''} \in \mathit{St}  \right) \wedge \left( {W^q}(y)^{'''} F {W^l}(y)^{'''} \in \mathit{St}  \right) \big) \\
%  \left( \left( v_i^{''} = v_k^{''} \right) \wedge \left( v_j^{'''} = v_m^{'''} \right) \right) \big) \wedge \\
%   \forall \big( %\left( \mathit{st} \in \mathit{St} \right) \wedge
%   \left( {W^i}(x)^{'} F {W^j}(y)^{'} \in \mathit{st} \right) \wedge \\ \left( {W^k}(y)^{'} F {W^l}(x)^{'} \in \mathit{st} \right) \big)
%   \big( \not\exists \big( %\left( \mathit{st}^{'}, \mathit{st}^{''} \in \mathit{St} \right) \wedge
%   \\ \left( {W^i}(x)^{''} F {R^m}(x)^{''} \in \mathit{St}  \right) \wedge
%   \left( {W^k}(y)^{'''} F {R^n}(y)^{'''} \in \mathit{St}  \right) \big) \\ \left( \left( v_m^{''} = v_i^{''} \right) \wedge \left( v_n^{'''} = v_j^{'''} \right) \right)
%\forall i, j, o, \mathit{st} \;  \big( \mathit{Op}^i F \mathit{Op}^j \in \mathit{st}
%\rightarrow  \exists \mathit{Si}_p \left( \mathit{Op}^i F \mathit{Op}^j \in \mathit{Si}_p \right) \\
%\wedge \forall \mathit{st} \not\exists R^k, R^l \left( \mathit{Op}^i X^o R^k F \mathit{Op}^j X^o R^l \in \mathit{st} \right) \\ \wedge \left( v^k \not= v^i  \right) \wedge \left( v^l = v^j \right) \big)
\end{split}
  \end{align}
 \par For specifying isolation levels, we consider only the isolation levels defined by Adya et al. \cite{DBLP:conf/icde/AdyaLO00}.
 The isolation level PL-1 mandates that write operations in  a transaction must be executed such that write-write
 dependency cycles among transactions are proscribed. %before any write from a different transaction executes.
  PL-1 is specified in the restrictive format, given in Definition \ref{def:restrict}, as follow.
 % \begin{align}\label{eqn:PL1}
%\begin{split}
%\forall i,j,k,l,m, tx, ty \left( tx F ty \; \wedge \; \star w^i_{tx} F w^j_{tx} \star \; \wedge \; \star w^k_{ty} F w^l_{ty} \star \right)^\mathit{po}_{o_m} \\
%\rightarrow \left(\star w^i_{tx} F w^j_{tx} \star \; \wedge \; \star w^k_{ty} F w^l_{ty} \star  \right)^\mathit{st}_{o_m},
%\end{split}
%  \end{align}
 %\begin{align}\label{eqn:PL1}
%\begin{split}
%\forall i,j, m, tx \left( \star w^i_{tx} F^{o} w^j_{tx} \star \right)^\mathit{po}_{o_m}
%\rightarrow \left(\star w^i_{tx} F^{o} w^j_{tx} \star  \right)^\mathit{st}_{o_m},
%\end{split}
%  \end{align}
  \begin{align}\label{eqn:PL1}
\begin{split}
%\forall i, j, k, l, m, n, p, q, u, z, tx \\ \big( \star W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} R^p_{tx}{v_n} \star \big)^\mathit{po}_{o} \\
%\rightarrow \big(G \star \left( v_n = v_q \right) \oplus \\ \left( W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} W^u_{tx}(v_z)  X^{o} R^p_{tx}{v_n}  \right) \star  \big)^\mathit{st}_{o},
%\forall i, j, tx \\ \big( \star W^i_{tx} F^{o} W^j_{tx}(v_q) X^{o} R^p_{tx}{v_n} \star \big)^\mathit{po}_{o} \\
%\rightarrow \big(G \star \left( v_n = v_q \right) \oplus \\ \left( W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} W^u_{tx}(v_z)  X^{o} R^p_{tx}{v_n}  \right) \star  \big)^\mathit{st}_{o},
%\forall i, j, o, \mathit{st}, \mathit{tx} \big( \left( W^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st} \right) \; \rightarrow \; \exists \mathit{Si}_p \left(  W^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{Si}_p \right)
%\\ \wedge  \not\exists R^k_\mathit{tx} \in \mathit{st} \left( W^i_\mathit{tx} F W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^k = v^i \right) \big),
 E^r = C = \forall \mathit{St}, \mathit{st}, \mathit{tx}, \mathit{ty}, x, y,
  {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx}, \\
  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty} \in  \mathit{St} \;
 %\mathit{tx} F \mathit{ty} \rightarrow
  \big( \left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \\
  % \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big) \big)
\end{split}
  \end{align} where $\mathit{tx}$ and $\mathit{ty}$  are consecutive transactions.

The isolation level PL-2 states that operations from a transaction can not read a value that was not the final value that was
committed by a transaction. Further, a transaction cannot read values written by aborted transactions. Additionally,
operations in a transaction must be executed in an order
that proscribes write-write and write-read dependency cycles \cite{DBLP:conf/icde/AdyaLO00} among transactions. PL-2 is given as
 % \begin{align}\label{eqn:PL2}
%\begin{split}
%\forall i, j, tx, ty \left( tx F ty \right)^\mathit{po}_{\mathit{op}_j} \rightarrow \left(\star c_{tx} F \mathit{op}^i_{ty} F c_{ty} \star \right)^\mathit{st}_{\mathit{op}_j},
%\end{split}
%  \end{align}
%\begin{align}\label{eqn:PL2}
%\begin{split}
%\forall i, j, m, tx, ty \left( tx F^{o} ty \; \wedge w^i_{ty} F^{o} r^j_{ty} \right)^\mathit{po}_{\mathit{o}_m} \rightarrow \\ \left(\star c_{tx} F^{o} w^i_{ty} F^{o} r^j_{ty} F^{o} c_{ty} \star \right)^\mathit{st}_{\mathit{o}_m},
%\end{split}
%  \end{align}
  \begin{align}\label{eqn:PL2}
\begin{split}
%\forall i, j, k, l, m, n, p, q, u, a, b, c, tx, ty \big( \left( tx F ty \right) \\ \wedge \left( \star W^j_{tx}(v_l)X^{o} R^k_{tx}{v_m} \star \right) \wedge \left( \star W^n_{ty}(v_q)X^{o} R^s_{ty}{v_u} \star \right) \big)^\mathit{po}_{\mathit{o}_i} \\
%\rightarrow \big( G \; \left( \left( v_m = v_l \right) \oplus \left( W^j_{tx}(v_l) F^{o} W^p_{tx}(v_a) X^{o} R^k_{tx}{v_m} \right) \right) F \;  c_{tx} \\ F \; \left( \left( v_u = v_q \right) \oplus \left( W^n_{ty}(v_q) F^{o} W^b_{ty}(v_c) X^{o} R^s_{ty}{v_u} \right) \right) \; F \; c_{ty} \star \big)^\mathit{st}_{\mathit{o}_i},
%\forall i, j, k, l, o, \mathit{st}, \mathit{tx}, \mathit{ty} \big( \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \\
%\wedge \left( W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)
%\; \rightarrow \; \exists \mathit{Si} \left( W^i_\mathit{tx} F R^j_\mathit{tx} F c_\mathit{tx} \in \mathit{Si} \right) \\
%\wedge \left(  c_\mathit{tx} F W^k_\mathit{ty} F R^l_\mathit{ty} F c_\mathit{ty} \in \mathit{Si}_p \right)
%\\ \wedge  \not\exists W^m_\mathit{tx} \in \mathit{st} \left( W^m_\mathit{tx} F W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \wedge \left( v^j = v^m \right) \\
%\wedge \not\exists W^n_\mathit{ty} \in \mathit{st} \left( W^n_\mathit{ty} F W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)  \wedge \left( v^l = v^n \right) \big)
E^{r} = C = \forall  \mathit{st}, \mathit{st}^{'}, \mathit{tx}, \mathit{ty} \big(
 % \mathit{tx} F \mathit{ty} \rightarrow
 \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
 \big(  {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st} \big) \\
  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
 \big( {W^k}(y)^{'}_\mathit{ty} F {R^l}(y)^{'}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
 \big( \not\exists  {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{tx}, \\ {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st}  \big)
 \big( \left( {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big)  \wedge
   \not\exists \left( {W^i}(x)^{'}_\mathit{ty}, {W^j}(x)^{'}_\mathit{ty}, {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st} \right) \\
    \big( \left(
 {W^i}(x)^{'}_\mathit{ty}  F {W^j}(x)^{'}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge
 %\mathit{tx} F \mathit{ty} \rightarrow
  \big( \\ \not\exists {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty}, {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \\ \big)
% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big) \big) %\wedge \\
%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \c\
%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
% \big( \not\exists  \left({R^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
%  \left({R^l}(y)^{'}_\mathit{ty} F {W^m}(y)^{'}_\mathit{tx} F {R^n}(y)^{'}_\mathit{tx} \in \mathit{St} \right)  \big) \big(  \left( v_k^{'} = v_j^{'} \right) \wedge \\
% \left( v_n^{'} = v_m^{'} \right) \big)
 %\big)
  %\left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right)  \big) \big)
 %\left( c_{ty} F {\mathit{Op}^i}^{'}_\mathit{tx} \in \mathit{st} \right) \big) \wedge \\
% \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx}, {W^j}(y)^{'}_\mathit{tx}, {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty} \in  \mathit{St} \right) \wedge  \\
%  \left( {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{st} \right) \big)
%  \big( \left( v_m^{'} = v_j^{'} \right) \wedge \left( v_n^{'} = v_k^{'} \right) \big)  \wedge \\
%  \forall \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{tx} \in \mathit{st} \right) \left( {v_i}^{'} = {v_j}^{'} \right) \big)
\end{split}
  \end{align} where $c_{tx}$ and $c_{ty}$ are the commit statements for the transactions $\mathit{tx}$ and $\mathit{ty}$, respectively. F is the traditional LTL next operator.

 The isolation level  PL-3 specifies that, on top of PL-2,  read-write dependency cycles \cite{DBLP:conf/icde/AdyaLO00}
  must also be proscribed among transactions. PL-3 is given as
 %\begin{align}\label{eqn:PL3}
%\begin{split}
%\forall i,j,k,l,m, tx, ty \left( tx F^{o} ty \; \wedge \; \star \mathit{op}^i_{tx} F^{o} \mathit{op}^j_{tx} \star \; \wedge \; \star \mathit{op}^k_{ty} F^{o} \mathit{op}^l_{ty} \star \right)^\mathit{po}_{o_m} \\
%\rightarrow \left(\star \mathit{op}^i_{tx} F^{o} \mathit{op}^j_{tx} F^{o} c_{tx} F^{o} \mathit{op}^k_{ty} F^{o} \mathit{op}^l_{ty} F^{o} c_{ty}  \right)^\mathit{st}_{o_m}.
%\end{split}
%  \end{align}
  \begin{align}\label{eqn:PL3}
\begin{split}
%\forall i, j, k, l, m, n, q, s, t, u, w, x, z, a, b, c, d, e, f, g, h, tx, ty \\
%\big( \left( tx F ty \right) \wedge \left( \mathit{Op}^j =  \left(W^j_{tx}(v_l) \oplus R^k_{tx}{v_m} \right) \right) \wedge \\
%\left( \mathit{Op}^n = \left( W^n_{tx}(v_q) \oplus R^s_{tx}{v_t} \right) \right)  \wedge \left( \star  \mathit{Op}^j X^{o} \mathit{Op}^n \star \right) \wedge \\
%\left( \mathit{Op}^u = \left(W^u_{ty}(v_w) \oplus R^x_{ty}{v_z} \right) \right) \wedge \left( \mathit{Op}^a = \left( W^a_{ty}(v_b) \oplus R^c_{ty}{v_d} \right) \right) \\
%\left( \star \mathit{Op}^u X^{o} \mathit{Op}^a   \star \right) \big)^\mathit{po}_{o} \\
%\rightarrow \big(G \; \left( v_f = v_q \right)  \oplus \left( v_t = v_l \right) \oplus \left( v_t = v_m \right) \big)  \\
%  F c_{tx} F \big( \left( v_h = v_b \right) \oplus \left( v_d = v_b \right) \oplus \left( v_d = v_z \right) \big) F c_{ty}  \big)^\mathit{st}_{o}.
%E^{r} = C = \big( \not\exists \left( a_\mathit{tx} \oplus a_\mathit{ty} \in \mathit{st} \right)
% \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st} \right)  \wedge
%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
% \not\exists \big( \big( \\
% {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \big)
%   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge \\
% %\mathit{tx} F \mathit{ty} \rightarrow
%  \left( \not\exists {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
%  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty}, {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \\
%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
%\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big) \wedge \\
%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \c\
%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
% \left( \not\exists {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^p}(x)^{'}_\mathit{tx}, {R^q}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \big(  \left( v_p^{'} = v_j^{'} \right) \wedge \\
% \left( v_q^{'} = v_i^{'} \right) \big)
%   \big) \big) \wedge
%%\forall  \mathit{St}, \mathit{st}, \mathit{st}^{'}, \mathit{tx}, \mathit{ty} \big(
%%  \mathit{tx} F \mathit{ty} \rightarrow \\
%% \big( \not\exists \left( \left( a_\mathit{tx} \in \mathit{st} \right) \wedge \left( a_\mathit{ty} \in \mathit{st} \right) \right) \wedge \\
%% %\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \right)  \wedge \left( v_k^{'} = v_i^{'} \right)  \right) \wedge \\
%%  \left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \\
%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%% \left( \not\exists {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^p}(x)^{'}_\mathit{tx}, {R^q}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \big(  \left( v_p^{'} = v_j^{'} \right) \wedge \\
%% \left( v_q^{'} = v_j^{'} \right) \big) \wedge
%%   \big) \big)
%%E^s =  \forall  \mathit{St}, \mathit{st} \in \mathit{St}, \mathit{tx}, \mathit{ty} \big(
%%  \mathit{tx} F \mathit{ty} \rightarrow \\
%% \big( \not\exists \left( a_\mathit{ty} F a_\mathit{tx} \in \mathit{st} \right) \wedge \not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right) \wedge \\
%   \not\exists \big( \left( {R^i}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right) \big) \\
%  \big( \left( \left( v_k^{'} = v_j^{'} \right)  \wedge \left( v_p^{'} = v_m^{'} \right) \right)  \big) \big) \big) \big)
E^{r} = C = \forall  \mathit{st}, \mathit{st}^{'}, \mathit{tx}, \mathit{ty} \big(
 % \mathit{tx} F \mathit{ty} \rightarrow
 \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
 \big(  {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st} \big) \\
  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
 \big( {W^k}(y)^{'}_\mathit{ty} F {R^l}(y)^{'}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
 \big( \not\exists  {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{tx}, \\ {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st}  \big)
 \big( \left( {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big)  \wedge
   \not\exists \left( {W^i}(x)^{'}_\mathit{ty}, {W^j}(x)^{'}_\mathit{ty}, {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st} \right) \\
    \big( \left(
 {W^i}(x)^{'}_\mathit{ty}  F {W^j}(x)^{'}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge
 %\mathit{tx} F \mathit{ty} \rightarrow
  \big( \\ \not\exists {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty}, {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \\ \big)
% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big) \wedge \\
%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \c\
%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
    \big( \not\exists {R^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^k}(x)^{'}_\mathit{ty}, {R^l}(y)^{'}_\mathit{ty}, {W^m}(y)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{tx} \in \mathit{St} \big)  \\
     \big( \big( {R^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in \mathit{St} \big) \wedge \\
  \big(  {R^l}(y)^{'}_\mathit{ty} F {W^m}(y)^{'}_\mathit{tx} F {R^n}(y)^{'}_\mathit{tx} \in \mathit{St} \big)  \big)  \\
  \big(  \left( v_k^{'} = v_j^{'} \right) \wedge
 \left( v_n^{'} = v_m^{'} \right) \big) \big) \big)
%\left( \mathit{Op}^i_\mathit{tx} X^o \mathit{Op}^j_\mathit{tx} \in \mathit{st} \right) \wedge
% \left( \mathit{Op}^k_\mathit{ty} X^o \mathit{Op}^l_\mathit{ty} \in \mathit{st} \right)
%\\ \rightarrow \exists \mathit{Si} \left( \mathit{Op}^i_\mathit{tx} X^o \mathit{Op}^j_\mathit{tx} F c_\mathit{tx} F \mathit{Op}^k_\mathit{ty} X^o \mathit{Op}^l_\mathit{ty} F c_\mathit{ty}  \in \mathit{Si} \right)  \wedge \\
% \forall \mathit{st}  \left( \mathit{Op}^j_\mathit{tx} X^o R^m_\mathit{tx} \in \mathit{st} \right) \wedge \left( v^m = v^j  \right) \wedge \\
% \forall \mathit{st}  \left( \mathit{Op}^k_\mathit{ty} X^o R^n_\mathit{ty} \in \mathit{st} \right) \wedge \left( v^n = v^k  \right) \big) \big)
\end{split}
  \end{align}
  The isolation level  PL-2.99 specifies that, on top of PL-2, read-write item-dependency cycles must be proscribed among transactions. PL-2.99 is given as
  \begin{align}\label{eqn:PL299}
\begin{split}
%\forall i, j, k, l, m, n, p, q, s, t, u, a, b, c, d, e, f, tx, ty \\ \big( \left( tx F ty \right) \wedge \left( \left( \star R^j_{tx}{v_l} F^{o} W^k_{tx}(v_m) X^{o} R^p_{tx}{v_t} \star \right) \right) \\ \wedge \left( \left( \star R^n_{ty}{v_s} F^{o} W^q_{ty}(v_u) X^{o} R^a_{ty}{v_b} \star \right) \right) \big)^\mathit{po}_{o_m} \\
%\rightarrow \big( G \left( v_t = v_m \right) \oplus \left( R^j_{tx}{v_l} F^{o} W^c_{tx}(v_d) F^{o} W^k_{tx}(v_m) X^{o} R^p_{tx}{v_t} \right) \\ F \;  c_{tx} \; F \; \\  \left( v_b = v_u \right) \oplus \left( R^n_{ty}{v_s} F^{o} W^q_{ty}(v_u) F^{o} W^e_{ty}(v_f) X^{o} R^a_{ty}{v_b} \right) \\ F \;  c_{ty} \big)^\mathit{st}_{o_m}.
%E^s =  \forall  \mathit{St}, \mathit{st} \in \mathit{St}, \mathit{tx}, \mathit{ty} \big(
%  \mathit{tx} F \mathit{ty} \rightarrow \\
% \big( \not\exists \left( a_\mathit{ty} F a_\mathit{tx} \in \mathit{st} \right) \wedge \not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right) \wedge \\
E^{r} = C = \forall  \mathit{st}, \mathit{st}^{'}, \mathit{tx}, \mathit{ty} \big(
 % \mathit{tx} F \mathit{ty} \rightarrow
 \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
 \big(  {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st} \big) \\
  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
 \big( {W^k}(y)^{'}_\mathit{ty} F {R^l}(y)^{'}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
 \big( \not\exists  {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{tx}, \\ {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st}  \big)
 \big( \left( {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big)  \wedge
   \not\exists \left( {W^i}(x)^{'}_\mathit{ty}, {W^j}(x)^{'}_\mathit{ty}, {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st} \right) \\
    \big( \left(
 {W^i}(x)^{'}_\mathit{ty}  F {W^j}(x)^{'}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge
 %\mathit{tx} F \mathit{ty} \rightarrow
  \big( \\ \not\exists {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty}, {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \\ \big)
% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big) \wedge \\
%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \c\
%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
    \big( \not\exists {R^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^k}(x)^{'}_\mathit{ty}, {R^l}(x)^{'}_\mathit{ty}, {W^m}(x)^{'}_\mathit{tx}, {R^n}(x)^{'}_\mathit{tx} \in \mathit{St} \big)  \\
     \big( \big( {R^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in \mathit{St} \big) \wedge \\
  \big(  {R^l}(x)^{'}_\mathit{ty} F {W^m}(x)^{'}_\mathit{tx} F {R^n}(x)^{'}_\mathit{tx} \in \mathit{St} \big)  \big)  \\
  \big(  \left( v_k^{'} = v_j^{'} \right) \wedge
 \left( v_n^{'} = v_m^{'} \right) \big) \big) \big)
%E = C = \forall i, j, k, l, o, \mathit{st}, \mathit{tx}, \mathit{ty} \big( \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( R^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st} \right) \\
%\wedge \left( R^k_\mathit{ty} F W^l_\mathit{ty} \in \mathit{st} \right)
%\\ \rightarrow \; \exists \mathit{Si} \left( R^i_\mathit{tx} F W^j_\mathit{tx} F c_\mathit{tx}  F R^k_\mathit{ty} F W^l_\mathit{ty} F c_\mathit{ty}\in \mathit{Si} \right) \\
%\\ \wedge  \not\exists R^m_\mathit{tx} \in \mathit{st} \left( R^i_\mathit{tx} F W^j_\mathit{tx} F R^m_\mathit{tx} \in \mathit{st} \right)  \wedge \left( v^i = v^m \right) \\
%\wedge  \not\exists R^n_\mathit{ty} \in \mathit{st} \left( R^k_\mathit{ty} F W^l_\mathit{ty} F R^n_\mathit{ty} \in \mathit{st} \right) \wedge \left( v^k = v^n \right) \big)
\end{split}
  \end{align}

\begin{figure*}[htpb]
\centering
%\noindent
\subfigure[RYW]{ \includegraphics[width=0.45\linewidth,height=6cm]{RYW.eps}\label{fig:label-ryw}}\hfill
\subfigure[MR]{\includegraphics[width=0.45\linewidth,height=6cm]{MR.eps}\label{fig:label-mr}}\hfill
\subfigure[Causal]{\includegraphics[width=0.45\linewidth,height=6cm]{Causal.eps}\label{fig:label-causal}}\hfill
\subfigure[Strict Serializability]{ \includegraphics[width=0.45\linewidth,height=6cm]{Strict.eps}\label{fig:label-strict}}\hfill
\subfigure[WFR]{ \includegraphics[width=0.45\linewidth,height=6cm]{WFR.eps}\label{fig:label-wfr}}\hfill
\subfigure[MW]{ \includegraphics[width=0.45\linewidth,height=6cm]{MW.eps}\label{fig:label-mw}}\hfill
\caption{Violation Examples}
%Manually chosen weak read-write consistency levels ONE/ANY are optimal (i.e., satisfy the subSLA) for low read proportions (i.e, in $<=55$\% cases) (Figures \ref{fig:label-8}, \ref{fig:label-9},
%\ref{fig:label-10}, \ref{fig:label-11}, \ref{fig:label-12}, \ref{fig:label-13}, and \ref{fig:label-14}). Manually chosen strong read-write consistency levels
%satisfy the subSLA for high read proportions (i.e, in $<=75$\% cases) (Figures \ref{fig:label-4}, \ref{fig:label-5}, \ref{fig:label-6}, and
%\ref{fig:label-7}).
%OptCon %is at least as effective as the optimal fixed consistency settings
% satisfies the subSLA (Figure \ref{fig:label-15}) for all possible read proportions by choosing the optimal consistency levels for each given read proportion.}
\end{figure*}

\begin{figure*}[htpb]
\centering
%\noindent
\subfigure[TSO]{ \includegraphics[width=0.45\linewidth,height=6cm]{TSO.eps}\label{fig:label-tso}}\hfill
\subfigure[PC]{\includegraphics[width=0.45\linewidth,height=6cm]{PC.eps}\label{fig:label-pc}}\hfill
\subfigure[PL-1]{\includegraphics[width=0.45\linewidth,height=6cm]{PL1.eps}\label{fig:label-1}}\hfill
\subfigure[PL-2]{ \includegraphics[width=0.45\linewidth,height=6cm]{PL2.eps}\label{fig:label-2}}\hfill
\subfigure[PL-3]{ \includegraphics[width=0.45\linewidth,height=6cm]{PL3.eps}\label{fig:label-3}}\hfill
\subfigure[PL-2.99]{ \includegraphics[width=0.45\linewidth,height=6cm]{PL299.eps}\label{fig:label-299}}\hfill
\caption{More Violation Examples}
%Manually chosen weak read-write consistency levels ONE/ANY are optimal (i.e., satisfy the subSLA) for low read proportions (i.e, in $<=55$\% cases) (Figures \ref{fig:label-8}, \ref{fig:label-9},
%\ref{fig:label-10}, \ref{fig:label-11}, \ref{fig:label-12}, \ref{fig:label-13}, and \ref{fig:label-14}). Manually chosen strong read-write consistency levels
%satisfy the subSLA for high read proportions (i.e, in $<=75$\% cases) (Figures \ref{fig:label-4}, \ref{fig:label-5}, \ref{fig:label-6}, and
%\ref{fig:label-7}).
%OptCon %is at least as effective as the optimal fixed consistency settings
% satisfies the subSLA (Figure \ref{fig:label-15}) for all possible read proportions by choosing the optimal consistency levels for each given read proportion.}
\end{figure*}

\section{Violation Examples: Verified \\ Against ConSpec Specifications}
  Using example session traces, we illustrate situations where a given consistency model is violated. Let us consider a
session trace $\mathit{st}_1$: $w^1(x,1), w^2(x,2), r^1(x){2}, r^2(x){1}$ to demonstrate how violation of RYW consistency can occur.
 From the session trace $\mathit{st}_1$, the following LTL expression  \\ $W^1 F W^2 F R^1 F R^2$ follows
 directly from the temporal order of execution as per the session trace. In $\mathit{st}_1$, the read operation $r^1(x){2}$
 follows the write operation $w^1(x,1)$ can be expressed by the LTL expression $W^1 F R^1$; which satisfies the
 condition given in LHS of the shorter specification $E^{s}$ in Equation \ref{eqn:MR} if $W^i$ = $W^1$, $R^j$ = $R^1$. The session trace
 $\mathit{st}_1$ can be transformed into the following partial legal serializations (that also comprises all write operations from other
 clients: $\mathit{Si}_p^1$ = $W^1 F R^2 F W^2 F R^1$, $\mathit{Si}_p^2$ = $W^2 F R^1 F W^1 F R^2$,
  and $\mathit{Si}_p^3$ = $R^1 F W^2 F W^1 F R^2$.
 Only for $\mathit{Si}_p^1$, the condition $W^1 F R^2 \in \mathit{Si}_p^1$ holds, which does not hold for $\mathit{Si}_p^2$ and $\mathit{Si}_p^3$.
 thus the condition corresponding to the RHS of the implies operator $\rightarrow$ in $E^{s}$ , given in Equation \ref{eqn:RYW}, holds.
  %$W^k$ preceding  $W^1$ such that the above LTL condition holds.
  Next, we consider the sequence in the session trace where the
   write operation $w^1(x,1)$ is followed by the read operation  $r^2(x){1}$, expressed by the LTL expression $W^1 F R^2$. As discussed before a partial
  serialization $\mathit{Si}_p^1$ exists for the session trace such that $W^1 F R^2 \in \mathit{Si}_p^1$, satisfying the first
  condition in the RHS of Equation \ref{eqn:RYW}.
  %Also, following the same argument as
%   above, there does not exist a $w^k$ such that the temporal order represented by the LTL condition $W^k F^x W^1 F^x R^2$ holds.
  Next, we consider the sequence write operation $W^2$ followed by $R^1$ in the session trace, given as $W^2 F R^1$.
  This implies that the condition $W^i F^x R^j$ in the LHS of the $E^{s}$ condition in Equation \ref{eqn:RYW} holds, where $W^i$ = $W^2$ and
  $R^j$ = $R^1$. Again a legal partial serialization $\mathit{Si}_p^1$ exists such that $W^2 F R^1 \in \mathit{Si}_p^1$.
%  Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does not exist
%  a write operation $W^k$ such that the LTL conditions $W^k F^x W^i F^x R^j$ and $v_j=v_k$ hold, where $W^i$ = $W^2$
%  and $R^j$ = $R^1$. Thus, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
  %$R^1$ returns a value 2 was written by the write operation $W^1$ which precedes $W^2$.
%   Thus the condition
%  $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( v^j = v^k \right)$ holds, where $\mathit{st}$ = $\mathit{st}_1$.
  Next, we consider the sequence write operation $W^2$ followed by $R^2$ in the session trace, given as $W^2 F R^2$.
  This implies that the condition $W^i F^x R^j$ in the LHS of $E^{s}$ in Equation \ref{eqn:RYW} holds, where $W^i$ = $W^2$ and
  $R^j$ = $R^2$. $\mathit{Si}_p^1$ is the only legal partial serialization that satisfies the condition $W^i F R^j \in \mathit{Si}_p$
   in the RHS of Equation \ref{eqn:RYW} for all the above write-read operation sequences. However, $\mathit{Si}_p$ does not satisfy
  $W^i F R^j \in \mathit{Si}_p$ for the write-read sequence $W^2 F R^2$.
  %Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does exist
%  a write operation $W^k$ = $W^1$ such that the LTL condition $W^k F^x W^i F^x R^j$ holds,  where $W^i$ = $W^2$ and
%  $R^j$ = $R^2$. Further, the read operation
%  $R^2$ returns a value 1 which was written by the write operation $W^1$ that precedes $W^2$. Thus the condition $v_j=v_k$
%  holds, and thus, in turn, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
  For anomaly
  condition $C$  in Equation \ref{eqn:RYW} to hold, their cannot exist in the global session trace a read operation $r^k$ preceding the read operation
  $r^j$ (which is $r^2(x){1}$) and a write operation $w^l$ preceding $w^i$ (which is $w^2(x,2)$ in this case)
   such that the LTL condition $\left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big(\left( {v^j}^{'} = {v^l}^{'} \right) \vee
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big)$ hold.
However, in the given session trace  $\mathit{st}_1$, there does exist a read $r^1(x){2}$ and a write $w^1(x,1)$, such that
conditions $\left(  {v^k}^{'} = {v^i}^{'} \right) $ and $\left( {v^j}^{'} = {v^l}^{'} \right)$ hold, thus, in turn,
violating the anomaly condition.
  Hence, the RYW condition is violated for the given session trace.
 %In $\mathit{st}_1$, read operations $r^1(x){2}$ and $r^2(x){1}$ follow the $w^2(x,2)$, the latest write operation on $x$,
%   satisfying the RHS of Equation \ref{eqn:RYW}. However, the value returned by $r^2(x){1}$ is 1, which does not match the
%    value written by the latest write operation $w^2(x,2)$ preceding $r^2(x){1}$; hence, $S_1 $does not satisfy the
%    condition $v_m = v_l$ in Equation \ref{eqn:RYW}.  Further, the value written by $w^2(x,2)$ is not overwritten by any
%     subsequent write preceding $r^2(x){1}$; hence, $S_1$ does not satisfy the condition
%     $W^j(v_l) F^{o} W^p(v_q) F^{o} R^k{v_m}$ in  Equation \ref{eqn:RYW}. Thus $S_1$ does not satisfy Equation
%     \ref{eqn:RYW}.
 \par Let us consider a session trace $\mathit{st}_2$:  $w^1(x,1)$, $\mathit{st}_2^{'}$: $w^2(x,2)$, and $\mathit{st}_2^{''}$: $r^1(x){1}, r^2(x){2}, r^3(x){1}$ to illustrate how
 violation of MR consistency can occur. Since the above session traces comprise write operations followed by read on the same object, as well
 as multiple read operations on same object x, they satisfy the conditions given in LHS of Equation \ref{eqn:MR}.
 First, let us consider the sequence of read operations $r^1(x){1}$ and $r^2(x){2}$ in $\mathit{st}^2$, given by the LTL expression $R^1 F^x R^2$.
 If and only if $R^i$ = $R^1$ and $R^j$ = $R^2$, the above sequence of reads can satisfy the LHS of the condition  $E^{s}$ in Equation \ref{eqn:MR}.
  The above traces can be transformed into legal partial serialization order $\mathit{Si}_p$ =
 $W^1 F R^1 F R^3 F W^2 F R^2$, such that $R^1 F R^2 \in \mathit{Si}_p$ holds, thus satisfying
 the first condition the RHS of the implies operator $\rightarrow$
 in  $E^{s}$ in Equation \ref{eqn:MR}.
   Next, we consider the sequence $r^1(x){1}$ followed by $r^3(x){1}$ in the above traces, given as the LTL expression $R^1 F R^3$. The above condition satisfies the LHS of $E^s$ Equation
   \ref{eqn:MR}, given that
  $R^i$ = $R^1$ and $R^j$ = $R^3$, which, in turn, implies $v_i$ = $v_1$ = 1 and $v_j$ = $v_2$ =1. As discussed above, a
  legal partial serialization $\mathit{Si}_p$ exists for the above trace, such that $R^1 F R^3 \in \mathit{Si}_p$
  holds; the condition $E^s$  in the RHS of Equation \ref{eqn:MR} holds for the above sequence of reads.
  %Also, $W^m$ and $W^n$ are the only write operations
%  that can satisfy the condition $W^m F^x W^n F^x R^i F^x R^j \in \mathit{st}$. Hence,
%  the second condition in the RHS requires that $W^m$ = $W^1$ and $W^n$ = $W^2$, and thus $v_m$ = $v_1$ = 1 and $v_n$ = $v_2$ = 2.
%  Hence,  $v_n \not= v_i$, which, in turn, implies that the condition $\left( v^i = v^n \right) \wedge \left( v^j = v^m \right)$
%  $\left( v^i = v^n \right) \wedge \left( v^j = v^m \right)$ holds. This, in turn, second condition in the RHS of
%  Equation \ref{eqn:MR} holds.
   Next, we consider the sequence $r^2(x){2}$ followed by $r^3(x){1}$ in the above traces, given
  as $R^2 F R^3$. However, the above sequence of reads does not match the order among these reads in the serialization  $\mathit{Si}_p$, i.e.,
  $R^2 F R^3 \in \mathit{Si}_p$ holds;
    thus it does not satisfy the first condition in the RHS of Equation \ref{eqn:MR}.
    Further, for the LHS of Equation \ref{eqn:MR} to hold for the above sequence of reads,   $R^i$ = $R^2$ and $R^j$ = $R^3$,
   which, in turn, implies $v_i$ = $v_2$ = 2 and $v_j$ = $v_3$ =1.
   For the anomaly condition $C$ in Equation \ref{eqn:MR} to hold for the sequence of read operations $r^1(x){1}$ followed by $r^3(x){1}$, there cannot exist write
  operations $w^m$ and $w^n$ corresponding to the reads $r^i$ and $r^j$  such that the LTL condition
  $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \\ \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathit{St} \right) \big)$ holds.
   Here, $W^m$ = $W^1$ and $W^n$ = $W^2$, since $W^m$ and $W^n$ are the only write operations in the given session history.
   Hence, $v_m$ = $v_1$ = 1 and $v_n$ = $v_2$ = 2. Also, it is given that
  $v_i$ = $v_1$ = 1 and $v_j$ = $v_2$ =2. Hence, the conditions $\left( v^i = v^n \right)$ and $ \left( v^j = v^m \right)$
  is satisfied; thus, in turn, the above LTL condition is also satisfied. Thus, the violation condition $C$
  in Equation \ref{eqn:MR} holds.
   %Also, $W^m$ = $W^1$ and $W^n$ = $W^2$. Hence,
%   $v_n$ = $v_i$ and $v_m$ = $v_j$. Thus, the second condition does not hold here.
    Hence, the above traces violate the MR condition.
   %\par
 % In $S_2$, $r^1(x){1}$ returns a value 1, whereas it should have returned 2, which is the value written by the latest write operation $w^2(x,2)$ preceding $r^1(x){1}$. Thus, $S_2$ does not satisfy the condition $v_l = v_m$. Since there are not write operations overwriting the latest write operation $w^2(x,2)$ preceding each read, the condition $W^j(v_l) F^{o} W^x(v_y) F^{o} R^k(v_m)$ holds. Following the same line of argument, we can show that $S_2$ does not
% satisfy any of the  conditions in RHS of Equation \ref{eqn:MR}. Hence, $S_2$ does not satisfy Equation \ref{eqn:MR}.
 \par Let us consider a session trace \\ $\mathit{st}_3$: $w^1(x,1), r^1(x){2}$, $\mathit{st}_3^{'}$: $r^2(x){1} w^2(x,2), r^3(x){1}$, and $\mathit{st}_3^{''}$: $r^4(x){2}, r^5(x){1}$ to demonstrate
 a violation of Causal consistency. Since, there are successive operations with direct precedence relation on the object x, $\mathit{st}_3$
 satisfies LHS of the $E^s$ condition in Equation \ref{eqn:Causal}.  We can transform
 the above session traces into a partial serialization $\mathit{Si}_p$ =
 $W^1 F R^2 F R^3 F R^5 F W^2 F R^1 F R^4$. First, let us consider the sequence of operations
 $w^1(x,1)$ and $r^1(x){2}$ in the above traces, given by the LTL expression $W^1 F R^1$. The above expression satisfies
 the condition $\mathit{Op}^i F^x \mathit{Op}^j$, where $\mathit{Op}^i$ = $W^1$ and $\mathit{Op}^j$ = $R^1$;
 thus satisfying the LHS of the implies operator $\rightarrow$ in $E^s$ in Equation \ref{eqn:Causal}. The above sequence of
 writes and reads satisfies the condition $W^1 F R^1 \in \mathit{Si}_p$, thus satisfying the first condition the RHS of
 the implies operator $\rightarrow$ in $E^s$ in Equation \ref{eqn:Causal}.
 %For the second condition in the RHS of
% Equation \ref{eqn:Causal} to hold, there cannot exist write  operations $W^m$ such that the LTL conditions
%   $W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}$ and $v^j = v^m$ hold.
% Since there is no such $W^m$ preceding $\mathit{Op}^i$, the second condition in the RHS of Equation \ref{eqn:Causal}
% holds for the above sequence of operations.
 Following the same line of argument, the sequence of operations
  $w^1(x,1)$ and $r^2(x){1}$, $w^1(x,1)$ and $r^3(x){1}$, $w^1(x,1)$ and $r^4(x){2}$, $w^1(x,1)$ and $r^5(x){1}$
  and $w^1(x,1)$ and  $w^2(x,2)$ satisfy the LHS and RHS of $E^s$ in the Equation \ref{eqn:Causal}. Next, let us consider
  the sequence of operations $w^2(x,2)$ and $r^3(x){1}$, which is expressed using LTL condition $W^2 F^x R^3$.
  Thus, the above sequence satisfies LHS of $E^s$ in the Equation \ref{eqn:Causal}. The above sequence of
 writes and reads do not satisfies the condition $W^2 F R^3 \in \mathit{Si}_p$, violating the RHS of $E^s$ in Equation \ref{eqn:RYW}.
  Let us consider the anomaly condition $C$ in Equation \ref{eqn:Causal} for the write and read operations $w^2(x,2)$ (which is
  $w^i$ in this case) and $r^3(x){1}$ (which is $r^j$ in this case). Since  $w^2(x,2)$ is followed by $r^3(x){1}$ in the session trace, they satisfy the LHS of the condition
  $C$. For the RHS of $C$ to hold, there cannot a exist write operations $w^m$ preceding the write $w^2(x,2)$ such that the
  LTL condition $\left( {v^j}^{'} = {v^m}^{''} \right) \vee
 \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big)$
 holds.
 We can assign $W^m = W^1$ since $w^1(x,1)$ precedes $w^2(x,2)$. Subsequently the condition $\left( {v^j}^{'} = {v^m}^{''} \right)$
 holds (since $R^j$ = $R^3$ and $v_j$ = 1 in this case). Hence, the RHS of $C$ is satisfied for Equation \ref{eqn:Causal} for the above sequence of operations.
 %Also, we can assign $W^m$ = $W^1$,
%   $\mathit{Op}^i$ = $W^2$, and $\mathit{Op}^j$ = $R^3$, such that the LTL conditions
%   $W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}$ holds. Further, $v_j$ = $v_m$ = 1, violating
%   the condition $\not\exists  \mathit{st} \left( W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}
%   \right) \wedge \left( v^j = v^m \right)$, violating the RHS of Equation \ref{eqn:Causal}.
 It results in
   violation of Causal consistency condition.
% \forall i, j, k, o, \mathit{st} \big( \exists \mathit{Op}^k \in  \mathit{st}
%\big( \mathit{Op}^i F \mathit{Op}^j \vee \\ \left( \mathit{Op}^i F \mathit{Op}^k  \wedge
%\mathit{Op}^k F \mathit{Op}^j \right)
%\vee \big( \left( \mathit{Op}^i = W^i \right) \wedge \left( \mathit{Op}^j = R^j \right) \wedge \\
%\left( \left( v_i = v_j \right) \vee \left( \left( v_i = v_k \right)
% \wedge \left( v_k = v_j \right) \right) \big) \right) \big)
%\\ \rightarrow \exists \mathit{Si}_p \left( \forall \mathit{Op}^i F \mathit{Op}^j \in \mathit{Si}_p \right)
%\wedge \not\exists  \mathit{st} \left( W^m F \mathit{Op}^i F \mathit{Op}^j \in \mathit{st} \right) \\
%\wedge \left( v^j = v^m \right) \big)

 %The operation $r^1(x){2}$ returns 2, which does not match the write operation
% $w^1(x,1)$ that directly preceded $r^1(x){2}$. Similarly, $r^3(x){1}$  does not return the correct value written by
% the latest write $w^2(x,2)$ which directly precedes $r^3(x){1}$. Thus, $S_3$ does not satisfy the conditions in Equation
% \ref{eqn:Causal}.
 All the above session traces violate the specification of Strict Serializability, given in Equation
 \ref{eqn:Strict}. Consider the session traces $\mathit{st}_3$, $\mathit{st}_3^{'}$, and $\mathit{st}_3^{''}$, which can be transformed into the legal
 serialization $\mathit{Si}$, which is, in this case, equivalent to  $\mathit{Si}_p$ in absence of writes from other
 client applications in the given session history (see above). The sequence of operations $w^1(x,1)$ and
 $r^1(x){2}$ in the above session trace satisfies the LHS of the condition $E^s$ (i.e., the condition
 $\mathit{Op}^i X \mathit{Op}^j$). Since $v_i \not= v_j$, the above sequence of write and read operations
 do not satisfy the condition  in the RHS of $E^s$, i.e., it violates the condition $W^1 X R^1 \in \mathit{Si}$.
 For the anomaly condition $C$ to hold for the above sequence of operations, let us consider the
 sequence of operations $w^2(x,2)$ and $r^3(x)1$. For the RHS of $C$ to hold, there cannot a exist write operations $r^k$ following the read $r^3(x)1$ such that the
  LTL condition $\big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge
 \not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathit{St} \right) \big) \\
 \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$
 holds.
 We can assign $r^k = r^4$ since $r^4(x)2$ follows $r^3(x)1$. Subsequently the conditions $\left( {v^k}^{''} = {v^i}^{''} \right)$
and $\left( {v^j}^{'} \not= {v^i}^{'} \right)$ holds, since $r^j$ yields $v_j$ = 1, and
 $r^k$ yields $v_k$ = 2.
 Thus, it also violates the anomaly condition in Equation \ref{eqn:Strict}, violating strict serializability.
 \par  We consider the session traces \\ $\mathit{st}_4$: $w^1(x,1)$, $\mathit{st}_4^{'}$: $r^1(x){1}, w^2(x,2)$, and
 $\mathit{st}_4^{''}$: $r^2(x){2}, r^3(x){1}$ to show how
 WFR consistency can be violated. The above session traces can be transformed into a legal serialization
 $\mathit{Si}_p$  = $W^1 F R^1 F R^2 F W^2$. The write operation $w^1(x,1)$ follows
  the read operation $r^1(x){1}$, and can be expressed as $W^1 F^x R^1$. The above expression satisfies
 the condition $W^i F R^j$, where $W^i$ = $W^1$ and $R^j$ = $R^1$. Hence, the above traces satisfy the
 condition in the LHS of Equation \ref{eqn:WFR}. Further, by observation, the above sequence of write-read
 operations satisfies the condition  $W^1 F R^1 \in \mathit{Si}_p$. Thus, the condition $E^s$ in the RHS of
 Equation \ref{eqn:WFR} holds. According to the anomaly condition $C$ in Equation \ref{eqn:WFR}, there must not
 exist a read operation $r^n(x)$ such that the conditions $\left( R^i F^x W^j F^x R^n \in \mathit{st} \right) \wedge
\left( W^j F^x R^n \in \mathit{st} \right)$ and $v^n = v^i$ are satisfied. Since $r^2(x){1}$ succeeds  $w^2(x,2)$, we can
assign $R^n$ = $R^2$. But, the read operation $r^2(x){1}$ returns a value 1 which was written by $w^1(x,1)$; thus
the condition $v^n = v^i$ holds. Thus, $\mathit{st}_4$ violates the second condition in
 RHS of Equation \ref{eqn:WFR}; hence, it violates WFR consistency.
 \par Let us consider the session traces \\ $\mathit{st}_5$: $w^1(x,1), r^1(x){2}, w^2(x,2)$, $\mathit{st}_5^{'}$: $r^2(x){2}$, and
 $\mathit{st}_5^{''}$: $r^3(x){1}, r^4(x){2}$, and demonstrate violation of
  MW consistency with it. The above session traces can be transformed in a legal serialization
  $\mathit{Si}$ = $W^1 F W^2 F R^1 F R^2$.
   Since the above session traces comprise a sequence of successive writes $w^1(x,1), w^2(x,2)$ on same object x,
   it can be expressed as $W^i F W^j$, thus satisfying the LHS of $E^s$ in Equation \ref{eqn:MW}, where $W^i$ = $W^1$ and $W^j$ = $W^2$.
  Also, the above sequence of write operations satisfies the first condition of the RHS of Equation \ref{eqn:MW},
  i.e., $W^i F W^j \in \mathit{Si}$. The above traces can be transformed into a legal serialization order $\mathit{Si}$ =
   $w^1(x,1), r^2(x){1}, w^2(x,2), r^1(x){2}$, thus satisfying the first condition in the RHS of Equation \ref{eqn:WFR}.
   For the anomaly condition $C$ to hold, there cannot exist a sequence of write operations $w^1(x,1)$ and
    $w^2(x,2)$ followed by a sequence of read operations $r^k$ and $r^l$ such that the following condition holds:
  $\left( \not\exists  {R^k}^{'} F  {R^l}^{'} \in \mathit{St} \right)
   \wedge  \left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
   \left( {v_l}^{'} = {v_i}^{'} \right)$. For the above session trace,
  we assign the operations $r^2(x){2}$ and $r^3(x){1}$ to the read operation $r^k$ and $r^l$. However, the above
  read operations $r^k$ yields $v_k$ = 2, and $r^l$ yields $v_l$ = 1, such that the condition
  $\left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
   \left( {v_l}^{'} = {v_i}^{'} \right)$ holds.
   %According to the RHS of Equation \ref{eqn:MW},  there must not exist a read operation $r^n(x)$ that satisfies the
%   conditions $ W^i F^x W^j F^x R^n \in \mathit{st}$ and $v^n = v^i$. In other words, any operation that
%   follows the above write sequence must not return a value updated by a write operation that precedes the latest write.
%   Since the read operation $r^1(x){1}$ succeeds the sequence of writes $W^1 F^x W^2$, $R^n$ = $R^1$. But, $r^1(x){1}$
%   returns the value 1; thus, the condition $v^n = v^i$ holds. Thus, $\mathit{st}_5$ violates the RHS of Equation \ref{eqn:MW},
%    and, in turn, violates MW consistency.
  \par Consider a group of 2 clients (or processors), namely $\mathit{Cl}_1$ and $\mathit{Cl}^2$, respectively.  Let us
  consider  that operations are invoked from the above 2 clients, and a session trace  $\mathit{st}_6$ is
  collected as follows.
  $\mathit{st}_6$: $w^1(x,1), r^1(y){1}$, $\mathit{st}_6^{'}$: $w^2(y,1), r^2(x){2}$. % In
%   $\mathit{st}_6$, the order of write operations $w^1(x,1)$ and $w^2(y,1)$ are different in each of the
%  2 session traces. In $\mathit{st}^2$, $r^2(x){1}$ returned while $w^1(x,1)$ did not yet execute. In
%  $\mathit{st}_1$, $w^1(x,1)$ executed but $r^2(x){1}$ did not execute.
  For the above session trace to satisfy TSO consistency, the condition
  $\left( {W^i}^{'}(x) F {R^j}^{''}(x) \in \mathit{St}  \right) \wedge \\
    \left( {v_j}^{''} \not= {v_i}^{'} \right)  \wedge
  %\big( \not\exists \big( \left({R^k}(x)^{'} \in \mathit{st}^{'} \right) \wedge  \\
  \left( {R^k}^{''}(x) F {R^j}^{''}(x) \in \mathit{St}  \right)
     \wedge \left( {v_k}^{''} \not= {v_i}^{'} \right)  \\
     \wedge
 %\not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right)  \wedge
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^i}^{'} \in \mathit{St} \right) %\big) \\
\wedge \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \\
\big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right)  \wedge \\
 \not\exists  {W^m}^{'} \left( {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big)$
  must hold. In the above session traces, let us assign the operation  $w^1(x,1)$ as $w^i$. $r^2(x){2}$ occurs in another session trace, and thus invoked was from a different client. Further,
  $r^2(x){2}$ follows $w^1(x,1)$ in the global session order. Hence we can assign the operation
  $r^2(x){2}$ as $r^j$. Since $r^2(x){2}$ returns 2 instead of 1, the condition ${v_j}^{''} \not= {v_i}^{'} $ does not hold.
  Also, there doesn't exist an operation $r^k$ preceding $r^2(x){2}$ that satisfies the condition ${v_k}^{''} \not= {v_i}^{'} $.
  Thus, the given session trace violates Equation \ref{eqn:TSO}.
    \par  Consider two client applications (or processors), namely $\mathit{Cl}_1$ and $\mathit{Cl}^2$,
  respectively. Consider a session trace collected by executing operations on the above client  applications as follows.
   $\mathit{st}_7$: $w^1(x,1), w^2(y,1)$,    $\mathit{st}_7^{'}$: $r^1(x){1}$,  $\mathit{st}_7^{''}$:
  $r^2(y){1}, r(x){1}$. To satisfy the PC consistency, any sequence of write operations $w^i$ and $w^j$ invoked by a client must satisfy
  the condition $\big(\not\exists \left( {W^i}^{'} F {W^j}^{'} \in \mathit{st} \right) \wedge
  \left( \mathit{st}^{'} \in \mathit{St} \right) \wedge
  \left( {R^k}^{'} F {R^l}^{'} \in \mathit{st}^{'} \right) \big)
 \big( \left( v_k^{''} = v_j^{'} \right) \wedge \left( v_l^{'} = v_i^{'} \right)\big)$. Thus, there must not exists a sequence of
 reads $r^k$ and $r^l$ such that the condition  $\left( v_k^{''} = v_j^{'} \right) \wedge \left( v_l^{'} = v_i^{'} \right)$
 holds. In the above session traces, the write operations  are executed according to the precedence order
  $w^1(x,1)$ followed by $ w^2(y,1)$, hence we assign $w^1(x,1)$ and $ w^2(y,1)$ as $w^i$ and $w^j$. Also, let us assign
  the sequence of read operations $r(x){1}$  and $r^2(y){1}$ as $r^k$ and $r^l$, respectively. According to the
   above condition, reads against the above writes should view the results of the above write operations
  according to the invocation order of these writes. However, in the given session trace, the client application
  $\mathit{Cl}_2$ observes the above writes out of order. Since  $r^2(y){1}$ executes before ,$r(x){1}$ in the above session
  traces, $\mathit{Cl}_2$ observes the result of $w^2(y,1)$ before observing result of $w^1(x,1)$.  Thus,
   the above traces violate Equation \ref{eqn:PC}.
 \par Consider a session trace $\mathit{st}_8$: $w^1_{tx}(x,2), w^2_{ty}(x,5),  w^1_{ty}(y,5), \\ c_{ty},
 w^2_{tx}(y,8), r^1_{ty}(x){5}, r^2_{ty}(y){8}, c_{tx}$. According to the  specification of PL-1 isolation level
 (refer to Equation \ref{eqn:PL1}), there cannot exist read operations $r^m_\mathit{ty}$ and $r^n_\mathit{ty}$ such that they satisfy the condition
 $\left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \\ \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right) $.
 In the session trace $\mathit{st}_8$, the write operations $w^1_{tx}(x,2)$,  $w^2_{tx}(y,8)$, $w^2_{ty}(x,5)$, and $w^1_{ty}(y,5)$
 are $W^i_{tx}$,  $W^j_{tx}$,  $W^k_{ty}$, and  $W^l_{ty}$, respectively. Also, we can assign the read operations $r^1_{ty}(x){5}$ and $r^2_{ty}(y)8$ as $r^m_\mathit{ty}$
 and $r^n_\mathit{ty}$, respectively. Under the above assignment, we have $v_m$ = 8 and $v_n$ = 5, which in turn,
 satisfies the conditions $\left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'}\right)$.
  % The observed execution order in transactions $tx$ and $ty$ are given as
%  $w^1_{tx}(o_1,5)$, $w^2_{tx}(o_2,8)$ and $w^1_{ty}(o_1,5)$, $w^2_{ty}(o_2,5)$, respectively. In $\mathit{st}_8$,
%  write operations in transaction $tx$ execute in the order $w^1_{tx}(o_1,5)$, $w^2_{tx}(o_2,8)$.
%  However,  the write operations in transaction $ty$ execute in the order $w^2_{ty}(o_1,5),  w^1_{ty}(o_2,5)$.
  This, in turn, satisfies the anomaly condition for PL-1. Thus, $\mathit{st}_8$ violates
  PL-1.
  \par Let us consider a session trace \\ $\mathit{st}_9$: $w^1_{tx}(x,1), r^1_{t_y}(x){1}, w^2_{tx}(x,2), c_{ty}, c_{tx}$.
  According to PL-2 (refer to Equation \ref{eqn:PL2}), a transaction never must read a value from an operation
  if the transaction executing above operation has not yet committed. In other words there must not exist a read operation
 $r^k(x)_\mathit{ty}$ such that $r^k(x)_\mathit{ty}$ reads a value written by a write operation  $w^i(x)_\mathit{tx}$
 that does not write the final (committed) version of the object $x$ for the transaction $\mathit{tx}$, i.e., the condition
  $\not\exists \big( \big(
 {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \big)
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge
   \not\exists \big( \big(
 {W^i}(x)^{'}_\mathit{ty}  F {W^j}(x)^{'}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \big)
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big)$ does not hold. In the session trace $\mathit{st}_9$, the read operation
   $r^1_{ty}(x){1}$ returns a value 1 written by the operation $w^1_{tx}(x,1)$ in transaction $tx$. However, the write
   operation $w^2_{tx}(x,2)$, which follows $w^1_{tx}(x,1)$ in $\mathit{st}_9$, writes the committed version (i.e., the
   final version) of $x$, which is 2. Thus, the above condition does not hold for  $\mathit{st}_9$, resulting in violation of PL-2.
  \par Consider a session trace \\ $\mathit{st}_{10}$: $r^1_{tx}(\mathit{tx}){50}, r^1_{\mathit{ty}}(x){-50}, r^2_{\mathit{ty}}(y){100},
  w^1_{\mathit{ty}}(x,100), w^2_{\mathit{ty}}(y,50), \\
   c_{\mathit{ty}},  w^1_{\mathit{tx}}(y,-50), r^2_{\mathit{ty}}(x){100}, r^2_{\mathit{tx}}(y){-50}, c_{\mathit{tx}}$.
  In $\mathit{st}_{10}$, the read operation $r^1_{\mathit{tx}}(x){50}$ on object $x$ in $\mathit{tx}$ is followed by write
  operation  $w^1_{\mathit{ty}}(x,100)$.
    The read operation $r^2_{\mathit{ty}}(x){100}$ following the commit $c_{\mathit{ty}}$ returns the value 100, indicating a rw
    dependency between transactions $\mathit{tx}$ and $\mathit{ty}$. Similarly, the read operation $r^2_{\mathit{ty}}(y){100}$
     on object $y$ in $\mathit{ty}$ is followed by write
  operation  $w^1_{\mathit{tx}}(y,50)$.
    The read operation $r^2_{\mathit{tx}}(y){-50}$ following the commit $c_{\mathit{ty}}$ returns the value -50, implying
    a read-write dependency between  $\mathit{ty}$ and $\mathit{tx}$.
    %This causes anomaly DSGs comprising of anti-dependency edges
   %(r-w dependencies) between operations $r^1_{tx}(x){50}$ and $w^1_{ty}(x,100)$, and between $ w^2_{ty}(y,50)$
  % and $r^2_{tx}(y){-50}$, which are proscribed by PL-3.
  Thus, there is a read-write dependency cycle in $S_{11}$, violating PL-3 specifications. Let us consider a session trace
   $\mathit{st}_{11}$: $r^1_{tx}(\mathit{tx}){50}, r^1_{\mathit{ty}}(x){-50}, \\
   r^2_{\mathit{ty}}(x){100}, w^1_{\mathit{ty}}(x,100),  w^2_{\mathit{ty}}(y,50), c_{\mathit{ty}},
    w^1_{\mathit{tx}}(x,-50), r^2_{\mathit{ty}}(x){100}, \\ r^2_{\mathit{tx}}(x){-50}, c_{\mathit{tx}}$
   Following similar line of reasoning, we can
   observe that the session trace   $\mathit{st}_{11}$ violates the isolation level PL-2.99, given in Equation \ref{eqn:PL299}.

\section{Deriving ConSpec Specifications From the State-of-the-Art Definitions}\label{sec:derive}
 Here we show how the ConSpec specifications can be directly derived from state-of-the-art specifications of
 consistency and isolation level \cite{Chockler2000, Terry:1994:SGW:645792.668302}. As already discussed,
 state-of-the-art consistency specifications define axiomatic rules for consistency models using first order
 logic expressions.  Consistency definitions are specified by Chockler et al. \cite{Chockler2000} as follows.
 They use the following formalization syntax in their definitions. Consider two operations $\mathit{op}^1$ and
 $\mathit{op}^2$ invoked from a client application, such that $\mathit{op}^1$ is a write operation that updates
 a datastore object $o$, and $\mathit{op}^2$ is a read operation that reads $o$. The symbol $\rightarrow$ denotes
  precedence relationship \cite{Bailis:2013:BCC:2463676.2465279} between two operations. Chockler et al. used the
  notation $\sigma$ to denote an execution of a sequence of read and write operations performed by a client
  application (referred to as a  process by Chockler). They also use
  a specialised form of the precedence operator, $\xrightarrow{\sigma}$, where the superscript $\sigma$
  is used to indicate that the precedence relationship is defined specifically with respect to  an execution
  $\sigma$ by a client application.  Thus, an expression $\mathit{op}^1 \xrightarrow{\sigma} \mathit{op}^2$
  indicates that an execution of the operation $\mathit{op}^1$ precedes, i.e., happens before, an
  execution of the operation $\mathit{op}^2$ in an execution sequence $\sigma$. The consistency definitions by
  Chockler et al. specify the allowed order of operations with respect to a \emph{serialization}, which is
   a linear sequence of operations formed with the operations  in a given execution sequence. They denote a partial
    execution comprising all operations performed by a process (or a client application) and all write operations from
    from other processes as $\sigma |i + w$. They denote a legal serialization for the above partial execution as $S_i$;
    we denote the above legal serialization as $\mathit{Si}_p$.  For means and
   purposes of this paper, an execution sequence $\sigma$ according to the terminology of Chockler et al. is
   equivalent to a session trace $\mathit{st}$ in ConSpec. %An execution order $\sigma$ (invocation order) in
%   \cite{Chockler2000}of Chockler et al.  is equivalent to the program order $\mathit{po}$ in ConSpec.
 Hence,  we assign the notation $\mathit{st}$ to an execution sequence $\sigma$ in Chockler's definitions.
  We can rewrite the precedence relation $ \mathit{op}^1 \xrightarrow{\sigma} \mathit{op}^2 $, in terms of Linear Temporal Logic
 (i.e., LTL) $\mathit{op}^1 F \mathit{op}^2 \in \mathit{st}$, where we replace the precedence  operator $\rightarrow$ with the
 equivalent LTL operator $F$ that denotes ``eventually".
  The definitions by Chockler et al.  express a precedence relation $\mathit{op}^1 \rightarrow \mathit{op}^2$ in a serialization ${S_i}$
   as $\mathit{op}^1 \xrightarrow{S_i} \mathit{op}^2$,  where we specify the scope of the precedence operator $\rightarrow$
   with the serialization ${S_i}$. We can rewrite the above precedence relation as
  $ \mathit{op}^1 \xrightarrow{S_i} \mathit{op}^2 $, in terms of Linear Temporal Logic (i.e., LTL)
  $\mathit{op}^1 F \mathit{op}^2 \in \mathit{Si}$,
  where we assign the notation $\mathit{Si}$ to a serialization ${S_i}$, and replace the precedence
  operator with the equivalent LTL operator $F$ that denotes ``eventually". Also, Chockler et al.
  bases their definitions on a serialization of an execution sequence comprising all operations performed
  by a client application (or a process), along with writes by all other clients. In ConSpec,
  we denote such a serialization as $\mathit{Si}_p$. We can express the precedence relation for such a
  serialization in terms of LTL  as $ \mathit{op}^1 F \mathit{op}^2 \in \mathit{Si}_p$.
 \par Let $w^i$ and $r^j$ be signatures of read and write operations $\mathit{op}^1$ and
 $\mathit{op}^2$, respectively.
  Chockler et al. states the RYW consistency model as: if the condition represented by the expression
  $\mathit{op}^1 \xrightarrow{\sigma} \mathit{op}^2$ holds for a given execution sequence $\sigma$
  (let us call this Condition 1) comprising the above write and read operations, there must exist a serialization ${S_i}$,comprising the
   operations $\mathit{op}^1$ and $\mathit{op}^2$, for which the condition given by the expression
  $\mathit{op}^1 \xrightarrow{\mathit{Si}} \mathit{op}^2$ must hold (let us call this Condition 2). The
  above precedence relationships among operations $\mathit{op}^1$ and $\mathit{op}^2$ in Condition 1 can be directly
  expressed in terms of LTL as follows. Let $\mathit{Op}^1$ and $\mathit{Op}^2$  be propositional logic
  variables that indicate whether operations $\mathit{op}^1$ and $\mathit{op}^2$ on an object $o$ have
  returned (indicated by the value of the variables being TRUE) or not (indicated by the value of the
  variables being FALSE), respectively. Condition 1, which expresses the precondition for RYW with respect to
   a given execution order $\sigma$, can be expressed in terms of the LTL expression
    $\mathit{Op}^1 F \mathit{Op}^2 \in \mathit{st}$, where a session trace $\mathit{st}$ is equivalent to $\sigma$ for the
    means and purposes of this paper. The above LTL expression implies: if the propositional variable
    $\mathit{Op}^1$ is true at one instant, $\mathit{Op}^2$ is eventually true in some later instant for the
    same session trace $\mathit{st}$.  In other
     words, the operation $\mathit{op}^2$ on object $o$ follows the operation $\mathit{op}^1$ in the
     given session trace $\mathit{st}$.
 % Thus, the expressions $\left(\mathit{op}^1 \rightarrow \mathit{op}^2\right)^\sigma$ can be rewritten as LTL formula
%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
   The expression $\mathit{op}^1 \xrightarrow{Si} \mathit{op}^2$ in Condition 2
  can be expressed in terms of LTL as $\mathit{Op}^1 F \mathit{Op}^2 \in \mathit{Si}_p$,  where
  $\mathit{Si}_p$ is equivalent to $S_i$, i.e., both notations represent a legal serialization comprising all
   operations performed from a given client application along with writes from all other clients.  Further,
   since RYW talks about a sequence of write operations followed by a read, the propositional variables
   $\mathit{Op}^1$ and $\mathit{Op}^2$ in both Condition 1 and Condition 2 can safely be  replaced  by a new propositional variable
   $W^i$ and $R^j$.
   Further, the anomaly condition $C$ for RYW can be derived as follows. Let us consider that there exists
   a write operation $w^l$ precedes $w^i$, i.e., ${W^l}^{'} F {W^i}^{'} \in \mathit{St}$, and a read operation
    $r^k$ precedes $r^j$, i.e., ${R^k}^{'} F {R^j}^{'} \in \mathit{st}$. According to the
    definition of RYW in \cite{Terry:1994:SGW:645792.668302, Burckhardt:2014:PEC:2693641.2693642},
   either of the following conditions must be satisfied: 1) $r^j$ must not observe a value that was written by $w^l$ if the result of the later write
   $w^j$ was already read by read $r^k$, i.e., $\left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right)$, or
   2) the read $r^j$ is directly followed by the write $w^l$, i.e.,  the condition
   $\left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right)$
   must hold.
  % Let $w^k(o,v_k)$ be signature of the write operation $\mathit{op}^k$, which overwrites the value written by
%   $\mathit{op}^1$; let $W^k$ be a propositional variable that indicates whether the operation
%   $\mathit{op}^k$ returns the result.
%  Replacing variables $\mathit{Op}^1$, $\mathit{Op}^2$, and $\mathit{Op}^k$  with variables $W^j(v_l)$, $R^k{v_m}$, and
%  $W^p(v_q)$, respectively, the above condition can be expressed as
%  $\not\exists W^k \in \mathit{st} \left( W^k F W^i F R^j \in \mathit{st} \right)$.
  From the above reasoning, we can directly derive the ConSpec expression $C$ = $\not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge \\
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^i}^{'} \in \mathit{St} \right) %\big) \\
\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big) \big)$
 (refer to Equation \ref{eqn:RYW}.
 %\begin{align}
%  \begin{split}
%\forall i, j, o, \mathit{st} \big( \left( W^i F R^j \in \mathit{st} \right) \;
% \rightarrow \; \exists \mathit{Si}_p \left(  W^i F R^j \in \mathit{Si}_p \right)
%\\ \wedge  \not\exists W^k \in \mathit{st} \left( W^k F W^i F R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( v^j = v^k \right) \big).
%  \end{split}
%  \end{align}
% In the above expression, the condition \\ $\left( W^j(v_l) F W^p(v_q) F R^k{v_m} \right) \oplus \left( W^j(v_l)X^{o}R^k{v_m} \right)$ in a session trace $\mathit{st}$ implies that either 1) the read operation $R^k{v_m}$ returns the value written by the write operation $w^j(o,v_l)$, or 2) a value that is written by a write operation $w^p(o,v_q)$, that follows $w^j(o,v_l)$ and overwrites $o$. The condition 1 in the above statement, in turn, implies that $v_m = v_l$. Plugging in the above expression in Equation \ref{eqn:RYWder}, the above expression can be reduced to the ConSpec expression for RYW, given as
%  \begin{align}\label{eqn:RYWFin}
%\begin{split}\forall i, j, k, l, m \left(\star W^j(v_l)X^{o}R^k{v_m} \star \right)_{o}^\mathit{po} \\ \rightarrow \left(G\;  \left( W^j(v_l) F W^p(v_q) F R^k{v_m} \right) \oplus \left( v_m = v_l \right) \right)_{o}^\mathit{st}
%\end{split}
%\end{align}.
 \par Session Monotonic or Monotonic Read (also referred to as Session Causality or MR) consistency model is
 another popular consistency model \cite{Chockler2000, Terry:1994:SGW:645792.668302}. According to Chockler et al.,
 MR is expressed as: if the condition $\mathit{op}^1 \xrightarrow{\sigma} \mathit{op}^2$ holds for a given execution sequence $\sigma$
  (Condition 1), where both $\mathit{op}^1$ and $\mathit{op}^2$ must be read operations,
  there must exist a serialization ${S_i}$,comprising the
   operations $\mathit{op}^1$ and $\mathit{op}^2$, for which the condition
  $\mathit{op}^1 \xrightarrow{\mathit{Si}} \mathit{op}^2$ must hold (Condition 2).
 As in the case of RYW, the expressions $\mathit{op}^1 \xrightarrow{\sigma} \mathit{op}^2$,
  and $\mathit{op}^1 \xrightarrow{\mathit{Si}} \mathit{op}^2$  can be rewritten as LTL expressions
   $R^i F R^j \in \mathit{st}$ and $R^i F R^j \in \mathit{Si}_p$, respectively.
    Let us consider a sequence of consecutive read operations $R^i$ and $R^j$  in a given
    session trace $\mathit{st}$, i.e., the condition ${R^i}^{'} F {R^j}^{'} \in \mathit{st}$ holds. Further,
     consider that there exists two consecutive write operations $w^m$ and $w^n$ in the global session
    history, i.e., the condition ${W^m}^{''} F {W^n}^{''}  \in \mathit{St}$ holds. According to the definition of MR,
     if the first read operation $r^i$ returns the
    result of the later write $w^n$, then either of the following conditions must hold: 1) the read $r^j$ that follows $r^i$ can not return the result
    written by an earlier read by the earlier write $w^m$, i.e., the condition $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right)$ holds, or 2) the read operation $r^j$ is directly followed by write
    operation $w^m$, i.e., the condition $\left( {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathit{St} \right)$ holds.
    %The above condition can be expressed in terms of LTL
%    by the expression $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right)$.
    The above conditions can be combined together to the anomaly expression for MR, i.e.,
     $C = \not\exists \big( \left( {R^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge %\left( {\mathit{st}}^{'} \in \mathit{St} \right) \wedge
 \left( {W^m}^{''} F {W^n}^{''}  \in \mathit{St} \right) \\ \big( %\left( {W^m}^{''} F {W^n}^{''} F {R^i}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \\
 \left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \\ \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big) \big)$.
  Thus, the ConSpec specification for MR is directly derived from the definition by Chockler et al.
   %\begin{align}%\label{eqn:PL299}
%\begin{split}
%\big(\star \left( W^j(v_l)X^{o}R^k{v_m} \right) \\ \wedge \left( W^n(v_q) X^{o}R^s{v_t} \wedge ( R^k{v_m}F^{o}R^s{v_t} \right) \star \big)^\mathit{po}_{o}
%\\ \rightarrow \big(G\; \star \left( W^n(v_q) X^{o}R^s{v_t} \right)\oplus \\ \left(W^n(v_q) F^{o} W^u(v_x) X^{o} R^s{v_t} \right) \star \big)_{o}^\mathit{st}
%\end{split}
%\end{align}.  $W^n(v_q) X^{o}R^s{v_t}$ implies that the read operation $r^s(o){v_t}$ must return the value $v_x$ written by the write operation $w^n(, ov_q)$. This, in turn, implies $v_t = v_x$.
  %Thus, the above expression can be again rewritten as \begin{align}%\label{eqn:PL299}
%\begin{split}
%\big(\star \left( w^j(v_l)X^{o}r^k{v_m} \right) \wedge \left( w^n(v_q)X^{o}r^s{v_t} \right) \star \big)^\mathit{po}_{o} \\
%\rightarrow \big(G\; \star \left( v_q \gets \left( R^k{v_m}F^{o}R^s{v_t} \right) \right)\oplus \\ \left( v_x \gets \left( W^n(v_q) F^{o} W^u(v_x) X^{o} R^s v_t \right) \right) \star \big)_{o}^\mathit{st}
%\end{split}
%\end{align}.
% Additionally, we also consider a read operation $r^s(o){v_t}$ that reads values written by $w^n(o,v_q)$, i.e., \\ $w^n(o,v_q) X^{o} r^s(o){v_t}$. Then, without violating the above conditions, the above expression can be reduced to the ConSpec expression for MR, given as
% Hence, the above equation can be directly reduced to the equivalent ConSpec expression for MR, which is
% \begin{align}%\label{eqn:PL299}
%\begin{split}
%\forall i, j, k, l, m, n, q, r, s, t \big(\star ( W^j(v_l)X^{o}R^k{v_m} ) \\ \wedge ( W^n(v_q)X^{o}R^s{v_t} ) \wedge ( R^k{v_m}F^{o}R^s{v_t} ) \star \big)^\mathit{po}_{o} \\
%\rightarrow \big(G\; \star %\left( v_t = v_q \right) \wedge
%  (v_t = v_q ) \oplus ( W^n(v_q) F^{o} W^u(v_x) X^{o} R^s{v_t} ) \star \big)_{o}^\mathit{st}.
%\end{split}
%\end{align}.
%$\forall i, j, o, \mathit{st} \; \big( \mathit{Op}^i X \mathit{Op}^j \in \mathit{st}
%\rightarrow \exists \mathit{Si} \left( \mathit{Op}^i X \mathit{Op}^j \in \mathit{Si} \right) \\ \wedge
%\forall \mathit{st}  \left( \mathit{Op}^j X^o R_k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right) \big)$
 \par Causal consistency is specified by Chockler et al. as follows. Chockler et al. defines a
\emph{direct precedence relation} (which we denote as $\xRightarrow{\sigma}$) between operations $\mathit{op}^i$
 and$\mathit{op}^k$ in the execution order $\sigma$ as follows. $\mathit{op}^i \xRightarrow{\sigma} \mathit{op}^j$
  implies that either $\mathit{op}^j$ reads values written by operation $\mathit{op}^i$, or  a precedence relationship
exists in the execution order $\sigma$ between $\mathit{op}^i$  and $\mathit{op}^j$, i.e.,
$\mathit{op}^i \xrightarrow{\sigma}\mathit{op}^j$ exists. The former part of the precondition can be expressed in the
 form ${\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'}$, where the LTL-like operator $F$ is equivalent to the precedence operator.
 The latter part of the precondition implies read operation $\mathit{Op}^i$ reads the value
 written by $\mathit{Op}^j$, i.e., $ \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \wedge \left( {\mathit{Op}^j}^{'} = {R^j}^{'} \right) \wedge
   \left( v_i = v_j \right)$. The precondition of causal consistency specifies that a transitive closure
must exist for a direct precedence relation $\xRightarrow{\sigma}$, i.e., $\xRightarrow{\star}$ must exist, i.,e.,
the condition $ {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \vee
 \left( \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \wedge \left( {\mathit{Op}^j}^{'} = {R^j}^{'} \right) \wedge
   \left( v_i = v_j \right) \right)$ must hold. \\ % The precondition specifies that operations $\mathit{op}^j$  and $\mathit{op}^k$ are comprised in the execution
%order $\sigma$.  The second precondition which claims
% closure under transitivity of direct precedence relations, we can specify that if $\mathit{op}^i$ directly precedes
% $\mathit{op}^k$, and $\mathit{op}^k$ directly precedes $\mathit{op}^j$, $\mathit{op}^i$ directly precedes
% $\mathit{op}^j$.
%Assuming the transitive closure property specified by the second precondition, the direct precedence
% relation among operations $\mathit{op}^i$ and $\mathit{Op}^j$ can be expressed in terms of LTL as : $\big(\big(  \mathit{Op}^i F \mathit{Op}^j \vee \\
% \exists \mathit{Op}^k \in  \mathit{st} \left( \mathit{Op}^i F \mathit{Op}^k  \wedge
%\mathit{Op}^k F \mathit{Op}^j \right) \big) \\ \vee \big( \left( \mathit{Op}^i = W^i \right) \wedge
%\left( \mathit{Op}^j = R^j \right) \wedge \\ \left( \left( v_i = v_j \right) \vee \exists \mathit{Op}^k \in  \mathit{st}
%\left( \left( v_i = v_k \right)
% \wedge \left( v_k = v_j \right) \right) \big) \right) \big)$.
% The above expression matches the LHS of Equation \ref{eqn:Causal}.
 Chockler et al. specifies that for causal consistency, if the above
precondition holds, the condition $\mathit{op}^i \xrightarrow{\mathit{Si}}\mathit{op}^j$ must hold,
i.e., an occurrence of $\mathit{op}^i$ must be followed by an occurrence of $\mathit{op}^j$ in any
 legal serialization ${S_i}$.
 The above postcondition can be expressed in terms of LTL as \\ $\exists \mathit{Si}_p \left( \forall \mathit{Op}^i F \mathit{Op}^j \in
\mathit{Si}_p \right)$.  The operation $\mathit{op}^i$ precedes $\mathit{op}^j$ such
  that the condition ${\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st}$ is satisfied.
 Additionally, the definition of  Causal consistency requires that the operation $\mathit{op}^j$ must not
 read the result of an earlier write operations $w^m$  instead of $\mathit{op}^i$ such that either of the following
  conditions are satisfied. The first condition specifies that $r^j$ returns the result of $w^m$, i.e., the condition
   ${v^j}^{'} = {v^m}^{''}$ holds. The second condition specifies that $r^j$ follows the write $w^m$, such that
   the condition $\left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right)$ holds. %The above condition can be expressed as
%  $\not\exists  \mathit{st} \left( W^m F \mathit{Op}^i F \mathit{Op}^j \in \mathit{st} \right)
%\wedge \left( v^j = v^m \right)$.
  We can combine the above expressions to form Equation \ref{eqn:Causal}, thus reducing it to the form of the anomaly condition, i.e.,
  $C = \not\exists \big( %\left( \mathit{st}^{'} \in \mathit{St} \right) \wedge
   \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
   \left( {W^m}^{''} \in \mathit{St} \right) \\
   \wedge \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \big)
\big( \left( {W^m}^{''} F {\mathit{Op}^i}^{'}  \in \mathit{St} \right) \wedge
\big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \\
 \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big) \big) \big)$
 \par Chockler et al. states strict serializability as: the order of execution among operations comprised in any execution
 sequence of a given client application must match the precedence order in a legal serialization for the given
 execution sequence. The order  of execution among operations in an execution sequence $\sigma$
 can be given  in terms of a series of LTL expression that express the precedence of successive operations in the sequence.
  The precedence relation between any two successive operations $\mathit{op}^i$ and $\mathit{op}^j$ can be expressed as
   $\mathit{op}^i X \mathit{op}^j$.  Thus, the above condition can be expressed as: any two operations in an execution
   sequence must execute in an order that matches the precedence relation among these operations in a legal
   serialization of the above execution sequence. In other words, any two operations must occur in a session trace in an
   order that matches the precedence relation of these operations in a legal serialization of those operations.  Hence, this condition can be expressed in terms of LTL as
   $\mathit{Op}^i X \mathit{Op}^j \in \mathit{st}
\rightarrow \exists \mathit{Si}_i \left( \mathit{Op}^i X \mathit{Op}^j \in \mathit{Si}_i \right)$.
 Additionally, consider that a read operations $r^j$ follows a write operation $w^i$ in a given session
 trace. Conisider a read oepration $r_k$ follows $r^j$ in the global session history. Strict serializability
 requires that the later read $r^k$ can not read the result of the write $w^i$ if the earlier read $r^j$ did not observe it,
 i.e., the condition $\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
 \left( {R^j}^{''} F {R^k}^{''} \in \mathit{St} \right) \big)
 \big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big)$ must hold.
 Further, consider that a read operation $r^l$ follows the above sequence of write and reads in the global session history,
 i.e., $ \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge
  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathit{St} \right)$. In that case,
  among the reads following $w^j$ the later read $r^l$ can not observe the result of $w^j$ if the earlier read $r^k$ did not
   observed it, i.e., \\ $\not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \\
  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathit{St} \right) \big)
 \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$.
  %must always observe the result
% of the latest operation preceding $r_k$. This condition can be expressed in terms of LTL as
% $\forall \mathit{st}  \left( \mathit{Op}^j X^o R^k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right)$
  Combining the above
  conditions, we can derive the anomaly expression for strict serializability, i.e., $C = \not\exists \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \\
   \wedge \left( {R^j}^{''} F {R^k}^{''} \in \mathit{St} \right) \big)
 \big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge \\
 \not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \\
  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathit{St} \right) \big)
 \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$ %\wedge
% \not\exists \big( \left( {\mathit{Op}}^{'} F {W^j}^{'} F {R^k}^{'} \in \mathit{st} \right) \wedge \\
% \left( {W^i}^{'} F {W^j}^{'} F {R^k}^{''} F {R^l}^{l'} \in \mathit{St} \right) \big)
% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{'} \not= {v^i}^{'} \right) \big)$
 (refer to Equation \ref{eqn:Strict}).
   \par Chockler et al. states the WFR consistency model as: if the condition represented by the expression
  $\mathit{op}^1 \xrightarrow{\sigma} \mathit{op}^2$ holds for a given execution sequence $\sigma$ of read operation
  followed by write operation
  (let us call this Condition 1), there must exist a serialization ${S_i}$,comprising the
   operations $\mathit{op}^1$ and $\mathit{op}^2$, for which the condition given by the expression
  $\mathit{op}^1 \xrightarrow{\mathit{Si}} \mathit{op}^2$ must hold (let us call this Condition 2).
  The above precedence relationships among operations $\mathit{op}^1$ and $\mathit{op}^2$ in Condition 1 can be directly
  expressed in terms of an LTL expression
    $R^i F W^j \in \mathit{st}$, where a session trace $\mathit{st}$ is equivalent to $\sigma$ for the
    means and purposes of this paper.
 % Thus, the expressions $\left(\mathit{op}^1 \rightarrow \mathit{op}^2\right)^\sigma$ can be rewritten as LTL formula
%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
   The expression $\mathit{op}^1 \xrightarrow{\mathit{Si}} \mathit{op}^2$ in Condition 2
  can be expressed in terms of LTL as $R^i F W^j \in \mathit{Si}_p$,  where
  $\mathit{Si}_p$ is equivalent to $S_i$.
  % Further,
%   since WFR talks about a sequence comprising a read and a write operation, the propositional variable
%   $\mathit{Op}^1$ and   $\mathit{Op}^2$ in both Condition 1 and Condition 2 can safely be  replaced  by new
%   propositional variables  $R^i$ and $W^j$.
   Further, let us consider consecutive read operations $r^k$ and $r^j$ in a  given session trace, and a write operation $w^i$
   preceded by a write operation $w^l$.  According to WFR, under the above condition, if the earlier read $r^k$ returns the result of the later write
   $w^i$, then  one of the following conditions must
   hold: 1) a later read $r^j$ can not return the result of an earlier write $w^l$, i.e., $ {v^j}^{'} = {v^l}^{'}$, or
   2) the read $r^j$ must directly succeed the write $w^l$ in the global session history, i.e., $\left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right)$.
   Further, let us consider a session trce comprising a sequence of reads $r^i$ and $r^k$ that follows a write operation $w^j$, and a write
   operation $w^m$ precedes read $r^k$ in the global session history. If $r^i$ reads from $w^j$, $r^k$ reads from $w^m$, and
    a read operation $r^l$ reads from $w^j$, then one of the following conditions must hold: 1) $r^l$ reads from $w^m$, i.e.,
     ${v^l}^{''} = {v^j}^{''}$,  or 2) $w^m$ is directly succeeded by $r^l$, i.e., $ \left( {W^m}^{''} F { R^l}^{''} \in \mathit{St} \right) \wedge
   \left(  \not\exists {W^m}^{''} F {W^n}^{''} F { R^l}^{''} \in \mathit{St}  \right)$. %can be also expressed as: a read operation $r^n$ must not observe
%    a value that is written by  an earlier read $r^i$ instead of a later write operation $w^j$ in the
%    execution sequence. %The above condition can be expressed in terms of the LTL expression
    %$\not\exists  \mathit{st} \left( R^i F W^j F R^n \in \mathit{st} \right) \wedge \left( W^j F R^n \in \mathit{st} \right) \wedge \left( v^n = v^i \right)$.
     Combining the above
  conditions, we can derive the ConSpec expression for WFR $ C = \not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge \\
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^i}^{'} \in \mathit{St} \right) %\big) \\
\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big) \big) \wedge \\
 \not\exists \big(  \left(  {W^j}^{''}  F  {R^i}^{''} F {R^k}^{''} \in \mathit{St} \right) \wedge \left(  {W^m}^{''}  F  {R^k}^{''} \in \mathit{St} \right) \wedge \\
 \left( {v^j}^{''} = {v^i}^{''} \right) \wedge \left( {v^m}^{''} = {v^k}^{''} \right)  \wedge \left( {v^l}^{''} = {v^j}^{''} \right)  \big) \big( \left( {v^m}^{''} = {v^l}^{''} \right) \\
  \vee \big( \left( {W^m}^{''} F { R^l}^{''} \in \mathit{St} \right) \wedge
   \left(  \not\exists {W^m}^{''} F {W^n}^{''} F { R^l}^{''} \in \mathit{St}  \right)  \big)  \big)$
   (refer to Equation \ref{eqn:WFR}).
  \par Chockler et al. states the MW consistency model as: if the condition represented by the expression
  $\mathit{op}^1 \xrightarrow{\sigma} \mathit{op}^2$ holds for a given execution sequence $\sigma$ of write operations
  (let us call this Condition 1), there must exist a serialization ${S_i}$,comprising the
   operations $\mathit{op}^1$ and $\mathit{op}^2$, for which the condition given by the expression
  $\mathit{op}^1 \xrightarrow{\mathit{Si}} \mathit{op}^2$ must hold (let us call this Condition 2).
  The above precedence relationships among operations $\mathit{op}^1$ and $\mathit{op}^2$ in Condition 1 can be directly
  expressed in terms of an LTL expression
    $\mathit{Op}^1 F \mathit{Op}^2 \in \mathit{st}$, where a session trace $\mathit{st}$ is equivalent to $\sigma$ for the
    means and purposes of this paper.
 % Thus, the expressions $\left(\mathit{op}^1 \rightarrow \mathit{op}^2\right)^\sigma$ can be rewritten as LTL formula
%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
   The expression $\mathit{op}^1 \xrightarrow{Si} \mathit{op}^2$ in Condition 2
  can be expressed in terms of LTL as $\mathit{Op}^1 F \mathit{Op}^2 \in \mathit{Si}_p$,  where
  $\mathit{Si}_p$ is equivalent to $S_i$.  %Further,
%   since MW talks about a sequence of write operations, the propositional variable
%   $\mathit{Op}^1$ and   $\mathit{Op}^2$ in both Condition 1 and Condition 2 can safely be  replaced  by new
%   propositional variables  $W^i$ and $W^j$.
%Further, the definition of MW can be also expressed as: a read operation $r^n$ must not observe
%    a value that is written by  an earlier write $w^i$ instead of a later write operation $w^j$ in the
%    execution sequence. The above condition can be expressed in terms of the LTL expression
%    $\not\exists  \mathit{st} \left( W^i F W^j F R^n \in \mathit{st} \right) \wedge \left( v^n = v^i\right)$.
 Let us consider that there exists two consecutive write operations $w^i$ and $w^j$ in a given session
    trace, i.e., the condition ${W^i}^{''} F {W^j}^{''}  \in \mathit{st}$ holds. A read operation $r^m$
    cannot read the result of the earlier write operation $w^i$.
 Further, let us consider a sequence of consecutive read operations $r^k$ and $r^l$  in a given
   global session history $\mathit{St}$, i.e., the condition ${R^k}^{'} F {R^l}^{'} \in \mathit{St}$ holds. According to
   the definition of MR, if the first read operation $r^k$ returns the
    result of the later write $w^j$, then the later read $r^l$ that follows $r^k$ can not return the result
    written by the earlier write $w^i$, i.e., the condition $\left( {v_k}^{''} = {v_j}^{'} \right) \wedge \left( {v_l}^{''} = {v_i}^{'} \right) $
    must hold. Further, let us consider the read operation $r^k$  reads the result of a preceding write $w^m$, and the read $r^n$ reads the
    result of a write $w^i$, the write $w^i(x)$ precedes $w^j(y)$ in the given session trace. Then, one of the following
    conditions must hold: 1) $r^n$ read the result of the write $w^m$, i.e., ${v_m}^{''} = {v_n}^{''}$ or 2) $r^n$ directly follows $w^m$ in the given
    session trace, i.e., $\left( {W^m}^{'} F {R^n}^{'} \in \mathit{St} \right) \wedge \\
      \not\exists \left( {W^m}^{'} F {W^p}^{'} F {R^n}^{'} \in \mathit{St} \right)$. Combining the above
  conditions, we can derive the anomaly expression for MW $C = \not\exists {W^j}^{'} F  {R^m}^{'} \in \mathit{st} \left( {v_m}^{'} = {v_i}^{'} \right)  \wedge \left( \not\exists  {R^k}^{''} F  {R^l}^{''} \in \mathit{St} \right) \\
   \left( \left( {v_k}^{''} = {v_j}^{'} \right) \wedge \left( {v_l}^{''} = {v_i}^{'} \right) \right) \wedge \not\exists \big( \left( {W^m}(x)^{'} F {R^k}(x)^{'} \in \mathit{St}  \right) \wedge \\
     \left( {v_m}^{''} = {v_k}^{'} \right) \wedge \left(  {W^i}(x)^{'} F {R^n}(x)^{'} \in \mathit{St} \right) \wedge \left( {v_i}^{'} = {v_n}^{'} \right) \wedge \\
     \left( {W^i}(x)^{'} F  {W^j}(y)^{'} \in \mathit{st} \right) \wedge \left( {R^l}(y)^{'} F  {R^k}(x)^{'} \in \mathit{St} \right) \big) \\
 \big(  \left( {v_m}^{''} = {v_n}^{''} \right) \vee
 \big( \left( {W^m}^{'} F {R^n}^{'} \in \mathit{St} \right) \wedge \\
      \not\exists \left( {W^m}^{'} F {W^p}^{'} F {R^n}^{'} \in \mathit{St} \right)  \big)$
      (refer to Equation \ref{eqn:MW}).
 %The postcondition of Chockler et al. implies that in any serialization order, a read operation $\mathit{op}^j$
% must return the values written by the latest write operations that directly precedes it, namely $\mathit{op}^i$.
% This, in turn, implies $v_l = v_m$ and
% $v_l = v_m$, respectively.
% However, subsequent write operations $\mathit{op}^p$ may alternatively overwrite the
%  values  observed/written by operation $\mathit{op}^k$ . The above conditions may be specified by the
% expressions $\mathit{Op}^j F^{o} \mathit{Op}^p X^{o} \mathit{Op}^k$. Thus, the expression for causal
% consistency can be rewritten as
%  \begin{align}
%  \begin{split}
%\forall i, j, k, l, m, n, p, q \big( \big( \left( \mathit{Op}^j = \left( W^j(v_l) \oplus R^j{v_l} \right) \right) \\
%\wedge \left(   \mathit{Op}^k = \left( W^k(v_m) \oplus R^k{v_m} \right) \right) \wedge \left( \mathit{Op}^p = W^p(v_q)  \right) \big)
% \\ \wedge \big( \left( \left( \mathit{Op}^j F^{o} \mathit{Op}^k \right) \oplus \left( \mathit{Op}^j X^{o} \mathit{Op}^k \right) \right)  \\
% \vee \big( \left( \left( \mathit{Op}^j F^{o} \mathit{Op}^n \right) \oplus \left( \mathit{Op}^j X^{o} \mathit{Op}^n \right) \right)  \\
%\wedge \left( \left( \mathit{Op}^n F^{o} \mathit{Op}^k \right) \oplus \left( \mathit{Op}^n X^{o} \mathit{Op}^j \right) \right) \big) \big) \big)_{o}^\mathit{po} \\
%\rightarrow \big(G\;  \left( v_l = v_m \right) \oplus \left( \mathit{Op}^j F^{o} \mathit{Op}^p X^{o} \mathit{Op}^k \right) \big)_{o}^\mathit{st}.
%\end{split}
% \end{align}
%$\forall i, j, k, l, o, \mathit{st}_x, \mathit{st}_y \big( W^i F W^j \in \mathit{st}_x, \mathit{st}_y
%\\ \rightarrow  \exists \mathit{Si} \left( W^i F W^j \in \mathit{Si} \right) \wedge
%\\ \wedge \not\exists R^m  \left( W^i F W^j F R^m \in \mathit{st}_x, \mathit{st}_y \right) \\
%\wedge \big( \left( \left( v^m = v^i \in \mathit{st}_x  \right) \wedge \left( v^m = v^j \in \mathit{st}_y
%\right) \right) \\
% \vee \left( \left( v^m = v^j \in \mathit{st}_x  \right) \wedge \left( v^m = v^i \in \mathit{st}_y \right)
% \right) \big) \big)
%$
\par Total Store Order (TSO or Total Order) is specified by Owen et al. \cite{Owens:2009:BXM:1616077.1616107}
 as follows. In any two executions of a sequence of operations by two processors (or client applications),
 a pair of operations on a common datastore object $o$ must be executed in the same precedence order.  %serializations ${S_i}_i$ and ${S_i}_j$, the write operations on common datastore objects in ${S_i}_i$ and
% ${S_i}_j$ must be executed in the same order, i.e., ${S_i}_i|w$ = ${S_i}_j|w$.
 The above condition implies that any two session traces $\mathit{st}$ and $\mathit{st}^{'}$ must comprise write-read sequences
  on an object $o$ in the same order. %, i.e., there must exist a common serialization comprising all operations executed from the
% client applications which contains the above writes executed in a particular order. This condition can be expressed in terms of LTL as
% $W^i F W^j \in \mathit{st}_x, \mathit{st}_y \rightarrow  \exists \mathit{Si} \left( W^i F W^j \in \mathit{Si} \right)$.
 Let us consider a given sequence of operations $w^i$ and $r^j$ in any given session trace, whee $r^j$ does not return
  the result of $w^i$. Further, consider a read operation $r^k$ that executes between  $w^i$ and $r^j$ in the
  global session history. If the read $r^k$ also does not return the result of $w^i$, there can not exceed a write operation
  $w^l$ that precedes the write $w^i$, such that one of the following conditions hold: 1) $r^i$ returns the result of $w^l$,
  i.e., ${v^j}^{'} = {v^l}^{'}$, or 2) $r^i$ directly follows $w^l$, i.e., $\left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge
 \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right)$.
% that must not observe the sequence
% of writes executing in  a different order in  two different session traces $\mathit{st}_x$ and $\mathit{st}_y$.% The above
%  condition can be expressed as
% $\not\exists R^m  \left( W^i F W^j F R^m \in \mathit{st}_x, \mathit{st}_y \right) \\
%\wedge \big( \left( \left( v^m = v^i \in \mathit{st}_x  \right) \wedge \left( v^m = v^j \in \mathit{st}_y
%\right) \right) \\
% \vee \left( \left( v^m = v^j \in \mathit{st}_x  \right) \wedge \left( v^m = v^i \in \mathit{st}_y \right)
% \right) \big) $.
 The above conditions can be combined to form the anomaly condition of TSO $C = \forall \mathit{st}, \mathit{St} \; \big( \not\exists \big( \left({W^i}(x)^{'} \in \mathit{st} \right) \wedge
 \left({R^j}(x)^{''} \in \mathit{st}^{'} \right) \wedge \\
  \left( {W^i}^{'}(x) F {R^j}^{''}(x) \in \mathit{St}  \right) \wedge \left( {v_j}^{''} \not= {v_i}^{'} \right) \big) \\
  \big( \not\exists \big( \left({R^k}(x)^{'} \in \mathit{st}^{'} \right) \wedge \left( {R^k}^{''}(x) F {R^j}^{''}(x) \in \mathit{St}  \right)   \big)  \\
  \left( {v_k}^{''} \not= {v_i}^{'} \right) \big) \wedge
 \not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%\left(  \mathit{st}^{'} \in \mathit{St} \right) \wedge
\left( {W^l}^{'} F {W^i}^{'} \in \mathit{St} \right) \\ %\big) \\
\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee
\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathit{St} \right) \wedge \\
 \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathit{St} \right) \big) \big) \big)$ (refer to Equation \ref{eqn:TSO}).
  %Thus, the ConSpec expression for TSO is derived as follows.
%   Any
%  two write operations with read operations following them must occur in the same order for all executions,
%  irrespective of the store where they are executed. Consider that there exists two write operations
%  $w^j(o,v_l)$ and $w^n(o,v_q)$, with two corresponding read operations $r^k(o){v_m}$ and $r^s(o){v_t}$, such
%  that  conditions $w^j(o,v_l)X^{o}r^k(o){v_m}$ and $w^n(o,v_q)X^{o}r^s(o){v_t}$ hold.
% Following the same line of reasoning as that used in the case of Causal consistency, the following condition
%  must hold:
%  \\ $\forall i, j, o, \mathit{st}, \mathit{Si} \; \big( \mathit{Op}^i X W^j \in \mathit{st}
%\rightarrow \\ \forall \mathit{Si} \left( \mathit{Op}^i X W^j \in \mathit{Si} \right)
%\wedge \not\exists R^k  \left( \mathit{Op}^i X^o W^j X^o R^k \in \mathit{st} \right) \\ \wedge \left( v^k = v^i  \right) \big)
%$.
 Similarly, the specification for Processor consistency model can be directly derived using the above line of reasoning;
 it talks about preserving the order of operations executed by individual processors (or client applications).  %Also, the ConSpec expression for strict
% serializability follows directly from its definition.
%It states that  any serialization of a sequence of operations
%  executed by a processor must observe an identical order of execution among operations. This, in turn, is expressed using Equation
 %\ref{eqn:Strict}.
  %The specification for Write Follows Read consistency (see Equation \ref{eqn:WFR}) is also derived using similar line of reasoning.
\par The ConSpec specifications for the isolation levels are derived from the definitions by Adya et al.
\cite{DBLP:conf/icde/AdyaLO00}.  Here, we show that the isolation specifications in ConSpec, given in
Equations \ref{eqn:PL1}, \ref{eqn:PL2}, \ref{eqn:PL3}, and \ref{eqn:PL299}, follow directly from the
definitions of isolation levels PL-1, PL-2, PL-3, and PL-2.99 \cite{DBLP:conf/icde/AdyaLO00}. We analyze the
ConSpec Equations, and demonstrate their equivalence to the definitions of  \cite{DBLP:conf/icde/AdyaLO00}, as
follows.
\par  The PL-1 specification states that the anomaly G0 must be proscribed in any session trace collected
for the execution of a client application. G0 specifies that there can not be any directed cycle in the
dependency graph corresponding to an execution of a pair of transactions, comprising entirely of write dependency edges.
%The
% condition can be avoided if the write dependencies are preserved in any execution of a given client
% application, i.e., if any pair of write operations are executed in order. The LHS of
%  Equation \ref{eqn:PL1}, i.e., the expression $W^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st}$
%  denotes the above precondition with respect to a given session trace $\mathit{st}$ comprising any two
%  write operations $w^i_{tx}$ and $w^j_{tx}$. PL-1 specifies that any session trace must
%  comprise the above write operations in the same order. This, in turn, implies that the write operation
%  $w^j_{tx}$ in the session trace $\mathit{st}$ must overwrite the value written by the write operation $w^i_{tx}$, i.e.,
%  $r^k_{tx}$ that follows the write operation $w^j_{tx}$ must not return the value $v_i$ written by an earlier
%   write. The above condition can be expressed as $\not\exists R^k_\mathit{tx} \in \mathit{st} \left( W^i_\mathit{tx} F W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^k = v^i \right)$.
%  Thus, the above condition can be reduced to the RHS of Equation \ref{eqn:PL1} using ConSpec operators.
 Let us consider a pair of transactions $\mathit{tx}$ and $\mathit{ty}$. Let us consider that write operations
 $w^i(x)_\mathit{tx}$ and $w^j(y)_\mathit{tx}$ write to objects $x$ and $y$ from transaction $\mathit{tx}$, and
 $w^k(x)_\mathit{ty}$ and $w^l(y)_\mathit{ty}$ write to objects $x$ and $y$ from transaction $\mathit{ty}$.
 According to PL-1 there can not exist a pair of read operations $r^m(x)_\mathit{tx}$ and $r^n(y)_\mathit{ty}$
 invoked from transactions  $\mathit{tx}$ and $\mathit{ty}$  such that the following conditions are simulataneously
 satisfied: 1) $r^m(x)_\mathit{tx}$ reads the result of the
 write operation $w^i(x)_\mathit{tx}$ causing a $ww$ dependency from  $\mathit{tx}$ to $\mathit{ty}$, i.e.,
 $v_m^{'} = v_i^{'}$ must not hold, and 2)
  $r^n(y)_\mathit{ty}$ reads the result of the
 write operation $w^l(y)_\mathit{ty}$ causing a $ww$ dependency between  $\mathit{ty}$ to $\mathit{tx}$, i.e.,
 $v_n^{'} = v_l^{'} $ must not hold. Simulataneous
 satisfaction of conditions 1 and 2 results in a cycle comprising $ww$ dependencies between $\mathit{tx}$ and $\mathit{ty}$.
 Thus, we can express the specification of PL-1 as
$C = \forall \mathit{St}, \mathit{st}, \mathit{tx}, \mathit{ty}, x, y,
  {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty} \in  \mathit{St} \\
 %\mathit{tx} F \mathit{ty} \rightarrow
  \left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right)
  % \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \\
\left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big)$
 which is identical to Equation \ref{eqn:PL1}. %It can be trivially observed that the above expression for PL-1 proscribes the anomaly G0, and thus satisfies PL-1 specifications.
\par The isolation level PL-2 proscribes the anomalies G1-a, G1-b, and G1-c \cite{DBLP:conf/icde/AdyaLO00}. We show that
the ConSpec specification for PL-2, given in Equation \ref{eqn:PL2}, disallows the above anomalies as follows.
\textbf{G1-a}: According to G1-a, a transaction can not observe a value wriitten by an aborted transaction.
 In other words, if either transaction  $\mathit{tx}$ or transaction $\mathit{ty}$ aborts, i.e., either of the conditions $a_\mathit{tx} \in \mathit{st}$ or $a_\mathit{ty} \in \mathit{st}$ hold,
 then there can not exist a read operation that reads the value written by an aborted transaction, i.e., the conditions
 ${W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st}$ or $ {W^k}(y)^{'}_\mathit{ty} F {R^l}(y)^{'}_\mathit{tx} \in \mathit{st}$
 can not hold.
Thus, the G1-a condition ca be directly translated to the expression $\not\exists a_\mathit{tx} \in \mathit{st} \;
 \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
  \not\exists a_\mathit{ty} \in \mathit{st} \;
 \left( {W^k}(y)^{'}_\mathit{ty} F {R^l}(y)^{'}_\mathit{tx} \in \mathit{st} \right)$ in Equation \ref{eqn:PL2}.
  \textbf{G1-b}: According to G1-b, a transaction must always read the final committed version of an object.
  Let us consider consecutive write operations  $w^i(x)_\mathit{tx}$ and  $w^j(x)_\mathit{tx}$ invoked from transacton $\mathit{tx}$
   followed by the commit statement $c_\mathit{tx}$, and a read operation $r^k(x)_\mathit{ty}$ invoked from transaction $\mathit{ty}$, i.e.,
   $ {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st}$.
 According to G1-b, $ty$ can never read a value written by an operation in $tx$ that was not finally committed by $tx$.
 Thus, $r^k(x)_\mathit{ty}$ cannot return the result of $w^i(x)_\mathit{tx}$ since it was overwritten by another write
  $w^j(x)_\mathit{tx}$ before the commit $c_\mathit{tx}$.
 The above condtion can be expressed as $\not\exists \big( \big(
 {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \big)
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge
   \not\exists \big( \big(
 {W^i}(x)^{'}_\mathit{ty}  F {W^j}(x)^{'}_\mathit{ty} F  c_\mathit{ty} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st} \big)
   \wedge \left( v_k^{'} = v_i^{'} \right)  \big)$.
 \textbf{G1-c}: %PL-2 orders all operations according to their w-r dependency, i.e., if their is a write
% followed by a read in an execution sequence, all executions must contain the above write and read in the same order.
  G1-c specifies that there can be no direct cycle comprising dependency edges, i.e., $wr$ and $ww$ dependencies, between
  trasactions in a given execution. The condition $\not\exists \big(
 {W^i}(x)^{'}_\mathit{tx}, {R^j}(y)^{'}_\mathit{tx}, {W^k}(y)^{'}_\mathit{ty}, {R^l}(x)^{'}_\mathit{ty} \in  \mathit{St} \big)
   \big( \left( v_l^{'} = v_i^{'} \right) \wedge \left( v_k^{'} = v_j^{'} \right) \big)$ proscribes $wr$ dependency cycles. The expression
   \\ $\left( \not\exists {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty}, {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \\
% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big)$
proscribes $ww$ cycles. % In
%  the LHS of Equation \ref{eqn:PL2}, the expressions
%  $ \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \\
%\wedge \left( W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)
%$ denotes the condition that there are write operations followed by read operations in the execution order of
% transactions $tx$ and $ty$, respectively. Similarly, the RHS of Equation \ref{eqn:PL2} indicates the
% following. Let us consider that the above condition holds for a given session trace. Then, read operations
%   that follow the operations $w^i_{tx}$ and $r^j_{tx}$, or $w^k_{ty}$ and $r^l_{ty}$, respectively, in the respective transactions
% $tx$ and $ty$, must not observe results of write operations that occurred earlier than $w^i_{tx}$ or $w^k_{ty}$
% according in the session trace $\mathit{st}$.   This, in turn, implies that \\
%  $\not\exists W^m_\mathit{tx} \in \mathit{st} \left( W^m_\mathit{tx} F W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^m_\mathit{tx} F W^i_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^j = v^m \right) \\
%\wedge \not\exists W^n_\mathit{ty} \in \mathit{st} \left( W^n_\mathit{ty} F W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right) \wedge \left( W^n_\mathit{ty} F W^k_\mathit{ty} \in \mathit{st} \right) \\ \wedge \left( v^l = v^n \right)$,
%   thus Equation \ref{eqn:PL2} proscribes G1-c.
%     Further, in the RHS, all operations in $tx$ occur before the commit
%   operation $c_{tx}$ is executed in the session trace $\mathit{st}$. The above condition is true for operations in
%   transaction $ty$ as well, thus proscribing G1-a. Further, we can observe that in the RHS, $tx F ty$, i.e., an
%   operation in $ty$ can only occur after all operations in $tx$ have finished, proscribing G1-b.
 Thus, the ConSpec
   specification of PL-2 in  Equation \ref{eqn:PL2} proscribes G1-a, G1-b, and G1-c; thus, Equation \ref{eqn:PL2} is
   equivalent to PL-2 specifications by Adya et al.
% \begin{align}\label{eqn:PL2}
%\begin{split}
%\forall i, j, k, l, m, n, q, s, t, u, tx, ty \big( tx F ty \; \wedge \left( w^j_{tx}(o,v_l)X^{o} r^k_{tx}(o){v_m} \right) \\ \wedge \left( w^n_{ty}(o,v_q)X^{o} r^s_{tx}(o){v_u} \right)  \big)^\mathit{po}_{\mathit{o}_i} \\ \rightarrow \big(\left( v_l \gets (\left( w^j_{tx}(o,v_l) \; X^{o} \; r^k_{tx}(o){v_m} \right) \right) F \;  c_{tx} \\ F \; \left( v_q \gets \left( w^n_{ty}(o,v_q) \; X^{o} \; r^s_{ty}(o){v_u} \right) \right) \; F \; c_{ty} \star \big)^\mathit{st}_{\mathit{o}_i},
%\end{split}
%  \end{align}
 \par  The isolation level PL-3 proscribes the anomaly G-2 \cite{DBLP:conf/icde/AdyaLO00}. According to the
 ConSpec specification for PL-3 (refer to Equation \ref{eqn:PL3}), apart from proscribing G1 anomalies, G2 anomalies are
  also disallowed. According to G2, their can be
 effectively no cycle comprising anti-dependency edges between transactions. The expression \\
 $\big( \not\exists  \left({R^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in \mathit{St} \right) \wedge \\
  \big( {R^l}(x)^{'}_\mathit{ty} F {W^m}(x)^{'}_\mathit{tx} F {R^n}(x)^{'}_\mathit{tx} \in \mathit{St} \big)  \big) \big(  \left( v_k^{'} = v_j^{'} \right) \wedge
 \left( v_n^{'} = v_m^{'} \right) \big) \big)$ proscribes anti-dependency cycles. Thus, the
 ConSpec expression disallows G2, and effectively follows PL-3. Following the same line of reasoning, we can
  prove that the ConSpec expression in Equation \ref{eqn:PL299} effectively  specifies PL-2.99.

\section{SpecCheck: Automated Verification With ConSpec}


\section{Equivalence between State-of-the-art and ConSpec Notations}
 State-of-the-art definitions specify consistency levels in terms of dependency relations, namely
  $w \xrightarrow{wr} r$,  $w \xrightarrow{ww} w^{'}$, and  $w \xrightarrow{wr} r$ dependency, respectively
  \cite{Hennessy:2011:CAF:1999263}.  The $w \xrightarrow{wr} r$ dependency can be translated to the form
  $\exists \big( %\left(  \mathit{st}, \mathit{st}^{'} \in \mathit{St} \right) \wedge
  \left( W^i \in \mathit{st} \right)
  \wedge \left(  R^j \in \mathit{St} \right) \big) \\ \left( {v^i}^{'} = {v^j}^{''} \right)$, where we represent the write and read operations $w$ and $r$
  involved in the  dependency relation with the propositional variable $W^i$ and $R^j$, respectively. Denoting
  $w$, and $w^{'}$ with propositional variables $W^i$ and $W^j$, the
  dependency relation $w \xrightarrow{ww} w^{'}$ is translated into ConSpec form as follows.
  \begin{align}\label{eqn:ww}
\begin{split}
   \exists \big( %\left( \mathit{st}, \mathit{st}^{'} \in \mathit{St} \right) \wedge
   \left( {W^i}^{'} \in \mathit{st} \right)
   \wedge \left( {W^j}^{'}  \in  \mathit{St} \right)  \big)
   \big( %\wedge
 % \left( {W^i}^{'} \in \mathit{st} \right)
  \exists %\big(  %\left( \mathit{st}^{''} \in \mathit{St} \right) \wedge
  \left( { R^l}^{''} \in \mathit{St} \right) %\big)
  %\exists \left( \mathit{st}, \mathit{st}^{'} \in \mathit{St} \right)  %{W^i}^{'}  F { R^k}^{''} \in \mathit{st}^{''}  \wedge \\
  %\wedge {R^l}^{'''} F { R^k}^{'''} \in \mathit{st}^{''} \wedge
   \left( {v_l}^{''} = {v_j}^{''} \right) \\
   \wedge \big( \left(  {v_l}^{'} = {v_i}^{'} \right) \vee
  \big( \left( {W^i}^{''} F { R^l}^{''} \in \mathit{St} \right) \wedge \\
   \left(  \not\exists {W^i}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{St} \right)  \big) \big) \big) %\left( \not\exists {W^j}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{st}^{'} \; \wedge \; {v_l}^{'} = {v_j}^{'}
%  \right) \\
%  \vee \left( \exists {W^j}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{st}^{'} \right) \left({v_l}^{'} = {v_m}^{'}  \right) \big) % \\
  %\not\exists {W^i}^{'} F {W^n}^{'} F { R^l}^{'} \in \mathit{st}  \big)
   %\big( \left( {v_k}^{'} = {v_j}^{'}  \right) \vee \\
   %\exists \left( \mathit{st}^{'''} \in \mathit{St} \wedge {W^j}^{''''} F {W^m}^{''''} F { R^k}^{''''}  \in \mathit{st}^{'''} \right)
   %\left( {v_k}^{'} = {v_m}^{'}  \right) \big).
   \end{split}
   \end{align}
   Similarly, denoting  $r$, and $w$ with propositional variables $R^i$ and $W^j$, the
   $r \xrightarrow{rw} w$ dependency is translated into ConSpec form as follows.
     \begin{align}\label{eqn:rw}
\begin{split}
\exists \big( %\left( \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''}  \in \mathit{St} \right)  \wedge
\left( {R^i}^{'} \in \mathit{st} \right)
   \wedge \left( {W^j}^{'}  \in  \mathit{St} \right) \wedge
   \left( \exists  {W^k}^{''} \in \mathit{st}  \right) \\
   \left( {v_i}^{'} = {v_k}^{'} \right) \wedge
  \left( \exists {R^l}^{''} \in \mathit{St}  \right) \left( {v_l}^{'} = {v_j}^{'} \right)  \big)
 \big( \left( {v_k}^{'} = {v_l}^{'} \right) \vee \\
  \big(  \left( {W^k}^{''} F { R^l}^{''} \in \mathit{St} \right) \wedge
    \left(  \not\exists {W^k}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{St}  \right) \big) \big)
   %\left( {W^j}^{''} F { R^l}^{''} \in \mathit{st}^{'} \right) \wedge
% \left( \not\exists {W^m}^{'} F {R^i}^{'} \in \mathit{st}^{''} \right) \left( {v_l}^{'} = {v_m}^{'} \right) \big)
 % \big( {v_l}^{'} = {v_j}^{'}
  %\; \vee \left( \exists {W^j}^{''} F {W^n}^{'} \in \mathit{st}^{'} \right) \\
  %\left( {v_j}^{'} = {v_n}^{'} \right) \big).
  \end{split}
  \end{align}
   \par Adya et al. define isolation  levels in terms of $w \xrightarrow{wr} r$,
   $w \xrightarrow{ww} w^{'}$, and  $w \xrightarrow{wr} r$  dependencies among transactions
   \cite{DBLP:conf/icde/AdyaLO00}. The $wr$ dependency relation of the dependency graph can be translated into
   ConSpec form \\ $\exists \big( %\left(  \mathit{st}, \mathit{st}^{'} \in \mathit{St} \right) \wedge
   \left( W^i_\mathit{tx} \in \mathit{st} \right)
  \wedge \left(  R^j_\mathit{ty} \in \mathit{St} \right) \big) \left( {v^i}^{'} = {v^j}^{''} \right) $. The $ww$ dependency relation
    between transactions $\mathit{tx}$ and $\mathit{ty}$ can be translated to \begin{align}\label{eqn:ww}
\begin{split}
 \exists \big( %\left( \mathit{st}, \mathit{st}^{'} \in \mathit{St} \right) \wedge
 \left( {W^i}^{'}_\mathit{tx} \in \mathit{st} \right)
   \wedge \left( {W^j}^{'}_\mathit{yx}  \in  \mathit{St} \right)  \big)
   \big( %\wedge
 % \left( {W^i}^{'} \in \mathit{st} \right)
  \exists %\big( % \left( \mathit{st}^{''} \in \mathit{St} \right) \wedge
  \left( { R^l}^{''}\mathit{ty} \in \mathit{St} \right) %\big)
  %\exists \left( \mathit{st}, \mathit{st}^{'} \in \mathit{St} \right)  %{W^i}^{'}  F { R^k}^{''} \in \mathit{st}^{''}  \wedge \\
  %\wedge {R^l}^{'''} F { R^k}^{'''} \in \mathit{st}^{''} \wedge
   \left( {v_l}^{''} = {v_j}^{''} \right)
   \wedge \\
   \big( \left(  {v_l}^{'} = {v_i}^{'} \right) \vee
  \big( \left( {W^i}^{''} F { R^l}^{''}_\mathit{ty} \in \mathit{St} \right) \wedge \\
   \big( \left(  \not\exists {W^i}^{''}_\mathit{tx} F {W^m}^{''}_\mathit{tx} F { R^l}^{''}_\mathit{ty} \in \mathit{St} \right)
  \wedge  \left(  \not\exists {W^i}^{''}_\mathit{tx} F {W^m}^{''}_\mathit{ty} F { R^l}^{''}_\mathit{ty} \in \mathit{St} \right) \big) \big) \big) \big)
  %\left( \not\exists {W^j}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{st}^{'} \; \wedge \; {v_l}^{'} = {v_j}^{'}
  % \exists \big( \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''} \in \mathit{St} \wedge
%  {W^i}^{'}_\mathit{tx} F { R^l}^{'}_\mathit{tx} \in \mathit{st}
%  \wedge {W^j}^{''}_\mathit{ty} F { R^k}^{''}_\mathit{ty} \in \mathit{st}^{'} \\
%  \wedge {R^l}^{'''}_\mathit{tx} F { R^k}^{'''}_\mathit{ty} \in \mathit{st}^{''} \wedge
%  \not\exists {W^j}^{''}_\mathit{ty} F {W^m}^{''}_\mathit{ty} F { R^k}^{''}_\mathit{ty} \in \mathit{st}^{'} \wedge \\
%  \not\exists {W^i}^{'}_\mathit{tx} F {W^n}^{'}_\mathit{tx} F { R^l}^{'}_\mathit{tx} \in \mathit{st}  \big)
%   \big( \left( {v_k}^{'} = {v_j}^{'}  \right) \vee \\
%   \exists \left( \mathit{st}^{'''} \in \mathit{St} \wedge {W^j}^{''''}_\mathit{ty} F {W^m}^{''''}_\mathit{ty} F { R^k}^{''''}_\mathit{tx}  \in \mathit{st}^{'''} \right)
%   \left( {v_k}^c{'} = {v_m}^{'}  \right) \big).
   \end{split}
   \end{align}
 The $rw$ dependency relation between transactions $\mathit{tx}$ and $\mathit{ty}$ can be translated into ConSpec form
  \begin{align}\label{eqn:rw}
\begin{split}
\exists \big( %\left( \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''}  \in \mathit{St} \right)  \wedge
\left( {R^i}^{'}_\mathit{tx} \in \mathit{st} \right)
   \wedge \left( {W^j}^{'}_\mathit{ty}  \in  \mathit{St} \right) \wedge
   \left( \exists  {W^k}^{''}_\mathit{tx} \in \mathit{st}  \right)
   \left( {v_i}^{'} = {v_k}^{'} \right)  \wedge \\
  \left( \exists {R^l}^{''}_\mathit{ty} \in \mathit{St}  \right) \left( {v_l}^{'} = {v_j}^{'} \right)  \big)
  \big( \left( {v_k}^{'} = {v_l}^{'} \right) \vee  \big(  \left( {W^k}^{''}_\mathit{tx} F { R^l}^{''}_\mathit{ty} \in \mathit{st}^{''} \right) \\ \wedge
    \big( \left(  \not\exists {W^k}^{''}_\mathit{tx} F {W^m}^{''}_\mathit{tx} F { R^l}^{''}_\mathit{ty} \in \mathit{St} \right) \wedge
   \left(  \not\exists {W^k}^{''}_\mathit{tx} F {W^m}^{''}_\mathit{ty} F { R^l}^{''}_\mathit{ty} \in \mathit{St} \right) \big) \big)
%\left( \exists \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''}  \in \mathit{St} \right) \big(
%  \left( {R^i}^{'}_\mathit{tx} F {W^j}^{''}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%   \left( {W^j}^{''}_\mathit{ty} F { R^l}^{''}_\mathit{ty} \in \mathit{st}^{'} \right) \wedge
% \left( \not\exists {W^m}^{'}_\mathit{tx} F {R^i}^{'}_\mathit{tx} \in \mathit{st}^{''} \right) \left( {v_l}^{'} = {v_m}^{'} \right) \big).
%\exists \big( \mathit{st}, \mathit{st}^{'} \in \mathit{St} \wedge
%  {W^k}^{'}_\mathit{tx} F { R^i}^{'}_\mathit{tx} \in \mathit{st} \wedge {W^j}^{''}_\mathit{ty} F { R^l}^{''}_\mathit{ty} \in \mathit{st}^{'} \wedge \\
%  \not\exists {W^k}^{'}_\mathit{tx} F {R^l}^{'}_\mathit{ty} F { R^i}^{'}_\mathit{tx} \in \mathit{st} \big) \big( {v_l}^{'} = {v_j}^{'}
%  \; \vee \left( \exists {W^j}^{''}_\mathit{ty} F {W^m}^{'}_\mathit{ty} \in \mathit{st}^{'} \right) \\
%  \left( {v_j}^{'} = {v_m}^{'} \right) \big).
  \end{split}
  \end{align}

\section{Verification Approach: Comparison With the State-of-the-art}\label{sec:compare}
 Here, we compare our approach of analyzing session traces against ConSpec specification with the traditional approach of analyzing server traces \cite{DBLP:conf/icde/AdyaLO00, Chockler2000, Terry:1994:SGW:645792.668302, Burckhardt:2014:PEC:2693641.2693642}. Let us start by assuming that both approaches use a single expression to represent a given consistency model or isolation level. Let us also assume that session traces used in our approach, and server traces used in traditional approaches, are equivalent in the context of complexity analysis.  Under the above assumptions, complexity of trace analysis with our approach can be potentially worse than the server trace analysis approach if anomaly exists in a given trace. This can be attributed to the fact that, with the server trace analysis approach, the analysis terminates as soon as an anomaly is found in any portion of a given execution trace.  Contrastingly, with our approach, the analysis may continue till the very end of the trace, since it checks if all portions of the trace conforms to the ConSpec specifications. Thus a trace analysis may terminate earlier with the server trace analysis approach. However, we fix the problem by modifying our approach to indirectly detect anomalies (see later part of this Section), thus enabling it to terminate early, similar to the server trace analysis approach.
\par On the other hand, in absence of anomalies in a given execution, i.e., in both the session trace and the server trace for the execution, the complexity of our approach matches the server trace analysis approach; since, in this case, the analysis with both approaches terminate at the very end of the trace. We further reduce the search space of session trace for session trace analysis, by considering only the session traces comprising operations performed on a concerned object.
 However, in reality, with the anomaly analysis approach, a consistency model or isolation level is typically represented by two components: 1) axiomatic rules, given by a group of first order logic expressions, representing the allowed execution order among operations, and 2)  DSGs representing the anomalies proscribed by the given consistency model or isolation level. On the other hand, our approach uses only a single LTL-like expression to express the same consistency model or isolation level. Thus, the server trace analysis approach compares each element in an  execution trace with two components. Contrastingly, with our approach, each element in a session trace is compared with only a single ConSpec expression. Hence, the complexity of the server trace analysis approach (refer to Section \ref{sec:complex}) is roughly twice the complexity with our approach, particularly in the case of absence of anomaly in a given trace. In the presence of anomalies in a session trace, the complexity analysis is more complicated; we need to consider the position of the first occurrence of an anomaly with respect to the size of the trace (TO DO).
\par Moreover, the traditional approach of server trace analysis involves analysis of execution traces collected from server nodes comprising the datastore cluster. It analyzes whether the results of operations observed at the system end, i.e., at the end of the datastore, matches the results expected as per a given consistency model or isolation level. Thus, this approach considers a system-centric view of a given consistency model or isolation level. On the other hand, we analyze whether a session trace, observed from a client application, satisfies the specification for a given consistency model or isolation level, i.e., whether the results in the session trace follow an order that is allowed by the above specification. Hence, our approach is concerned with client-centric view of a given consistency model or isolation level. Further, the traditional approach has the disadvantage of having to deal with much longer traces, comprising execution of operations performed from multiple applications or sessions on datastore servers. Extracting a session trace from a server trace is a computationally expensive task by itself, since it requires an exhaustive search on the server trace to identify portions that are relevant to a given application. Contrastingly, our approach directly analyzes session traces, collected from the client machines.
 \def\tuple#1{\langle #1\rangle}

\section{Complexity of Verification: Comparison with the State-of-the-art}\label{sec:complex}
 A session trace is comprised of results of execution of storage operations invoked from a client application on a target storage system, observed from a client machine. Let $\mathit{op}_i$ be unique signature of the
$i^\mathit{th}$ operation invoked from a given client application. $\mathit{op}_i$ can be a read or write operation that reads (or writes) a unique value from (or to) a datastore object $o_j$; signature of a read and write operation are of the form $r^k(o){v_m}$ and $w^j(o,v_l)$, respectively.
 Let $v_k$ be the current value observed against the operation $\mathit{op}_i$ on an object $o_j$. Let the length of the given session trace be denoted by the integer term $s_t$. A a session trace $\mathcal{S}_t$ can be expressed as a collection of tuples, where each tuple comprises: 1) the unique signature of the operation, 2) the name of the datastore object that the operation accesses, 3) the value written by the operation. Using the above notations, a session trace $\mathcal{S}_t$ is given as $\mathcal{S}_t$ = \[ \Set{\tuple{\mathit{op}_i,o_j,v_k}} {1\le i \le s_t, 1\le j\le m, 1\le k\le n}{.} \]
Let the ConSpec expression for a given consistency
 guarantee or an isolation level be given as $\mathcal{E}_c$ =\[ \Set{e_i} {1\le i\le s_c}{,} \] where
 $e_i$ is the $i^\mathit{th}$ character in the ConSpec expression, and the length of a given ConSpec expression is $s_c$.
 %$\tuple{\mathit{op}_i,o_j,v_k}$
It can be verified whether a storage system actually supports a consistency guarantee or an isolation level by analyzing a session trace with respect to the ConSpec specification for the above consistency guarantee or isolation level. Verifying a given session trace $\mathcal{S}_t$ against a specification $\mathcal{E}_c$  involves comparing the observed result of each operation in
  $\mathcal{S}_t$ against each expression in $\mathcal{E}_c$. The complexity (here we consider time complexity) of comparing each character in a session trace $\mathcal{S}_t$ against the specification $\mathcal{E}_c$ is equivalent to the length of the specification, i.e., $s_c$. For verification, the above step is repeated for all characters in the session trace (in the absence of anomalies). Thus, the total complexity  of verifying a session trace against a given ConSpec specification is $s_t \times s_c$.
\par  As already discussed in Section \ref{sec:compare}, state-of-the-art definitions of consistency models and isolation levels comprise a combination of axiomatic rules and anomaly DSGs. Let the total number of axiomatic rules in a state-of-the-art consistency specification  be $n_e$. Let the length of the expression for each axiomatic rule comprising a state-of-the-art specification  be $s_1$, $s_2$, ..., $s_{n_e}$, respectively. Thus, the total length of such expressions in a state-of-the-art specification
 is given as $\mathcal{E}_s$ =\[ \Set{\mathcal{E}^{i}_s}{1\le i\le n_e}{,}{,}\] where $\mathcal{E}^{i}_s$ is the $i^\mathit{th}$
 expression in the given specification. The process of verifying a given session trace against a specification involves comparing each expression in the given specification with each character in the session trace. The complexity (time complexity) of comparing the expression $\mathcal{E}^{i}_s$ against the session trace can be given as $s_t \times s_i$, where $s_i$ is the length of $\mathcal{E}^{i}_s$. The total complexity of verifying the given session trace against the above expressions comprising the given specification involves carrying out the above step for all expressions in the specification, which in turn, can be given as $s_t \times \left(s_1+s_2+...+s_{n_e}\right)$. Now, let us consider verifying the given session trace against the anomaly DSGs for the given specification. Let the number of anomaly DSGs for a given specification be $n_g$. Let the size of each anomaly DSG be $g_1$, $g_2$, ...., $g_{n_g}$. Verifying a given session trace against an anomaly DSG involves performing
 a pattern search in each of the DGSs with the session trace. The complexity $\mathcal{C}$ of the above search, using any algorithm based on Depth First Search,  can be given as $\mathcal{C}$ = $V+E$, where $V$ and $E$ are the number of vertices and edges in each DSG,
 respectively. Considering each DSG to be fully connected, the number of edges approximately equals the number of vertices
  -1, i.e., $E \approx V - 1$. Hence, $\mathcal{C}$ can be further rewritten as $\mathcal{C}=V+E\approx 2V -1$. Thus, the complexity of a graph search algorithm can be given $\approx 2V -1$. The total complexity
  of verifying he given session trace against anomaly DSGs involves performing the above pattern search for all anomaly DSGs comprising the given specification. Thus, the total complexity of verifying against anomaly DSGs can be given as
  $s_t \times 2 \times \left( g_1 + g_2 ... + g_{n_g} \right) - n_g$.  Combining the complexity of verifying against the expressions and the complexity of verifying against the anomaly DSGs, the total complexity of verification
   as per the state-of-the-art can be given as
   $s_t \times \left( s_1+s_2+...+s_{n_e} + 2 \times g_1 + 2 \times g_2 ... + 2 \times g_{n_g} - n_g \right).$
   \par According to the state-of-the-art definitions, the specification for Processor Consistency is of the largest size. The total number of characters in the rules for Processor Consistency is  30. It also comprises 3 DSGs, each with 3, 7, and 3 vertices, respectively. Then, using the formula 2V+1 for analyzing the DSGs using Depth first search, the  complexity of DSG analyzing is approximately $(5+13+5) \times s_t$ = $23 \times s_t$. Thus the total complexity of verifying Processor consistency is approximately $53 \times s_t$. On the other hand, the size of the ConSpec specification for Processor Consistency is 31, not counting parenthesis, punctuation symbols, and scope operators. Thus, the complexity of analysis using ConSpec is $31 \times s_t$. Thus, the complexity of verification using ConSpec is considerably less than that using the state-of-the-art. Similarly, the complexity of verifying other consistency models and isolation levels are also lower with ConSpec (TO DO).

 %$\square \lozenge \oplus \wedge \rightarrow \models \lnot$
%The \textit{proceedings} are the records of a conference.
%ACM seeks to give these conference by-products a uniform,
%high-quality appearance.  To do this, ACM has some rigid
%requirements for the format of the proceedings documents: there
%is a specified format (balanced  double columns), a specified
%set of fonts (Arial or Helvetica and Times Roman) in
%certain specified sizes (for instance, 9 point for body copy),
%a specified live area (18 $\times$ 23.5 cm [7" $\times$ 9.25"]) centered on
%the page, specified size of margins (1.9 cm [0.75"]) top, (2.54 cm [1"]) bottom
%and (1.9 cm [.75"]) left and right; specified column width
%(8.45 cm [3.33"]) and gutter size (.83 cm [.33"]).
%
%The good news is, with only a handful of manual
%settings\footnote{Two of these, the {\texttt{\char'134 numberofauthors}}
%and {\texttt{\char'134 alignauthor}} commands, you have
%already used; another, {\texttt{\char'134 balancecolumns}}, will
%be used in your very last run of \LaTeX\ to ensure
%balanced column heights on the last page.}, the \LaTeX\ document
%class file handles all of this for you.
%
%The remainder of this document is concerned with showing, in
%the context of an ``actual'' document, the \LaTeX\ commands
%specifically available for denoting the structure of a
%proceedings paper, rather than with giving rigorous descriptions
%or explanations of such commands.
%
%\section{The {\secit Body} of The Paper}
%Typically, the body of a paper is organized
%into a hierarchical structure, with numbered or unnumbered
%headings for sections, subsections, sub-subsections, and even
%smaller sections.  The command \texttt{{\char'134}section} that
%precedes this paragraph is part of such a
%hierarchy.\footnote{This is the second footnote.  It
%starts a series of three footnotes that add nothing
%informational, but just give an idea of how footnotes work
%and look. It is a wordy one, just so you see
%how a longish one plays out.} \LaTeX\ handles the numbering
%and placement of these headings for you, when you use
%the appropriate heading commands around the titles
%of the headings.  If you want a sub-subsection or
%smaller part to be unnumbered in your output, simply append an
%asterisk to the command name.  Examples of both
%numbered and unnumbered headings will appear throughout the
%balance of this sample document.
%
%Because the entire article is contained in
%the \textbf{document} environment, you can indicate the
%start of a new paragraph with a blank line in your
%input file; that is why this sentence forms a separate paragraph.
%
%\subsection{Type Changes and {\subsecit Special} Characters}
%We have already seen several typeface changes in this sample.  You
%can indicate italicized words or phrases in your text with
%the command \texttt{{\char'134}textit}; emboldening with the
%command \texttt{{\char'134}textbf}
%and typewriter-style (for instance, for computer code) with
%\texttt{{\char'134}texttt}.  But remember, you do not
%have to indicate typestyle changes when such changes are
%part of the \textit{structural} elements of your
%article; for instance, the heading of this subsection will
%be in a sans serif\footnote{A third footnote, here.
%Let's make this a rather short one to
%see how it looks.} typeface, but that is handled by the
%document class file. Take care with the use
%of\footnote{A fourth, and last, footnote.}
%the curly braces in typeface changes; they mark
%the beginning and end of
%the text that is to be in the different typeface.
%
%You can use whatever symbols, accented characters, or
%non-English characters you need anywhere in your document;
%you can find a complete list of what is
%available in the \textit{\LaTeX\
%User's Guide}\cite{Lamport:LaTeX}.
%
%\subsection{Math Equations}
%You may want to display math equations in three distinct styles:
%inline, numbered or non-numbered display.  Each of
%the three are discussed in the next sections.
%
%\subsubsection{Inline (In-text) Equations}
%A formula that appears in the running text is called an
%inline or in-text formula.  It is produced by the
%\textbf{math} environment, which can be
%invoked with the usual \texttt{{\char'134}begin. . .{\char'134}end}
%construction or with the short form \texttt{\$. . .\$}. You
%can use any of the symbols and structures,
%from $\alpha$ to $\omega$, available in
%\LaTeX\cite{Lamport:LaTeX}; this section will simply show a
%few examples of in-text equations in context. Notice how
%this equation: \begin{math}\lim_{n\rightarrow \infty}x=0\end{math},
%set here in in-line math style, looks slightly different when
%set in display style.  (See next section).
%
%\subsubsection{Display Equations}
%A numbered display equation -- one set off by vertical space
%from the text and centered horizontally -- is produced
%by the \textbf{equation} environment. An unnumbered display
%equation is produced by the \textbf{displaymath} environment.
%
%Again, in either environment, you can use any of the symbols
%and structures available in \LaTeX; this section will just
%give a couple of examples of display equations in context.
%First, consider the equation, shown as an inline equation above:
%\begin{equation}\lim_{n\rightarrow \infty}x=0\end{equation}
%Notice how it is formatted somewhat differently in
%the \textbf{displaymath}
%environment.  Now, we'll enter an unnumbered equation:
%\begin{displaymath}\sum_{i=0}^{\infty} x + 1\end{displaymath}
%and follow it with another numbered equation:
%\begin{equation}\sum_{i=0}^{\infty}x_i=\int_{0}^{\pi+2} f\end{equation}
%just to demonstrate \LaTeX's able handling of numbering.
%
%\subsection{Citations}
%Citations to articles \cite{bowman:reasoning,
%clark:pct, braams:babel, herlihy:methodology},
%conference proceedings \cite{clark:pct} or
%books \cite{salas:calculus, Lamport:LaTeX} listed
%in the Bibliography section of your
%article will occur throughout the text of your article.
%You should use BibTeX to automatically produce this bibliography;
%you simply need to insert one of several citation commands with
%a key of the item cited in the proper location in
%the \texttt{.tex} file \cite{Lamport:LaTeX}.
%The key is a short reference you invent to uniquely
%identify each work; in this sample document, the key is
%the first author's surname and a
%word from the title.  This identifying key is included
%with each item in the \texttt{.bib} file for your article.
%
%The details of the construction of the \texttt{.bib} file
%are beyond the scope of this sample document, but more
%information can be found in the \textit{Author's Guide},
%and exhaustive details in the \textit{\LaTeX\ User's
%Guide}\cite{Lamport:LaTeX}.
%
%This article shows only the plainest form
%of the citation command, using \texttt{{\char'134}cite}.
%This is what is stipulated in the SIGS style specifications.
%No other citation format is endorsed or supported.
%
%\subsection{Tables}
%Because tables cannot be split across pages, the best
%placement for them is typically the top of the page
%nearest their initial cite.  To
%ensure this proper ``floating'' placement of tables, use the
%environment \textbf{table} to enclose the table's contents and
%the table caption.  The contents of the table itself must go
%in the \textbf{tabular} environment, to
%be aligned properly in rows and columns, with the desired
%horizontal and vertical rules.  Again, detailed instructions
%on \textbf{tabular} material
%is found in the \textit{\LaTeX\ User's Guide}.
%
%Immediately following this sentence is the point at which
%Table 1 is included in the input file; compare the
%placement of the table here with the table in the printed
%dvi output of this document.
%
%\begin{table}
%\centering
%\caption{Frequency of Special Characters}
%\begin{tabular}{|c|c|l|} \hline
%Non-English or Math&Frequency&Comments\\ \hline
%\O & 1 in 1,000& For Swedish names\\ \hline
%$\pi$ & 1 in 5& Common in math\\ \hline
%\$ & 4 in 5 & Used in business\\ \hline
%$\Psi^2_1$ & 1 in 40,000& Unexplained usage\\
%\hline\end{tabular}
%\end{table}
%
%To set a wider table, which takes up the whole width of
%the page's live area, use the environment
%\textbf{table*} to enclose the table's contents and
%the table caption.  As with a single-column table, this wide
%table will ``float" to a location deemed more desirable.
%Immediately following this sentence is the point at which
%Table 2 is included in the input file; again, it is
%instructive to compare the placement of the
%table here with the table in the printed dvi
%output of this document.
%
%
%\begin{table*}
%\centering
%\caption{Some Typical Commands}
%\begin{tabular}{|c|c|l|} \hline
%Command&A Number&Comments\\ \hline
%\texttt{{\char'134}alignauthor} & 100& Author alignment\\ \hline
%\texttt{{\char'134}numberofauthors}& 200& Author enumeration\\ \hline
%\texttt{{\char'134}table}& 300 & For tables\\ \hline
%\texttt{{\char'134}table*}& 400& For wider tables\\ \hline\end{tabular}
%\end{table*}
%% end the environment with {table*}, NOTE not {table}!
%
%\subsection{Figures}
%Like tables, figures cannot be split across pages; the
%best placement for them
%is typically the top or the bottom of the page nearest
%their initial cite.  To ensure this proper ``floating'' placement
%of figures, use the environment
%\textbf{figure} to enclose the figure and its caption.
%
%This sample document contains examples of \textbf{.eps} files to be
%displayable with \LaTeX.  If you work with pdf\LaTeX, use files in the
%\textbf{.pdf} format.  Note that most modern \TeX\ system will convert
%\textbf{.eps} to \textbf{.pdf} for you on the fly.  More details on
%each of these is found in the \textit{Author's Guide}.
%
%\begin{figure}
%\centering
%\includegraphics{fly}
%\caption{A sample black and white graphic.}
%\end{figure}
%
%\begin{figure}
%\centering
%\includegraphics[height=1in, width=1in]{fly}
%\caption{A sample black and white graphic
%that has been resized with the \texttt{includegraphics} command.}
%\end{figure}
%
%
%As was the case with tables, you may want a figure
%that spans two columns.  To do this, and still to
%ensure proper ``floating'' placement of tables, use the environment
%\textbf{figure*} to enclose the figure and its caption.
%and don't forget to end the environment with
%{figure*}, not {figure}!
%
%\begin{figure*}
%\centering
%\includegraphics{flies}
%\caption{A sample black and white graphic
%that needs to span two columns of text.}
%\end{figure*}
%
%
%\begin{figure}
%\centering
%\includegraphics[height=1in, width=1in]{rosette}
%\caption{A sample black and white graphic that has
%been resized with the \texttt{includegraphics} command.}
%\vskip -6pt
%\end{figure}
%
%\subsection{Theorem-like Constructs}
%Other common constructs that may occur in your article are
%the forms for logical constructs like theorems, axioms,
%corollaries and proofs.  There are
%two forms, one produced by the
%command \texttt{{\char'134}newtheorem} and the
%other by the command \texttt{{\char'134}newdef}; perhaps
%the clearest and easiest way to distinguish them is
%to compare the two in the output of this sample document:
%
%This uses the \textbf{theorem} environment, created by
%the\linebreak\texttt{{\char'134}newtheorem} command:
%\newtheorem{theorem}{Theorem}
%\begin{theorem}
%Let $f$ be continuous on $[a,b]$.  If $G$ is
%an antiderivative for $f$ on $[a,b]$, then
%\begin{displaymath}\int^b_af(t)dt = G(b) - G(a).\end{displaymath}
%\end{theorem}
%
%The other uses the \textbf{definition} environment, created
%by the \texttt{{\char'134}newdef} command:
%\newdef{definition}{Definition}
%\begin{definition}
%If $z$ is irrational, then by $e^z$ we mean the
%unique number which has
%logarithm $z$: \begin{displaymath}{\log e^z = z}\end{displaymath}
%\end{definition}
%
%Two lists of constructs that use one of these
%forms is given in the
%\textit{Author's  Guidelines}.
%
%There is one other similar construct environment, which is
%already set up
%for you; i.e. you must \textit{not} use
%a \texttt{{\char'134}newdef} command to
%create it: the \textbf{proof} environment.  Here
%is a example of its use:
%\begin{proof}
%Suppose on the contrary there exists a real number $L$ such that
%\begin{displaymath}
%\lim_{x\rightarrow\infty} \frac{f(x)}{g(x)} = L.
%\end{displaymath}
%Then
%\begin{displaymath}
%l=\lim_{x\rightarrow c} f(x)
%= \lim_{x\rightarrow c}
%\left[ g{x} \cdot \frac{f(x)}{g(x)} \right ]
%= \lim_{x\rightarrow c} g(x) \cdot \lim_{x\rightarrow c}
%\frac{f(x)}{g(x)} = 0\cdot L = 0,
%\end{displaymath}
%which contradicts our assumption that $l\neq 0$.
%\end{proof}
%
%Complete rules about using these environments and using the
%two different creation commands are in the
%\textit{Author's Guide}; please consult it for more
%detailed instructions.  If you need to use another construct,
%not listed therein, which you want to have the same
%formatting as the Theorem
%or the Definition\cite{salas:calculus} shown above,
%use the \texttt{{\char'134}newtheorem} or the
%\texttt{{\char'134}newdef} command,
%respectively, to create it.
%
%\subsection*{A {\secit Caveat} for the \TeX\ Expert}
%Because you have just been given permission to
%use the \texttt{{\char'134}newdef} command to create a
%new form, you might think you can
%use \TeX's \texttt{{\char'134}def} to create a
%new command: \textit{Please refrain from doing this!}
%Remember that your \LaTeX\ source code is primarily intended
%to create camera-ready copy, but may be converted
%to other forms -- e.g. HTML. If you inadvertently omit
%some or all of the \texttt{{\char'134}def}s recompilation will
%be, to say the least, problematic.
%
%\section{Conclusions}
%This paragraph will end the body of this sample document.
%Remember that you might still have Acknowledgments or
%Appendices; brief samples of these
%follow.  There is still the Bibliography to deal with; and
%we will make a disclaimer about that here: with the exception
%of the reference to the \LaTeX\ book, the citations in
%this paper are to articles which have nothing to
%do with the present subject and are used as
%examples only.
%%\end{document}  % This is where a 'short' article might terminate
%
%%ACKNOWLEDGMENTS are optional
%\section{Acknowledgments}
%This section is optional; it is a location for you
%to acknowledge grants, funding, editing assistance and
%what have you.  In the present case, for example, the
%authors would like to thank Gerald Murray of ACM for
%his help in codifying this \textit{Author's Guide}
%and the \textbf{.cls} and \textbf{.tex} files that it describes.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{allrec}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
%\appendix
%%Appendix A
%\section{Headings in Appendices}
%The rules about hierarchical headings discussed above for
%the body of the article are different in the appendices.
%In the \textbf{appendix} environment, the command
%\textbf{section} is used to
%indicate the start of each Appendix, with alphabetic order
%designation (i.e. the first is A, the second B, etc.) and
%a title (if you include one).  So, if you need
%hierarchical structure
%\textit{within} an Appendix, start with \textbf{subsection} as the
%highest level. Here is an outline of the body of this
%document in Appendix-appropriate form:
%\subsection{Introduction}
%\subsection{The Body of the Paper}
%\subsubsection{Type Changes and  Special Characters}
%\subsubsection{Math Equations}
%\paragraph{Inline (In-text) Equations}
%\paragraph{Display Equations}
%\subsubsection{Citations}
%\subsubsection{Tables}
%\subsubsection{Figures}
%\subsubsection{Theorem-like Constructs}
%\subsubsection*{A Caveat for the \TeX\ Expert}
%\subsection{Conclusions}
%\subsection{Acknowledgments}
%\subsection{Additional Authors}
%This section is inserted by \LaTeX; you do not insert it.
%You just add the names and information in the
%\texttt{{\char'134}additionalauthors} command at the start
%of the document.
%\subsection{References}
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
%% This next section command marks the start of
%% Appendix B, and does not continue the present hierarchy
%\section{More Help for the Hardy}
%The sig-alternate.cls file itself is chock-full of succinct
%and helpful comments.  If you consider yourself a moderately
%experienced to expert user of \LaTeX, you may find reading
%it useful but please remember not to change it.
%\balancecolumns % GM June 2007
% That's all folks!
\end{document}
