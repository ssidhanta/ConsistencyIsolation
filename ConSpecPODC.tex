%\documentclass{sig-alternate-05-2015}
%\documentclass[journal,compsoc]{IEEEtran}
\documentclass[conference]{IEEEtran}
%\documentclass[acmlarge, ,11pt]{acmart}
%\usepackage{pdfpages}
%\citestyle{acmauthoryear}
%\usepackage{booktabs} % For formal tables
\usepackage{changes}
\usepackage[ruled]{algorithm2e} % For algorithms
\usepackage{subfigure}
\usepackage{marvosym}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{algpseudocode}
%\usepackage{algorithm}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{listings}
\usepackage{amsmath,bm,times,amssymb}
\usepackage{textcomp}
\usepackage[breaklinks=true,bookmarks=false]{hyperref}
%\usepackage[hyphenbreaks]{breakurl}
\usepackage[numbers]{natbib}
\usepackage{accents}
\definechangesauthor[name=Subhajit, color=red]{1}
\definechangesauthor[name=Rodrigo, color=blue]{2}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
 %\newtheorem {theorem} {Theorem}
 %\newtheorem{corollary} {corollary} [theorem]
 \newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\DeclarePairedDelimiterX\Set[2]{\lbrace}{\rbrace}%
{ #1 \,\delimsize|\,\mathopen{} #2 }
\newsavebox{\ieeealgbox}
\newenvironment{boxedalgorithmic}
  {\begin{lrbox}{\ieeealgbox}
   \begin{minipage}{\dimexpr\columnwidth-2\fboxsep-2\fboxrule}
   \begin{algorithmic}}
  {\end{algorithmic}
   \end{minipage}
   \end{lrbox}\noindent\fbox{\usebox{\ieeealgbox}}}
\lstset{ %
language=Java,                % choose the language of the code
%basicstyle=\scriptsize,       % the size of the fonts that are used for the code
%basicstyle=\sffamily,
basicstyle={\footnotesize \sffamily},
%numbers=left,                   % where to put the line-numbers
%numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
%stepnumber=1,                   % the step between two line-numbers. If it's 1 each line
                                % will be numbered
%numbersep=2pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=none,                    % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=none,                % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                % also try caption instead of title
escapeinside={\%*}{*)},         % if you want to add a comment within your code
%morekeywords={Definition, Theorem, Fixpoint}            % if you want to add more keywords to the set
}
\begin{document}
\title{A More Consistent Understanding of Consistency}
%\subtitle{Regular Submission}
%\numberofauthors{3} %  in this sample file, there are a *total*
%% of EIGHT authors. SIX appear on the 'first-page' (for formatting
%% reasons) and the remaining two appear in the \additionalauthors section.
%%
%\author{Subhajit Sidhanta}
%\authornote{The corresponding author %\\
%%\textbf{Email: ssidhanta@gsd.inesc-id.pt}\\
%%\textbf{Address: INESC-ID, R. Alves Redol 9, 1000-029 Lisboa}
% }
%%\orcid{1234-5678-9012-3456}
%\email{ssidhanta@gsd.inesc-id.pt}
%\affiliation{%
%  \institution{INESC-ID}
%%  \department{School of Engineering}
%%  \city{Charlottesville}
%%  \state{VA}
%%  \postcode{22903}
%  \country{Portugal}
%}
%\author{Ricardo J. Dias}
%\email{rjfd.di@gmail.com}
%\affiliation{%
%  \institution{NOVA LINCS, Universidade NOVA de Lisboa \& SUSE Linux GmbH}
%%  \city{Prague}
%%  \country{Czech Republic}}
%%\author{Tian He}
%%\affiliation{%
%%  \institution{University of Minnesota}
%  \country{Portugal}}
%\author{Rodrigo Rodrigues}
%\email{rodrigo@gsd.inesc-id.pt}
%\affiliation{%
%  \institution{INESC-ID/IST (U.\ Lisboa)}
%%  \city{Charlottesville}
%%  \state{VA}
%%  \postcode{22903}
%  \country{Portugal}
%}
%\textbf{\\A Consistent Understanding of Consistency} \\
%~\\
%\textbf{Regular Submission} \\ \\
%\textbf{Subhajit Sidhanta}, %\\
%%\authornote{The corresponding author.
%%\orcid{1234-5678-9012-3456}
%%
%  Affiliation: INESC-ID\\
%  Email: ssidhanta@gsd.inesc-id.pt\\
%Address: INESC-ID, R. Alves Redol 9, 1000-029 Lisboa\\
%Phone: +351 912413257\\ \\
%%  \department{School of Engineering}
%%  \city{Charlottesville}
%%  \state{VA}
%%  \postcode{22903}
%  %\country{Portugal}
%%}
%\textbf{Ricardo J. Dias}, %\\
%%\textbf{ricardo.dias@gmail.com}
%%\affiliation{%
%  Affiliation:  NOVA LINCS, Universidade NOVA de Lisboa \& SUSE Linux GmbH\\ \\
%%  \city{Prague}
%%  \country{Czech Republic}}
%%\author{Tian He}
%%\affiliation{%
%%  \institution{University of Minnesota}
%  %\country{Portugal}}
%\textbf{Rodrigo Rodrigues}, %\\
%%email{rodrigo@gsd.inesc-id.pt}
%%\textbf{%
% Affiliation: INESC-ID/IST (U.\ Lisboa) \\ \\%}\\
%  \city{Charlottesville}
%  \state{VA}
%  \postcode{22903}
 % \country{Portugal}
%}
%\maketitle
\author{\IEEEauthorblockN{Subhajit Sidhanta\IEEEauthorrefmark{1}, Ricardo J. Dias\IEEEauthorrefmark{2}, Rodrigo Rodrigues\IEEEauthorrefmark{3}}%\footnote{Supported by an Economic Development Assistantship Grant}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}IIT Jodhpur, India, Email: subhajit@iitj.ac.in}
\IEEEauthorblockA{\IEEEauthorrefmark{2}NOVA LINCS, Universidade NOVA de Lisboa \& SUSE Linux GmbH, Portugal, Email: rjfd.di@gmail.com}
\IEEEauthorblockA{\IEEEauthorrefmark{3}INESC-ID / T\'{e}cnico, ULisboa, Portugal, Email: rodrigo.rodrigues@inesc-id.pt}
\IEEEauthorblockA{IIT Jodhpur, India}\\
%Baton Rouge, LA 70803\\
%Email: ssidha1@tigers.lsu.edu}
%\and
%\IEEEauthorblockN{Ricardo J. Dias}
%\IEEEauthorblockA{NOVA LINCS, Universidade NOVA de Lisboa \& SUSE Linux GmbH, Portugal}%\\Electrical Engineering \\and Computer Science\\
%Louisiana State University\\
%3127 Patrick F. Taylor Hall\\
%Baton Rouge, LA 70803\\
%mail: supratik@csc.lsu.edu}
%\and
%\IEEEauthorblockN{Rodrigo Rodrigues}
%\IEEEauthorblockA{INESC-ID/IST (U.\ Lisboa), Portugal}%\\
%University of Waterloo\\
%200 University Avenue West\\
%Waterloo, Ontario, \\N2L 3G1, Canada\\
%Email: wgolab@uwaterloo.ca}
%}

%\author{Subhajit~Sidhanta, %~\IEEEmembership{Member,~IEEE,}
        %Ricardo~J.~Dias, %~\IEEEmembership{Fellow,~OSA,}
        %and~Rodrigo~Rodrigues %~\IEEEmembership{Fellow,~OSA,}
        %and~Saikat~Basu%~\IEEEmembership{Life~Fellow,~IEEE}% <-this % stops a space
%\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem S. Sidhanta is with IIT Jodhpur. This work was done when S. Sidhanta was with INESC-ID / IST, U. Lisboa, Portugal. %\protect\\
% note need leading \protect in front of \\ to get a newline within \thanks as
% \\ is fragile and will error, could use \hfil\break instead.
%E-mail: subhajit@iitj.ac.in
%\IEEEcompsocthanksitem
%R. J. Dias os with SUSE Linux.
%Email: rjfd.di@gmail.com
%\IEEEcompsocthanksitem R. Rodrigues is with INESC-ID / IST, U.\ Lisboa, Portugal.
%Email: rodrigo.miragaia.rodrigues@tecnico.ulisboa.pt
%\IEEEcompsocthanksitem W. Golab is with University of Waterloo, Canada.
% Email:  wgolab@uwaterloo.ca
 }% <-this % stops an unwanted space
%\thanks{Manuscript received July 28, 2018; revised October 28, 2018.}}


%\markboth{IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING,~Vol.~999, No.~999, December~2018}%
%{Sidhanta \MakeLowercase{\textit{et al.}}: A Consistent Understanding of Consistency}

% make the title area
\maketitle
%\thispagestyle{plain}
%\pagestyle{plain}
%\makeatletter
%\long\def\@IEEEtitleabstractindextextbox#1{\parbox{0.922\textwidth}{#1}}
%\makeatother

%\IEEEtitleabstractindextext{
\begin{abstract}
 We propose a specification language named \emph{ConSpec}, which enables the formalization of
 different consistency semantics that a storage system may provide, using a uniform syntax that is independent
 of the design and implementation of the target storage system. ConSpec addresses the recent profusion of consistency definitions,
 which are often accompanied by either informal definitions, or definitions that are tied to implementation-level details.
% Furthermore, even in the case of consistency models that have a precise definition associated with them,
%  Prior to ConSpec, definitions of
%  consistency models were tightly coupled with the specific design and implementation of the target storage system.
%  Each new storage system would redefine a consistency model in terms of its design and implementation. T
%   the absence of a uniform notation for describing different models
%   makes it difficult to compare different proposals.
%  Existing
%  definitions of consistency models and isolation levels either use textual descriptions or graphical representation of
%  proscribed anomalies and allowed dependencies between operations, making
%   automated verification even more difficult. To the best of our knowledge, this is the first work that expresses both
%   consistency and isolation levels in terms of ConSpec, a language that
 To enable a simple and uniform description of various existing proposals, ConSpec builds on recent proposals that view weak consistency
definitions as partial orderings between operations forming a visibility graph, which reduces the consistency definitions to a set of
restrictions on those partial orders, described using Linear Temporal Logic (LTL). We use ConSpec to revisit several existing models in light
of a common way to define and compare them. Furthermore, the use
of LTL enabled us to leverage existing automatic checkers to build a tool for validating whether a given trace of the execution of a system meets
a certain consistency semantics.
Finally, using our generic definitions and the insights from analyzing different models, we generalized the CAP
theorem, whose original formulation only considered linearizability, to precisely define the class of consistency definitions that can and cannot be implemented in a highly-available, partition-tolerant way. The evaluation of our consistency checker shows that it is able to verify the correctness of long traces in a reasonable time.

%We present SpecCheck, an  automated verification tool that is used %leverages of static analysis techniques
  %to  verify whether a storage system satisfies a consistency model or isolation level, specified using ConSpec.
  %Using the following approach, specifications derived using ConSpec can be used to subsequently  verify whether a given storage system satisfies a given consistency model or isolation level.
 %SpecCheck accepts as input: 1) a ConSpec expression corresponding to a consistency model or isolation level that a
% target storage system claims to provide, and 2) a trace collected by executing a client application on the target storage system.
  %For the simplified case, we consider that the target system can only performs simple read and write operations.
%The target system can work under any possible consistency model that can be defined with respect to storage operations that can be modelled using simple read and write operations.
  %Client applications, transactions, or client sessions executing on the target system can comprise a sequence of storage operations, optionally enclosed within
%  the application scope.
 %For transactional storage systems, we consider only committed transactions; analyzing uncommitted transactions is beyond the scope of this paper.
\end{abstract}

%\begin{IEEEkeywords}
%consistency semantics, concurrency, storage,  program specification, program verification
%\end{IEEEkeywords}}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords
\maketitle


%\IEEEdisplaynontitleabstractindextext

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



%\IEEEraisesectionheading{
	\section{Introduction}\label{sec:intro}%}
%\section{Introduction}\label{sec:intro}

   \IEEEPARstart{T}{he} development of Internet-based applications and services requires application developers to take into account the semantics of the
%consistency \cite{Burckhardt:2014:PEC:2693641.2693642} and isolation level \cite{DBLP:conf/icde/AdyaLO00} provided by the
underlying storage system, to ensure correctness and acceptable performance.
 In fact, there is evidence that the lack of a good comprehension of these
semantics can lead programmers to unintentionally break the application semantics \cite{Bailis:2015:FCC:2723372.2737784}.
However, the task of understanding and comparing the semantics provided by storage systems, normally encapsulated in a consistency definition, is made difficult by several factors. First, the current set of possible consistency models is not only large but also expanding, as new storage systems often coin new terms for the consistency semantics that they offer \cite{Cooper:2008:PYH:1454159.1454167, Lloyd:2011:DSE:2043556.2043593, Lakshman:2010:CDS:1773912.1773922}.
% http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/dml/dml_config_consistency_c.html
Second, existing consistency semantics have definitions that are often imprecise and/or are tied to implementation specifics (such as versioning \cite{DBLP:conf/icde/AdyaLO00} or the existence of replicas at different sites \cite{Li:2012:MGS:2387880.2387906}).
%% , and not generic enough to be used in the context of a different (newer) storage system.
%%       It is important for consistency and isolation definitions to be implementation-independent, because a particular
%%       storage system implementation may not be suitable for different application domains. A relational storage system, like MySQL
%%       or Oracle, may be unsuitable for an application that operates in the scale of millions of concurrent executions,
%%       serving clients that are geographically distributed across different continents. In the latter case, a
%%       geo-distributed storage system like Cassandra may prove to be more be more efficient, producing lower latency, while
%%       compromising on serializability and strict isolation.  Hence, research papers and projects often end up  re-defining
%%        existing consistency models using disparate semantics and notations.
%%        \par Disparities among multiple definitions of the
%%       same model may result in ambiguities and confusion, which in turn, may result in incorrect design and implementations
%%         of applications built upon such definitions.
%%  Also, with such ambiguous definitions, it is difficult to compare consistency models of different storage systems, and choose
%%  a suitable storage system for a given application. Though Adya et al. claim that their definitions are implementation agnostic,
%%  they assume that the system is able to track version histories of each object; hence, we argue that these definitions
%%  will not be applicable to systems that do not persist version histories.
%%  Further, they use graphical representation of proscribed
%%    anomalies and allowed dependencies between operations; making it difficult to automatically verify such definitions.
%%    Existing definitions of consistency models  used either textual descriptions or graphical representations, making
%%    automated verification even more difficult. The goal of this paper is to specify consistency and isolation definitions
%%     using a uniform syntax in an implementation agnostic manner.
%%    \par Traditionally, specifications of consistency models or isolation levels are comprised of the following components:
%%    \emph{rules} that restrict the order in which results of operations can be observed, specified using axiomatic expressions,
%%    \emph{anomalies} precluded by the models, expressed using directed serialization graphs (DSGs), where vertices in a DSG
%%    represent operations, and edges represent the dependency relations among operations corresponding to the connecting
%%    vertices.
%%  The rules in state-of-the-art consistency and isolation definitions specify the valid order of execution among operations
%%   in terms of dependency relations, like write-write (ww), write-read (wr) dependency, etc. Such dependency relations
%%   belong to two categories - explicit dependencies, like ww dependency, and implicit dependencies, like read-write (rw)
%%   dependency, that are expressed in terms of one or more explicit dependencies.
%%  These dependency relations are not apparent from the statement of consistency and isolation definition, especially
%%  implicit dependencies, since those are further described in terms of explicit dependencies.
%% \par However, a given consistency or isolation level specifies a valid relative temporal order among operations. Such
%% temporal order can be directly expressed using LTL \cite{Lamport:1994:TLA:177492.177726} operators, like next, eventually, etc.
%% We argue that consistency and isolation levels can be readily expressed in term of LTL-like expressions
%%  that specify required temporal order among operations according to given consistency or isolation level.
 Third, even when precise definitions exist, it is difficult to compare different definitions, since they use different formalisms and community-specific terms or notations.

To address these issues, we propose a specification language called
\emph{ConSpec} that  we use to develop a generic definition for consistency models, which can
be easily parameterized to obtain precise definitions of a variety of
semantics. ConSpec builds on the observations made by several proposals
that it is possible to define weak consistency semantics in terms of
partial orders over the set of operations that were executed in the
system, which comprise a visibility graph
\cite{Li:2012:MGS:2387880.2387906, Gotsman:2016:CIS:2837614.2837625, cheng-papoc}. This allows us to reduce
the configurable part of the consistency definition to a set of restrictions,
written in Linear Temporal Logic (LTL) \cite{4567924}, on top of a generic partial order.
%% . LTL is a natural choice for specifying relative
%%  temporal ordering among operations in different consistency and isolation definitions. ConSpec uses LTL-like semantics to
Intuitively, this allows us to express a set of rules that specify the allowed order in which results of operations can be visible to a client application.
%  The ConSpec expressions specify the allowed temporal order (i.e., ``happens before" order \cite{Bailis:2013:BCC:2463676.2465279}) in which operations within a client application return results, and restricts the manner in which these results are visible to subsequent operations in the client application.


With this framework in place, we were able to express several existing
consistency definitions in a common language, and compare them in a precise
way. Further, we show the equivalence between our definitions and  their original form. %, thereby we present equivalent proofs. %defining a hierarchy of consistency models. %In addition, our
%variants of the definitions for these
%consistency models were linked to their original definitions by proving their
%equivalence.

Based on the same framework, we were also able to revisit the CAP theorem \cite{brew:cap, Gilbert:2002:BCF:564585.564601} and restate it in more generic terms. The original proof for the theorem used linearizability as synonym for the strong consistency captured by the ``C'' property. In our new formulation of this theorem, we are able to define necessary and sufficient conditions for a given consistency model to be bound by the impossibility of being implemented in a highly available, partition-tolerant way.

Finally, we built a tool called ConSpecCheck, which is available online, to %check whether a given trace violates a certain consistency model. 
 %The tool can 
determine whether a client trace from a storage system satisfies a certain consistency model.
 This tool can be used with existing testing framewoks, which are used for generating test cases, to attempt to expose violations of the specified consistency semantics. For example, by coupling our system with a set of outputs of different thread interleavings that are generated by a concurrency testing framework like Chess~\cite{Musuvathi:2008:SCT:1390841.1390851}, we are able to systematically attempt to uncover concurrency bugs that lead to subtle consistency violations.
A noteworthy point is that the ConSpec checker highlights the advantage of our LTL-based specifications: even though we are not fully exploiting the expressiveness of LTL, it nonetheless allowed us to seamlessly leverage existing model checking systems in our design.


% With this tool,  we can perform runtime verification of a storage system on the basis of execution traces generated by running client  appl%ications on top of the storage system. The tool checks whether a particular execution trace violates a given consistency model. For example, to  test if a given social networking application like Facebook satisfies causal conssistency, we generate execution traces comprising blog posts and comments on those blogs from concurrent clients.  The consistency for that system is verified    by running the tool on execution traces collected from all concurrent client applications.    
%  This highlights the usefulness of using LTL in ConSpec. In particular, even though we make a simple use of LTL that is short of its full expressiveness, it nonetheless allowed us to reuse existing automatic checkers and adapt them to our constructs in a direct way.
 We built the ConSpec checker and evaluated it using traces produced from workloads from the YCSB and TPC-C benchmarks. Our experimental evaluation shows that the tool is able to validate traces in a reasonable amount of time, and that the time to check a trace against ConSpec is comparable to the time with prior definitions.
%Alternatively, the consistency definitions could as well be expressed using plain relations but in that case one would have to rely on hand-crafted verification tools instead of using an available automated verification software.


The remainder of this paper is organized as follows. Section \ref{sec:related} discusses related work. Section  \ref{sec:definitions} presents the system model and terminology.  Section \ref{sec:syntax} presents a general format of specifications based on ConSpec. Section \ref{sec:list} lists the specifications of several consistency models, expressed using ConSpec. % In each subsection where we define a given consistency model in Section  \ref{sec:list}, we also  analyze example session traces that meet and violate the respective models.  %Section  \ref{sec:examples} analyzes example session traces to determine which consistency levels they meet, as defined by their  ConSpec specifications. %comprises a detailed analysis of the process of verification of ConSpec specifications with respect to sample session traces that cause violations of the specifications.
 Section \ref{sec:cap} presents our restatement of the CAP theorem, % and CAC theorems,
  and proves its correctness.  Section \ref{sec:capanalyze} discusses how this extension of the CAP theorem can be used to categorize existing models. %analyzes the previously mentioned consistency models in terms of the restated CAP theorem.
 In Section \ref{sec:impl}, we present the design of our tool for checking if a trace obeys a certain consistency model. In Section  \ref{sec:eval}, we evaluate its performance. 
 %We conclude in Section \ref{sec:conc} with future work directions.  %; because of lack of space, we include some of the proofs in the Appendix.
 % Section \ref{sec:ser} in the appendix comprises ConSpec expressions for the various serialization definitions used in the original consistency definitions.  Section \ref{sec:equiv} illustrates the equivalence between the syntax of ConSpec expressions and the syntax of state-of-the-art  consistency definitions.  Section \ref{sec:hierarchy} presents a hierarchical organizaton of the lattice of consistency models. %Section \ref{sec:complex} in the appendix comprises a comparison of the complexity of verification using ConSpec with the state-of-the-art verification techniques.
  In a separate document available online~\cite{ConspecExtended2018}, we show the equivalence of each of the listed ConSpec specifications with respect to their original definitions.
 

 %%  \par We argue that specifications expressed in terms of ConSpec are much easier to reason about than the state-of-the-art definitions, which require an understanding
 %% of the various dependency relationships; the implicit dependencies can be particularly complex to express and
 %% comprehend.

%The main contributions of this paper are as follows.
   %\section{Contributions}
    %In this paper, we propose a generalized semantics for formally defining consistency models and isolation levels,
%   which can be used to unify definitions of all possible consistency models and isolation levels under a single
%   formalization framework.
   % We present the detailed derivation
% of ConSpec specifications for consistency models and isolation levels that exist in the literature of database systems.
%  ConSpec specifications are implementation agnostic; a target storage system can be anything ---
%  a stand-alone relational database, a transactional database, or a distributed ``NOSQL'' storage system.
  %Apart from eliminating the risks with ambiguous definitions, this approach further allows
% us to build a automated framework for verifying whether a system satisfies the definition of a given consistency model or i
% isolation level.
 %% \begin{itemize}
 %% \item
 %% It presents the syntax and design of ConSpec, a language for formally specifying the consistency
 %% models and isolation levels that a storage system supports.
 %% ConSpec specifications are expressed in terms of Linear Temporal Logic (LTL), thus enabling us to leverage
 %%   existing body of Satisfiability solvers and Theorem provers to build automated verifiers.
 %%   \item It restates the CAP theorem, which originally used to imply linearizability when talking about consistency, taking into account the different possible consistency models. We show how the extended CAP statement segregates the lattice of consistency models into \emph{CAP-strong} and \emph{CAP-weak} consistency models, i.e., into consistency models which can be implemented while simultaneously providing high availability and partition tolerance, and which can not be implemented in the above manner, respectively.
%%   \end{itemize}
    %Definitions specified with ConSpec are simpler, easier to
% understand, verifiable, thus making lives of application developers and database developers easier.
  % \item It also presents SpecCheck, a prototype  automated verification tool that is used %leverages of static analysis techniques
%  to  verify whether a storage system satisfies a consistency model or isolation level, specified using ConSpec.
%  %Using the following approach, specifications derived using ConSpec can be used to subsequently  verify whether a given storage system satisfies a given consistency model or isolation level.
% SpecCheck accepts as input: 1) a ConSpec expression corresponding to a consistency model or isolation level that a
% target storage system claims to provide, and 2) a trace collected by executing a client application on the target storage system.
% We argue that the complexity of the verification of execution histories using SpecCheck beats the state-of-the-art.
% Traditional \emph{server trace analysis} approaches perform trace analysis on server level execution traces, i.e.,
% execution traces collected from the server nodes comprising the underlying storage system. As such, they are dependent on the
% implementation and configuration
%  of a specific storage system instance, such as replication factor, partitioning scheme, etc.% They analyze server traces to
%%  check if any portion of the server traces matches the specified anomalies that a given consistency model or isolation
%%  level proscribes; process terminates with a failure once a match is found against any of the proscribed anomalies.
%  Contrastingly, SpecCheck analyzes traces collected at the end of the client application, making it completely implementation agnostic.
%%\section{Contributions}
%%   We present a generalised specification language \emph{ConSpec}, that enables formalization of any possible consistency model or isolation level that a storage system may follow, irrespective of the design and implementation of the target storage system. Using the following approach, ConSpec enables application of static analysis techniques to verify whether a storage system satisfies a consistency model or isolation level, specified using the formal semantics of ConSpec.
%%  %Using the following approach, specifications derived using ConSpec can be used to subsequently  verify whether a given storage system satisfies a given consistency model or isolation level.
%%  We can execute client applications on a target storage system, and analyze results returned by operations invoked from a particular application scope. We compare these results with the results expected according to specifications of the consistency model or isolation level for the underlying storage system, specified using ConSpec. The models specified using ConSpec are implementation agnostic; a target storage system can be anything --- a stand-alone relational database, a transactional database, or a distributed ``NOSQL'' storage system. %For the simplified case, we consider that the target system can only performs simple read and write operations.
%%%The target system can work under any possible consistency model that can be defined with respect to storage operations that can be modelled using simple read and write operations.
%%  %Client applications, transactions, or client sessions executing on the target system can comprise a sequence of storage operations, optionally enclosed within
%%%  the application scope.
% For transactional storage systems, we consider only committed transactions; analyzing uncommitted transactions is beyond the scope of this paper.
%\end{itemize}
%We specify any given consistency model or isolation level with a dependency graph, where vertices represent operations and edges represent dependency relations. We derive a dependency graph for the given consistency model or isolation level, depicting the possible dependency relations between storage operations.
%\begin{figure}[!htbp]
%        \centering
%        \includegraphics[width=3in,height=2in]
%                    {system.eps}
%        \caption{System Model}
%        \label{fig:System}
%\end{figure}

 \section{Related Work} \label{sec:related}
 Consistency definitions restrict the set of valid traces for the execution of a given system. % with a storage-like interface.
 In broad terms, the gold standard of consistency definitions are ``strong'' consistency levels, which have the characteristic of approximating the behavior that is obtained when interacting with a system whose implementation has a  centralized server that executes operations one at a time. There are several examples of such consistency models~\cite{Attiya:1994:SCV:176575.176576, Herlihy:1990:LCC:78969.78972, Lamport:1979:MMC:1311099.1311750, opac-b1024856, Mizuno1995, Raynal1995}.
% which have been implemented by modern storage systems that trade off linearizability in favour of higher availability and lower latency. %, most of which include precise definitions of their intended semantics.

Strong consistency is often forfeited by the algorithms that implement storage systems, in order to achieve better performance (e.g., when processors cache possibly stale data in a multiprocessor) and/or better availability (e.g., when multiple replicas of the data exist and operations proceed while contacting only a subset of them)~\cite{Lakshman:2010:CDS:1773912.1773922, Sumbaly_servinglarge-scale, Meiklejohn:2013:RPD:2505305.2505309, Plugge:2010:DGM:1869938, Schutt:2008:SRT:1411273.1411280, DeCandia:2007:DAH:1323293.1294281}.

Often, the definitions of these consistency models are vague and/or underspecified. For instance, the strong consistency option of Cassandra, a widely used NoSQL storage system, is stated in terms of the size of the quorums that are used for read and write operations, leaving unspecified what happens as the system reconfigures and the set of replicas of a data item changes~\cite{cassandra-consistency}.
%http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/dml/dml_config_consistency_c.html
Even when the specification is more precise, it may suffer from being tied to implementation details that may not be widely applicable. For instance, some definitions assume the existence of a centralized server that keeps monotonically increasing version number associated with the data~\cite{DBLP:conf/icde/AdyaLO00}; others explicitly define consistency in terms of the state maintained by different replicas of the data~\cite{Li:2012:MGS:2387880.2387906}; and other models, namely the well known set of session guarantees that strengthen the consistency offered by eventually consistent systems, are defined operationally in terms of the replicas that are accessed and the operations that these replica process and the respective order in which they are processed~\cite{bayou}.

In \cite{Szekeres:2018:MCM:3194261.3194268}, the underlying system is represented as a collection of one or more state machines, where each state machine models operations performed in parallel or on different replicas. Consistency models impose constraints on the total order of operations performed by a given state machine.
 % With the goal of obtaining more precise and less operational definitions,
Chockler et al.~\cite{Chockler2000} defined all session guarantees (and some other consistency levels) using first-order logic formulas that constrain a set of equivalent linear sequences comprising all operations that are part of a given execution.
 %; these formulas express preconditions of these consistency models in terms of constraints on equivalent \emph{legal serializations} for a given valid execution. In these definitions, a \emph{serialization} is a linear sequence comprising all operations that are part of a given execution, and then a serialization is said to be \emph{legal} if every read operation returns the value written by the latest write operation preceding it in the serialization.
%In more detail, the authors define each consistency model as an axiom of the form $P \rightarrow Q$, where $P$ is a  precondition that specifies a precedence order among pairs of operations in a local execution, and $Q$ is a postcondition that specifies a precedence order among the same operations in an equivalent legal serialization.  %'s  %consistency definitions  %specify existential quantification on precedence relations among operations in an equivalent legal serialization.
Similarly, Burckhardt et al.~\cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642} present the definitions of a broad set of consistency models,
%using properties like visibility and the happens-before order as building blocks. In particular, they formally represent a \emph{concrete  execution}, comprising a sequence of operations, as an \emph{abstract execution}, which is a tuple consisting of parameters such as the identifiers of replicas on which operations in a given execution are performed, or replica order, which is a total order on operations performed by each replica.  %\cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642}
 %This allows them to
by specifying consistency axioms in the form of constraints on \emph{visibility}  and \emph{arbitration order}  relations, which must be satisfied by a valid abstract execution for a given consistency model.
%Some aspects of these definitions make assumptions about the existence of replicas and the way in which the operations are executed at each replica.  The choice of a visibility relation is also dependent on the corresponding \emph{visibility witness}  \cite{DBLP:conf/popl/BurckhardtGYZ14},  which is a function of the message delivery protocol  of the underlying storage system. Furthermore, consistency axioms in  \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642}  are a function of a given transport layer specification, which, in turn, is a predicate on a given execution, and  specifies assumptions about the message delivery mechanism of the underlying storage system. In some cases, they are also a function of the data type specification of the system; specifically,  the choice of visibility witness varies with respect to the class of data type. %A transport layer specification is a parameter of the model which restricts message delivery in the underlying storage system. A data type specification is dependent on the specific target data type in question; specification of a counter data type is different from a register data type.
% As such, the consistency definitions in \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642}  are inherently tied to several server-level implementation parameters, like replica settings or the underlying message delivery protocol.  %Further compared to these definitions ConSpec definitions are much simpler and concise.
%  Unlike ConSpec, the framework described in  \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642} is able to define consistency models that mandate specific conflict resolution policies among concurrent operations in terms of arbitration relations which establishes total order on operations using timestamps collected from global clocks.  While the above definitions were based on restrictions on abstract executions,
Cerone et al. \cite{DBLP:conf/concur/CeroneGY17} developed a set of algebraic definitions of consistency for transactional systems, which are based on relations similar to those proposed by Burckhardt et al.\ to specify conflict resolution policies for ordering concurrent operations.
%While this makes the framework more expressive than ConSpec, it also makes the consistency axioms in  \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642, DBLP:conf/concur/CeroneGY17} more complex.
 Weber et al. \cite{Weber2017} present EPTL, an extension of LTL,  which they employ to specify correctness properties in weakly consistent systems. EPTL is used to capture  details of the system internals, such as techniques applied in the resolution of conflict among concurrent operations. Wickerson et al.\ developed a framework, based on the Alloy language, for modeling consistency in shared memory systems and performing verification of a system against a given consistency model  \cite{Wickerson:2017:ACM:3009837.3009838}.
 %However, Alloy models complex implementation level details of a memory system, such as the complier optimizations.
% With ConSpec, we trade off expressive ability for  simpler definitions. Further, in comparison to partial order relations among operations in the consistency definitions of ConSpec, the visibility relations used in the above consistency axioms are more restrictive  as they constrain only operations on a common object.


Compared to these prior approaches, ConSpec advances the state of the art by providing a generic way to describe consistency specifications, where each consistency level corresponds to a different parameterization of our generic definition.  Using this generic framework we generalize the CAP theorem as proved by Gilbert and Lynch~\cite{Gilbert:2002:BCF:564585.564601}. Another important distinguishing feature of our work is that we provide a software artifact to check whether traces meet a certain consistency level, leveraging our LTL definitions. % Finally, we obtain simple and implementation-agnostic definitions, sometimes at the expense of removing from the framework aspects that are orthogonal to the fundamental characteristics of a consistency definitions, such as specifying how to arbitrate conflicts in case of concurrent operations not seeing each other's effects.

Our definitions are also related to recent proposals for models that are weakly consistent by default but distinguish a subset of the operations, and enforce visibility restrictions only among those~\cite{Li:2012:MGS:2387880.2387906, Gotsman:2016:CIS:2837614.2837625, cheng-papoc}. In contrast to these proposals, our goal is not to propose a new consistency model, but to gain a deeper understanding of existing ones.

Other authors have explored the CAP theorem beyond its original formulation and first proof.
Mahajan et al.~\cite{mahajan11cacTR} defined Real Time Causal Consistency, a stronger variant of causal consistency, and proved that it is the strongest consistency model that can be provided in a highly available and eventually consistent implementation.
Attiya et al.~\cite{Attiya:2015:LHE:2767386.2767419}  provided a formal specification of systems that implement causal consistency, and proved that Observable Causal Consistency, a stronger variant of causal consistency, is the strongest consistency model that can be provided in a highly available, partition tolerant manner. Their definitions are stated in terms of some implementation-level concepts, namely a set of replicas connected by a network. They assume a replicated datastore, and define a consistency model in terms of events (operations) observed at each individual replica. %, i.e., consistency is defined in terms of visibility of each operation at different replicas.  On the other hand
 In contrast, the ConSpec definitions express consistency models in terms of constraints on the ordering of the operations observed from the viewpoint of the client, and the underlying storage system is a black box. This allows for an implementation-agnostic generalization of the CAP theorem.
%Though the effects of operations at the individual replicas are not considered at all in any of the definitions,  the definitions are applicable to replicated systems, stand-alone databases, as well as shared memory systems without any change. Attiya et al. proves that Observable Causal Consistency (OCC), which is a weaker invariant of Causal consistency, is the strongest consistency model that can be satisfied by an eventual consistent datastore. According to Definitions 9 and 10 in  \cite{Attiya:2015:LHE:2767386.2767419}, OCC specifies that the "observability" condition must be respected in the same order in all replicas for an abstract execution that complies with OCC.  Attiya et al. expresses their impossibility condition based on the per-replica order of messages for a valid abstract execution for a eventually consistent datastore that provide invisible reads and op-driven messages.
%Contrastingly,  we generalize CAP by defining necessary and sufficient conditions on the order of operations observed at the client-end (i.e., from sessions) for consistency models to be implemented in an available and partition-tolerant way.  These conditions are leveraged to precisely characterize the CAP line in a hierarchy of consistency models.

 There have been several research papers  on the verification of the consistency of  protocol implementations \cite{Katz:1985:ICC:327070.327237, Pong:1993:VCC:165231.165233}. Consistency of a protocol is verified by checking all possible execution traces that can be generated from the execution of an implementation of that protocol \cite{Condon2003}. In contrast, we are not tied to a particular implementation nor a particular consistency  definition, but instead we attempt to provide tools that are generic both in terms of the consistency semantics and the implementation that generates that traces. 
% On the other hand, we are interested in verifying whether a particular execution trace satisfies a given consistency model; a particular execution trace is verified  against a particular consistency model by running standard verification tools  over that execution trace. 

  \section{Basic Definitions} \label{sec:definitions}


 % We do not assume anything regarding the internal organisation of the storage system. As such, focusing on the interface of the storage system,

We assume a set of client processes that interface the storage system by invoking operations. An operation is a pair comprising an invocation and the respective response. We denote the set of possible operations on the storage system as $\mathcal{O}$, and therefore $o \in \mathcal{O} = \langle \textit{invocation},\textit{response}\rangle$. Invocations (resp.\ responses) belong to a generic set of possible invocations $\mathcal{I}$ (resp.\ responses $\mathcal{R}$).

A \emph{session trace} $\mathit{st}$ is a sequence of operations executed by the same client, ordered by the time when they were invoked. In this paper we assume that clients are well-formed, i.e., a client only invokes an operation after the preceding operation has returned its response value. As such, session traces can be modelled as sequences of elements of $\mathcal{O}$.

% We denote the set of all possible session traces as $\mathcal{S}_t$.
We define a session invocation trace $\mathit{s}_{it}$ as the sequence of invocations that are obtained from transforming each element in a session trace using the projection operator to obtain only the invocations. We define a session invocation trace to be compatible with a session trace if the projection of the invocations in the session trace matches the session invocation trace (denoted $st\bowtie s_{it}$).

The \emph{global session trace} $\mathcal{S}_t$ (resp.\ global session invocation trace $\mathcal{S}_{it}$) denotes the set of all
   session traces (resp.\ session invocation traces) in a given execution of the system.

A very large class of consistency definitions (namely those describing the behavior of loads and stores on computer hardware, and get and put operations on key-value stores) assume that these operations are partitioned into two classes, namely read operations that do not affect the result of subsequent operations and write operations that do. Given that many of the consistency levels we describe require this interface, we  also assume that the interface consists of these two operations. Note, however, that this does not lose generality, since other models also distinguish between commands that change versus those that only read the state of the system. For example, databases make a similar distinction between queries and updates, and the state machine replication model distinguishes between read-only and read-write requests.

Similarly, many consistency definitions reason about an interface that exposes the existence of multiple objects (e.g., different memory addresses seen by a CPU or different keys in a key-value store). As such, we assume the interface allows the programmer to specify an object $x$ associated with reads and writes. This does not lose generality since we can eliminate this by restricting the system to a single object.

%s that are associated with each operation, where we define object $x_j$ to comprise: 1) a unique name, given by the string $x_j$, and 2) a value $v_j$, which can be of any datatype, such as float, double, string, etc. %(A special case of this is a system with a single object whose datatype can be as complex as an entire file system or database, thus encompassing other models such as the state machine replication model~\cite{schneider:smr:tutorial}.) {\bf [RR: Note that the existence of a value does not match the SMR/DB model, since the operations do not return/overwrite the entire state of the state machine/database. How to make this analogy hold?]}

\newtheorem{definition}{Definition}
%Our execution


% comprising the results of a local execution, i.e., results of operations invoked from  a client application, observed from  the client machine. A given client application is executed on a target storage system. In the course of execution of the client application, we collect session traces over a pre-defined sliding window over time from the client machine (i.e., the machine that hosts the client application). %We perform \emph{session trace analysis} on the above session traces to determine whether the target system satisfies a given consistency model or an isolation level.
% Let $j$ be the index of the read operation in the execution sequence of  $\mathit{Cl}$ observed in a session trace.

We denote the set of all objects in a storage system as $\mathcal{X}$. In our notation, we denote an invocation of a write operation that writes a value $v$ to an object $x$, as $w(x,v)$ (with an empty response). Conversely, a read operation on object $x$ that outputs a value $v'$ is denoted $r(x){v'}$.
In our LTL formulas, variables denote operations that occur in a session trace.
Instead of defining predicates over these variables that restrict the type of operation or the corresponding parameters (e.g., a predicate {\tt isWrite(A)} to mean that variable A is a write operation), we use a shorthand notation $W^{x}_{st}$ to denote a variable that refers to a write operation to object $x$ that is part of session trace $st$. In turn, the notation $R^{x}_{st}$ denotes a read operation to object $x$ in session trace $st$. We also use the variable representation $O^{x}_{st}$ to denote a read or write operation over object $x$ that occurs in session trace $st$.

We use LTL to describe precedence relations among operations in the same session trace. 
\added[id=1]{We use LTL operators such as the implies operator $\Rightarrow$ as qualifiers in our consistency formulas. The LTL operator globally $\square$ is used to express a proposition which holds accross the entirety of a given path; in our case a session trace is the given  path. The LTL operator eventually $\lozenge$ expresses the statement that a proposition holds subsequently somewhere in a given path (i.e., given session trace). } For instance the LTL formula

$$ \quad \square \left( R_\mathit{st}^x \rightarrow \lozenge W_\mathit{st}^{x'} \right) $$
 
\noindent is satisfied by any session trace $st$ where, if a read operation on object $x$ is issued, then it must be eventually followed by a write operation on object $x'$.

 Finally, we assume the system has a sequential specification, %which is a correctness condition,
 corresponding to the output of the operations in a centralized system that executes operations in a sequence, one at a time. In the case of the sequential specification of a system whose interface is comprised of read and write operations, the read operation to object $x$ must output the value associated with the most recent write operation to the same object $x$. For other types of interfaces (e.g., in state machine replication), that specification %may change, and in some cases
 is specific to the service interface. % (e.g., the state machine being replicated).
This assumption implies that we cannot define specifications where concurrent operations lead to a result that would not be possible in a sequential execution. This decision has the advantage of simplifying our definitions.

While our consistency definitions are completely agnostic of implementation-level concepts, for our proofs regarding the characteristics of the implementation of a certain consistency level (namely in our restatement of the CAP theorem), we need to consider the protocols that implement the consistency level. As such, in that part of the paper only, we model each process as a deterministic state machine, whose transitions can be triggered either by an external input (i.e., an operation invocation) or by receiving a message from the network, and where the transition can trigger sending messages and/or issuing outputs (i.e., an operation response). Processes are connected by unreliable asynchronous communication channels. Note that the assumptions in this paragraph are only used in Section~\ref{sec:capanalyze}, and they are inevitable in this case since the generalized CAP proof concerns implementation characteristics. Therefore, this does not contradict our claim that ConSpec is implementation-agnostic.	


%\newtheorem{definition}{Definition}
  %% A \emph{serialization} is a linear sequence comprising all operations comprising a global  execution on a
  %% storage system.
  %% A serialization is said to be \emph{legal} if every read operation returns the value written by the latest write
  %%  operation preceding it in the serialization.  Following Chockler et al. \cite{Chockler2000}, ConSpec defines
  %%  consistency levels in terms of valid legal serialization orders equivalent to a given execution. Similar to Chockler et al., ConSpec defines different consistency models in terms of different specialized forms of legal serialization, which have been defined below. ConSpec defines those consistency models, which can not be expressed in terms of legal serialization, in terms of constraints on the global execution order,  represented by the global session trace $\mathcal{S}_t$.
  %%  Let the propositional variable ${\mathit{Op}^i}^{'}$ denote an execution of the
  %%  i\textquotesingle th operation comprised in the set $mathcal{O}$ of operations executed from a given client application in a session trace.
  %%   \newtheorem{definition}{Definition}
  %%    \begin{definition}(Legal Serialization)
  %%  We represent a global execution, comprising concurrent operations executed from multiple clients on a system, with a global session trace $\mathcal{S}_t$, which is a set of operations from all clien0ts. A legal serialization $\mathit{Ser}$ of a given global execution is represented by a sequence of propositional variables ${\mathit{Op}^i}^{'}$, each variable ${\mathit{Op}^i}$ denoting an execution of an
  %%   operation ${\mathit{o}}^i$, comprised in the set of operations ${\mathcal{O}_{St}}_{St}$ executed by a given client, observed a global session trace $\mathcal{S}_t$, as follows.
  %%  $\mathit{Ser}$ = $\Set{ {\mathit{Op}^i}^{'} } {{\mathit{Op}^i}^{'} \in \mathit{st}}, $ such that
  %%  $\forall {\mathit{o}^i}^{'}, {\mathit{o}^j}^{'} \in {\mathcal{O}_{St}} \\ \big( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'}  \wedge \exists \mathit{st} \in \mathcal{S}_t  \; \big( \big( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st}  \; \wedge \\
  %%  \not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \in \mathcal{S}_t  \right) \big)
  %% \Rightarrow \left( {v_j}^{'} = {v_i}^{'} \right) \big) \big)$.
  %%   \end{definition}\label{def:ser}
  %%  \begin{definition}(Serialization of a Client)
  %%  We  represent a local execution of a given client observed at a client machine, with a local session trace $\mathit{st} $, comprising results observed for operations executed by a given client application, comprised in the set of operations ${\mathcal{O}_{St}}_{St}$.  We formally define \emph{serialization of a client}, $S_c$, as the restriction of a legal serialization of a global execution
  %%   to  the operations invoked by a particular client application, which in turn,
  %%  corresponds to operations observed in a particular session trace $\mathit{st}$.
  %%   $S_c$ = $ \Set{ {\mathit{o}^i}^{'}, {\mathit{o}^j}^{'} \in {\mathcal{O}_{St}} \wedge {\mathit{Op}^i}^{'} } {{\mathit{Op}^i}^{'} \in \mathit{Ser} \wedge {\mathit{Op}^i}^{'} \in \mathit{st} } $.
  %%  \end{definition}\label{def:clientser}
  %%  \begin{definition}(Serialization of a Partial Execution)
  %%  The notation $S_p$ is used to denote a legal serialization of a partial execution comprising all    operations from the set of operations ${\mathcal{O}_{St}}_{St}$
  %%  performed by a given client application, represented by a local session trace $\mathit{st}$, and all write
  %% operations  executed from all other concurrent client applications, comprised in the global session trace $\mathcal{S}_t$. The above partial execution is denoted as $\sigma |i + w$ by Chockler et al. Thus, we formally denote $S_p$ as
  %%  \\ $S_p$ = $\Set{ {\mathit{Op}^i}^{'} } { \left( {\mathit{Op}^i}^{'} \in \mathit{st} \right) \vee \left(
  %% {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^i}^{'} \not\in \mathit{st} \right)}, $ such that
  %% $\forall {\mathit{o}^i}^{'}, {\mathit{o}^j}^{'} \in {\mathcal{O}_{St}} \big( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'}  \wedge \\ \exists \mathit{st} \in \mathcal{S}_t  \; \big( \big( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st}  \; \wedge \not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \\ \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \in \mathcal{S}_t  \right) \big)
  %% \Rightarrow \left( {v_j}^{'} = {v_i}^{'} \right) \big) \big)$.
  %% \end{definition}\label{def:parser}
  %% The above legal serialization does not comprise read operations from other clients, hence its a  serialization of a partial execution.

 \section{ConSpec}\label{sec:syntax}
In this section we present our generic ConSpec definition, which can be parameterized to obtain specifications for commonly used consistency models. % and
 % isolation levels. %Note that ConSpec focuses only on safety conditions. %Defining liveness conditions is left as future work.

ConSpec builds on recent proposals for consistency definitions that treat a subset of the operations in a given trace differently (e.g., operations labeled as being ``strongly consistent''), since they only enforce visibility among those specific operations~\cite{Li:2012:MGS:2387880.2387906, Gotsman:2016:CIS:2837614.2837625, cheng-papoc}. We can similarly see different consistency definitions as enforcing different visibility relationships only among a subset of the system operations, often depending on their types (e.g., reads versus writes).

As such, the generic definition of ConSpec requires the existence of a partial order that intuitively forms a ``visibility graph'', i.e., the output of each operation must reflect the effects of the operations that precede it according to that partial order. This allows us to see different consistency models as imposing different restrictive conditions on this precedence.
 Such a
  restrictive condition is then expressed as an LTL expression $E^s$.
%, which is  a conjunction of constraints, composed of conditions that restrict the precedence or
%  observed results for operations performed on the system. The generalized syntax of the specification $E^s$ for a given consistency model or an isolation
%  level is defined as follows.
%\section{Generalized Specification of Consistency Condition}
  %Generalizing from Equations \ref{form-1} and \ref{form-2}, we observe the following.
 \begin{definition}{Generalized form of ConSpec:}\label{def:form0}
Given a global session trace $\mathcal{S}_t$,
% representing a global execution of all concurrent clients on a given storage
%system,
we say  that $\mathcal{S}_t$ satisfies a consistency model $\mathcal{C}$
if there exists a partial order $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ over the set ${\mathcal{O}_{St}}$ comprising operations  present in all session traces in $\mathcal{S}_t$, i.e.,  ${\mathcal{O}_{St}} = \bigcup_{st \in St} \{ o \mid o \in st \},$
 such that 1) for every operation $\mathit{o}$ in  ${\mathcal{O}_{St}}$, %$\mathcal{S}_t$,
  its output is equal to the one obtained by executing the sequential specification of an  equivalent re-arrangement (i.e., permutation) %a linear extension of
 of the operations preceding $\mathit{o}$ in $\preccurlyeq$,
% the same irrespective of the
 %%among operations preceding it in $\preccurlyeq$, %$\exists {\mathit{Op}^i}^{'}, {\mathit{Op}^j}^{'} \in \mathcal{S}_t:
 %{\mathit{Op}^i}^{'} \preccurlyeq {\mathit{Op}^j}^{'}\; \Rightarrow \;{\mathit{Op}^i}^{'} R {\mathit{Op}^j}^{'}$, %\; \vee \; v_i \sim v_j$,{\mathcal{O}_{St}}, \preccurlyeq
 and 2) $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ obeys $E^S_C$, which is an LTL expression restricting $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$.
\end{definition}

%  The condition 1 for the Definition \ref{def:form0} follows directly from the definition of $\mathcal{S}_t$. Each element in
%  the set $\mathcal{S}_t$ represents the event that the result of execution of an operation is observed from a client.
%  Thus, there exists a temporal relation between at least two elements in $\mathcal{S}_t$, denoting the temporal order among
%   the operations, represented by a temporal operator $R$ (which may be the temporal operator eventually $F$, the
%   special-purpose next operator $X^o$, or a propositional relation between values returned by the operations). %Alternatively, there exists an equivalence relation $\sim$ between the results $v_i$ and $v_j$ observed by
%  operations $\mathit{o}^i$ and $\mathit{o}^j$, respectively, i.e., either $v_i = v_j$ or $v_i \not= v_j$.
% Many of the popular consistency models impose restrictions on a valid session order, which is a total order on operations enclosed  within the context and boundaries of a session. However, total order is only a specific type of partial order with an additional restriction imposed, namely totality. Hence we did not introduce session order or total order in our  definitions of session consistency models, such as Read Your Writes (RYW), since such definitions are already expressed in terms of equivalent partial order, which in turn makes the task of expressing the definitions in terms of an equivalent total order trivial.

Condition 1, when applied to a system whose interface consists only of reads and writes, translates to a requirement that every read operation in %$\mathcal{S}_t$
${\mathcal{O}_{St}}$ must return the value of the most recent write according to $\preccurlyeq$. Note that in the case of two or more concurrent preceding writes, since any  equivalent re-arrangement of the operations is valid, the system may arbitrate any order for them.
  Condition 2, in turn, can be expressed as $ E^S_C\; \vDash \; \left( {\mathcal{O}_{St}}, \preccurlyeq \right),$ where %$R$ is a temporal operator,
  $E^S_C$ is the ConSpec parameterization for each
 consistency model $\mathcal{C}$,
 %$\sim$ is an equivalence relation between the results $v_i$ and $v_j$ observed by a pair of
   %operations $\mathit{o}^i$ and $\mathit{o}^j$, and
 and  $\vDash$ is the satisfies operator. $E^S_C$  can refer to any characteristic of the global session trace (e.g., impose restrictions based on the ordering of operations within sessions).
 \par A noteworthy choice that was made when producing the above definition is that consistency models are expressed in terms of  partial order among operations performed, instead of using more general relations~\cite{Burckhardt:2014:PEC:2693641.2693642}. This choice entails a tradeoff between generality (by allowing for arbitrary relations) and simplicity (by producing more concise definitions using partial orders). We chose to have simpler definitions using partial orders for two main reasons. First, this is aligned with our goals of enabling a better understanding of consistency through simpler definitions, and second, the protocols that guarantee the extra properties required by partial orders (namely transitivity) are well studied and inexpensive in terms of their runtime overhead, namely since they do not require cross-replica synchronization~\cite{Bailis:2013:BCC:2463676.2465279,Lloyd:2011:DSE:2043556.2043593}.

 Another discussion point worth highlighting is the fact that, when concurrent branches of an execution merge, our definitions state that the output that is produced by any re-arrangement of the partial order of prior requests is admissible. In practice, this corresponds to saying that our merge policy is to serialize concurrent requests in an arbitrary order and re-execute them. Again, it would have been straightforward to add complexity to our definitions in order to allow for other merge strategies.
% , but we chose not to in order to keep our model simple.
For example, the ``last writer wins'' policy~\cite{lww} is a special case of our more general definition, and it would be relatively easy to constrain the definition to always arbitrate an order that is compatible with LWW. However, since our goal is to simplify the definitions, we decided to leave this arbitration out.

% {\bf MOVE BACK TO RELATED WORK:} \cite{Burckhardt:2014:PEC:2693641.2693642} present the definitions of a wide variety of consistency models in terms of relations like visibility and happens before order. Burckhardt et al. \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642} formally represents a \emph{concrete  execution}, comprising a sequence of operations, as an \emph{abstract execution}, which, in turn, is a tuple consisting of several server-level parameters, such as ids of replicas on which operations in a given execution are performed, and replica order, which is a total order on operations performed on each replica.  %\cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642}
%  This work specifies consistency axioms of a storage system in the form of logical constraints on \emph{visibility}  and \emph{arbitration order}  relations which must be satisfied by  a valid abstract execution for a given consistency model.   The above parameters, in turn,  are dependent on replica settings of the underlying storage system, and the manner in which the operations affect each replica.  Choice of a visibility relation is also dependent on the corresponding \emph{visibility witness}  \cite{DBLP:conf/popl/BurckhardtGYZ14},  which is a function of the message delivery protocol  of the underlying storage system. Further, consistency axioms in  \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642}  are a function of a given transport layer specification, which, in turn, is a predicate on a given execution, and  specifies assumptions about the message delivery mechanism of the underlying storage system. But in many cases, they are also a function of the data type specification of the system; specifically,  the choice of visibility witness varies with respect to the class of data type. %A transport layer specification is a parameter of the model which restricts message delivery in the underlying storage system. A data type specification is dependent on the specific target data type in question; specification of a counter data type is different from a register data type.
%  Thus, the consistency definitions in  \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642} are inherently tied to several server-level implementation parameters, like replica settings, underlying message delivery protocol, and target data type.  Unlike ConSpec, the framework described in  \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642} is able to define consistency models that mandate specific conflict resolution policies among concurrent operations in terms of arbitration relations which establishes total order on operations using timestamps collected from global clocks.  While this makes the framework more expressive than ConSpec, it also makes the consistency axioms in  \cite{DBLP:conf/popl/BurckhardtGYZ14, understanding-eventual-consistency, Burckhardt:2014:PEC:2693641.2693642} more complex. With ConSpec, we trade off expressive ability for  simpler definitions.

%{\bf [RR: We could discuss two points that were raised by PODC reviewers here: the fact that using a PO is more restrictive than a relation but leads to more concise notation, and the fact that allowing any linear extension precludes fancy merging but again is more concise.]}

 %%  This implies that the consistency specification for a particular
 %%  consistency model  $\mathcal{C}$ must satisfy the conditions of the generalized partial order relation, i.e., Condition 1 of Definition \ref{def:form0}.
 %%    \par Chockler et al. \cite{Chockler2000} define a consistency model in terms of an equivalent legal serialization,
 %% comprising a linear arrangement of the operations performed by a client application, that the model allows.
 %%   Following Chockler et al., wherever possible, we also define consistency models in terms of conditions imposed with
 %%   respect to a \emph{legal serialization} equivalent to a given sequence of operations executed in a session trace.  By definition \ref{def:ser}, an equivalent legal serialization is a special instance of the partial order $\preccurlyeq$ in Definition \ref{def:form0}, thus satisfying Conditions 1 and 2 of Definition \ref{def:form0}.  Such consistency models are specified in the form $E^S_C = \left( {\mathit{Op}^i}^{'} R {\mathit{Op}^j}^{'} \in \mathit{st} \wedge ... \wedge {\mathit{Op}^k}^{'} R {\mathit{Op}^l}^{'} \in \mathit{st}
 %%     \right)\; \Rightarrow \\
 %%      \exists \mathit{Ser} \; \left( {\mathit{Op}^i}^{'} R^{'} {\mathit{Op}^j}^{'} \in  \mathit{Ser} \right).$
 %%   However, some consistency models, like Total store order, Processor consistency and all isolation levels, can not be
 %%   expressed in terms of an equivalent legal serialization, because of the absence of notions of legal serialization in
 %%   the original  definitions of these consistency models and isolation levels. With ConSpec, those consistency models and isolation
 %%   levels are  specified in terms of a conjunction of logical constraints on the given global execution comprising operations performed from
 %%   concurrent clients on the system. Hence, such specifications also impose a partial order of the form Definition \ref{def:form0},  thus satisfying Conditions 1 and 2 of Definition \ref{def:form0}.  These consistency models are specified in the form $E^S_C = C =  {\mathit{Op}^i}^{'}, {\mathit{Op}^j}^{'}, {\mathit{Op}^k}^{'}, {\mathit{Op}^l}^{'}  \in \mathcal{S}_t \\
 %%         \left( {\mathit{Op}^i}^{'} R {\mathit{Op}^j}^{'} \wedge ... \wedge  {\mathit{Op}^k}^{'} R^{'} {\mathit{Op}^l}^{'} \right)$.
 %%     \par  In the next section, we specify each consistency or isolation level in terms of an expression $E^S_C$ corresponding to each consistency or isolation level.
 %% The consistency model Strict
 %%   Serializability is defined in terms of LTL constraints on the order among all operations performed each client in a global
 %%   execution (represented by the global session trace $\mathcal{S}_t$) with respect to an equivalent legal serialization of a client $S_c$. For Strict serializablity, $E^S_C$ is
 %%   represented by a
 %%   conjunction of one
 %%   or more LTL constraints on operations comprised in $S_c$. Since $S_c$ comprises all operations from all clients in $\mathcal{S}_t$, the strict serializability constraint is a \emph{total order} relation over concurrent clients executing on the underlying storage system.  In other words, strict serializability imposes a total order over a global execution comprising all clients, thus imposing a total order with respect to the global session trace $\mathcal{S}_t$.   Processor consistency and Total Store Order, which are not defined in terms
 %%   of legal serialization, impose constraints on operations comprised in the global execution composed of operations
 %%   performed by one or more concurrent clients. Hence, for Processor consistency and Total Store Order, the specifications $E^S_C$ comprise a
 %%   conjunction of LTL constraints on operations comprised in the global execution $\mathcal{S}_t$. This, in turn, implies that all of the the above mentioned consistency models can be regarded as total orders over operations performed by all clients executing on the storage system, expressed in terms of total order relations on the global session trace  $\mathcal{S}_t$ in their respective specifications $E^S_C$ .
 %%   \par On the other side of the consistency spectrum, the consistency models, namely Read Your Write, Monotonic Read, Causal consistency, Write Follows Read, and Monotonic
 %%   Write are
 %%  defined in terms of constraints on an equivalent legal serialization of a partial execution $S_p$ (refer to Definition \ref{def:parser}), which comprises all operations performed by
 %%  a given client, along with only write operations from other clients. Specifications of these consistency models, $E^S_C$, comprise a
 %%   conjunction of one or more LTL constraints on operations comprised in $S_p$. Since $S_p$ %comprises only write operations performed by other clients apart from operations performed by a given client, and
 %%   does not comprise read operations performed by other concurrent clients, consistency models which impose constraints on $S_p$ can only be regarded as \emph{partial orders} over a global execution comprising operations performed by all concurrent clients on the underlying storage system. An LTL formula representing the specification of such a consistency model can not be regarded as a total order over operations performed by all clients (represented by the global session trace $\mathcal{S}_t$). By definition, an LTL formulas satisfies the following properties: 1) irreflexivity, since LTL defines a linear order over time, and this linearity implies that there can not be any cyclic relation in LTL formulas, 2)  transitivity, which follows trivially from the linear order imposed by LTL, and 3) asymmetric, which follows directly from conditions 1 and 2. Since the above group of consistency models are specified in terms of LTL constraints, they, in turn, are irreflexive, transitive, and asymmetric. Hence, by definition, such consistency models are regarded as \emph{strict partial orders} over all clients.

 \section{Specifying existing models}\label{sec:list}
In this section as well in Section \ref{sec:morelist} in the Appendix, we present the ConSpec specifications for several common
consistency models.
%, which is the Read Your Writes session guarantee, originally proposed by Terry et al.\ in the context of a mobile computing storage system called Bayou~\cite{Terry:1994:SGW:645792.668302}.
%Due to space constrains, we leave the definition of other consistency models and session guarantees, as well as a step by step derivation of the ConSpec definition from their original counterparts to an Appendix.  %an extended version of the paper  at \url{https://github.com/ssidhanta/ConSpecTool/blob/master/ConSpecPODCFull.pdf}.
%Subsequently, in the Appendix, we discuss how these definitions correspond to their original counterparts.
  %\subsection{Specifications for Consistency Models}
% We start by specifying a series of session guarantees, which were originally proposed by Terry et al.\ in the context of a mobile computing storage system called Bayou~\cite{Terry:1994:SGW:645792.668302}. These are four guarantees that apply to individual sessions, allowing applications to see a view of the storage system that is consistent with their previous operations.
%The original definition of these session guarantees is tied to implementation-level concepts, since it is stated, for instance, in terms of the order in which writes are applied at various server replicas. Subsequently there were authors who wrote formal definitions for session guarantees~\cite{Chockler2000, Burckhardt:2014:PEC:2693641.2693642}. In the next four paragraphs, we provide their ConSpec definitions, which highlight a certain symmetry between many of these session guarantees.


\subsection{Causal Consistency}

To illustrate the expressiveness of ConSpec, we also derive ConSpec definitions for three existing consistency models.

First, we define Causal consistency, which is arguably one of the most popular and widely used consistency models in recent distributed storage systems. Our generic formulation allows for an interesting perspective on the definition of causal consistency, which can be expressed as encompassing the constrains defined by the previous session guarantees for all sessions~\cite{Ahamad:1993:PPC:165231.165264}. As such, any pair of operations in the same session need to be constrained by the partial order of the ConSpec definition. Furthermore, the definition needs to take into account that, unlike session guarantees, causal consistency is  defined as a property of the entire system and not on a per-session basis:

%  \par Causal Consistency specifies: results of operations (in a given client application) that are bound by a causal relationship \cite{Bailis:2013:BCC:2463676.2465279} must be  visible in the session trace according to their mutual execution order with respect to an observed session trace. The ConSpec expression for Causal Consistency is given below.
 %\begin{align}\label{eqn:Causal}
%\begin{split}
%\forall i \left(\star w(o,v)F^{o}(w^{'}(o,v^{'})\oplus r(o)) \star \right)_{o}^\mathit{po} \\
%\vdash \left(G\; \star w(o,v)F^{o}(w^{'}(o,v^{'})\oplus r(o)) \star \right)_{o}^\mathit{st}.
%\end{split}
%  \end{align}
\begin{align}\label{eqn:Causal}
\begin{split}
%E^S_C = \forall \; \mathit{st} \in \mathcal{S}_t, \; {\mathit{Op}}'(x), {\mathit{Op}}'(x) \in \mathit{st} : \\
 %\square\;  {\mathit{Op}}'(x) \operatorname{\it F}_\mathit{st} {\mathit{Op}}''(x)
 E^S_C =   \quad \forall x,y \in \mathcal{X}, \mathit{st} \in \mathcal{S}_t, O_\mathit{st}^x, O_\mathit{st}^{y} \in \mathit{st}: \\ \left( \square \left( O_\mathit{st}^x \rightarrow \lozenge O_\mathit{st}^{y} \right)
 %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
 \rightarrow O_\mathit{st}^x \preccurlyeq O_\mathit{st}^{y} \right),
% \vee \big( \left( {\mathit{Op}}^{'} = {W}^{'} \right) \wedge \\
%\left( {\mathit{Op}}^{''} = {R}^{'} \right) \wedge
  % \left( v = v^{'} \right) \big) %\Rightarrow \exists S_p \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in S_p \right) \big).
%   E^S_C = \forall \mathit{st} \in \mathcal{S}_t, {\mathit{Op}^i}^{'}, {\mathit{Op}^j}^{'} \in \mathit{st} \\ \big( \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right)
% \vee \big( \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \wedge \\
%\left( {\mathit{Op}^j}^{'} = {R^j}^{'} \right) \wedge
%   \left( v_i = v_j \right) \big)
 %\Rightarrow {\mathit{Op}}'(x) \preccurlyeq {\mathit{Op}}''(x),
   %; \\
 %C = \not\exists \left( {W^m}^{'} \in \mathcal{S}_t \right) \big( %\left( \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%   \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) %\left( {W^m}^{''} \in \mathcal{S}_t \right)  \\
%    \wedge \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \wedge \\
% \left( {W^m}^{'} F {\mathit{Op}^i}^{'}  \in \mathcal{S}_t \right)
%\wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee
% \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \\ \wedge
%\not\exists  {W^n}^{'} \in \mathcal{S}_t \left( {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big) \big) \big)
 \end{split}
  \end{align} %where the partial order $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ enforces order among conflicting operations in an equivalent $S_p$ to follow the causal order.
%  where $\mathit{st}$ is the session in context of session guarantees, and $ \preccurlyeq$ is a partial order over operations across all data objects with respect to a given global session trace $ \mathcal{S}_t$.
In this definition, the use of  $\preccurlyeq$ reflects this last aspect that Causal consistency is defined as a global property, instead of being specific to a given session trace $\mathit{st} \in \mathcal{S}_t$ and the respective subset of the relation $\preccurlyeq$. The above expression specifies that for  all session traces in a global session trace $\mathcal{S}_t$, there must exist a common valid partial order $\preccurlyeq$ that orders operations according to the precedence relation of those operations in the respective session trace that invokes these operations. %, i.e., $\preccurlyeq$ preserves precedence among operations with respect to each corresponding seession trace.

Note that this definition is simplified by the fact that the generic ConSpec construction already encodes an important aspect of Causal consistency, which is the fact that ConSpec requires the operations to form a partial order. Given the transitivity property of partial orders, this implies that if operation $b$ sees the effects of $a$ and operations $c$ sees the effects of $b$, then $c$ must also see the effects of $a$.

%\begin{figure}%[t]
        %\begin{center}
%        \includegraphics[width=3.5in,height=4.5in]
%                    {examplepo.eps} %\vspace{-5em}
          %\end{center}
%        \caption{Example of a global session trace and an example partial order that %is a superset of a partial order that
%         can be used by each of the ConSpec definitions we studied (except for Sequential Consistency, whose constraints are not met). Some of the ordering constraints are not required by the each of the session guarantees, depending on the type of the pair of operations ordered. Furthermore, the set of operations being considered must be adapted to exclude the reads from the sessions other than the one from the standpoint of which the session guarantees are being upheld. Note that in the case of a read operation that is partially ordered after two concurrent writes, the definition allows us to pick any of the linear extensions of the partial order.}
%        \label{fig:example}
%\end{figure}

\noindent \emph{\textbf{Examples.}}
  Next, to analyze a violation of causal consistency under the read-write interface, we consider the following global session trace comprising three  session traces:

  $\mathit{st}_1$: $w(x,1)$, %r^1(x){2}$,

 $\mathit{st}_2$: $r(x){1}, w'(x,2)$, %, r^3(x){1}$,

 and  $\mathit{st}_3$: $r'(x){2}, r''(x){1}$.

 The list of valid linear extensions of partial orders, comprising all operations in $\mathcal{S}_t$, that satisfy Condition 1 in Definition \ref{def:form0} are given as follows.
 \begin{itemize}
 \item [$\preccurlyeq^1$ =] $W^x_{\mathit{st}}   \preccurlyeq R^x_{\mathit{st}}  \preccurlyeq R''^x_{\mathit{st}}  \preccurlyeq W'^x_{\mathit{st}}   \preccurlyeq R'^x_{\mathit{st}} $
 \item [$\preccurlyeq^2$ =] $ W^x_{\mathit{st}}   \preccurlyeq R''^x_{\mathit{st}}  \preccurlyeq R^x_{\mathit{st}}   \preccurlyeq W'^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}}$
 \item [$\preccurlyeq^3$ =] $   W'^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}} \preccurlyeq  W^x_{\mathit{st}}  \preccurlyeq R^x_{\mathit{st}} \preccurlyeq R''^x_{\mathit{st}}$
 \item [$\preccurlyeq^4$ =] $  W'^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}} \preccurlyeq W^x_{\mathit{st}}  \preccurlyeq R''^x_{\mathit{st}} \preccurlyeq R^x_{\mathit{st}}  $
 \end{itemize} %There are successive operations with direct precedence relation on the object $x$, namely operations $w^2(x,2)$ and $r^3(x){1}$ in $\mathit{st}_5$; hence $\mathit{st}_5$,
 %satisfies LHS of the expression $E^S_C$ specified in Equation \ref{eqn:Causal}.
 Since the session trace  $\mathit{st}_1$ comprises a single write it vacuously satisfies the Causal consistency condition  in Equation \ref{eqn:Causal}, given that this condition constrains pairs of operations in the trace.
   Next, we consider the  session trace $\mathit{st}_2$ in $\mathcal{S}_t$, comprising operations $r(x){1}$ and $w'(x,2)$. $\mathit{st}_2$ only matches the LTL condition $ \square {\mathit{O}}^x_{\mathit{st}} \rightarrow \lozenge {\mathit{O}}'^x_{\mathit{st}}$ for ${\mathit{O}}^x_{\mathit{st}}$ = $r(x){1}$ and  ${\mathit{O}}'^x_{\mathit{st}}$ = $w'(x,2)$.  From the above list of valid partial orders, only $\preccurlyeq^1$ and $\preccurlyeq^2$ satisfy the  condition ${\mathit{O}}^x_{\mathit{st}} \preccurlyeq {\mathit{O}}'^x_{\mathit{st}}$ where ${\mathit{O}}^x_{\mathit{st}}$ = $r(x){1}$ and  ${\mathit{O}}'^x_{\mathit{st}}$ = $w'(x,2)$. Thus, $\mathit{st}_2$ reduces the set of valid linear extensions of partial orders to the set $\preccurlyeq^1, \preccurlyeq^2$.
% also satisfies the Causal consistency condition in Equation \ref{eqn:Causal}.  % \preccurlyeq W^2(x) \preccurlyeq R^1(x) \preccurlyeq R^4(x)$.
  %First, let us consider the sequence of operations
 %$w^1(x,1)$ and $r^1(x){2}$ in the above traces, given by the LTL expression $W^1(x) F R^1(x)$. The above expression satisfies
%the condition $\mathit{Op}^i(x) F \mathit{Op}^j(x)$, where $\mathit{Op}^i(x)$ = $W^1(x)$ and $\mathit{Op}^j(x)$ = $R^1(x)$;
% thus this sequence satisfies the LHS of the implies operator $\Rightarrow$ in $E^S_C$ in Equation \ref{eqn:Causal}. The above sequence of
 %writes and reads satisfies the condition $W^1(x) \preccurlyeq R^1(x)$, thus satisfying the first condition the RHS of
 %the implies operator $\Rightarrow$ in expression $E^S_C$ in Equation \ref{eqn:Causal}.
 %For the second condition in the RHS of
% Equation \ref{eqn:Causal} to hold, there cannot exist write  operations $W^m$ such that the LTL conditions
%   $W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}$ and $v^j = v^m$ hold.
% Since there is no such $W^m$ preceding $\mathit{Op}^i$, the second condition in the RHS of Equation \ref{eqn:Causal}
% holds for the above sequence of operations.
 %Following the same line of argument, the sequence of operations
  %$w^1(x,1)$ and $r^2(x){1}$, $w^1(x,1)$ and $r^3(x){1}$, $w^1(x,1)$ and $r^4(x){2}$, $w^1(x,1)$ and $r^5(x){1}$
  %and $w^1(x,1)$ and  $w^2(x,2)$ satisfy the LHS and RHS of $E^S_C$ in the Equation \ref{eqn:Causal}. Next,
  %Let us consider
  Finally, let us consider the session trace $\mathit{st}_3$  in $\mathcal{S}_t$, comprising operations $w'(x,2)$ and $r''(x){1}$. In this case, $\mathit{st}_3$ matches the LTL condition $ \square {\mathit{O}}'^x_{\mathit{st}} \rightarrow \lozenge {\mathit{O}}''^x_{\mathit{st}}$ for ${\mathit{O}}'^x_{\mathit{st}}$ = $w'(x,2)$ and  ${\mathit{O}}''^x_{\mathit{st}}$ = $r''(x){1}$.  From the list above, the only valid  orders that satisfy the condition ${\mathit{O}}'^x_{\mathit{st}} \preccurlyeq {\mathit{O}}''^x_{\mathit{st}}$ are  $\preccurlyeq^3$ and $\preccurlyeq^4$.
Putting together the previous requirements, we can see that only the orders $\preccurlyeq^1$ and $\preccurlyeq^2$ meet the condition in Equation \ref{eqn:Causal}) for $\mathit{st}_2$, whereas only $\preccurlyeq^3$ and $\preccurlyeq^4$ meet the same condition for $\mathit{st}_3$. Thus, there does not exist a single valid partial order that satisfies the causal consistency  condition for all the session traces in $\mathcal{S}_t$. %; causing a violation of Causal consistency.
 %The precedence between $w^2(x,2)$ and $r^3(x){1}$ in $\mathit{st}_5$ can be expressed as $W^2(x) F R^3(x)$.
%Thus, the above sequence satisfies LHS of $E^S_C$ in the Equation \ref{eqn:Causal}. There does not exist a legal serialization %that  satisfies the condition $W^2(x) \preccurlyeq R^3(x)$, violating the RHS of $E^S_C$ in Equation \ref{eqn:Causal}.
%  Let us consider the anomaly condition $C$ in Equation \ref{eqn:Causal} for the write and read operations $w^2(x,2)$ (which is
%  $w^i$ in this case) and $r^3(x){1}$ (which is $r^j$ in this case). Since  $w^2(x,2)$ is followed by $r^3(x){1}$ in the session trace, they satisfy the LHS of the condition
%  $C$. For the RHS of $C$ to hold, there cannot a exist write operations $w^m$ preceding the write $w^2(x,2)$ such that the
%  LTL condition $\left( {v^j}^{'} = {v^m}^{''} \right) \vee
% \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
%\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big)$
% holds.
% We can assign $W^m = W^1$ since $w^1(x,1)$ precedes $w^2(x,2)$. Subsequently the condition \\ $\left( {v^j}^{'} = {v^m}^{''} \right)$
% holds (since $R^j$ = $R^3$ and $v_j$ = 1 in this case). Hence, the RHS of $C$ is satisfied for Equation \ref{eqn:Causal} for the above sequence of operations.
%Also, we can assign $W^m$ = $W^1$,
%   $\mathit{Op}^i$ = $W^2$, and $\mathit{Op}^j$ = $R^3$, such that the LTL conditions
%   $W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}$ holds. Further, $v_j$ = $v_m$ = 1, violating
%   the condition $\not\exists  \mathit{st} \left( W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}
%   \right) \wedge \left( v^j = v^m \right)$, violating the RHS of Equation \ref{eqn:Causal}.
% Hence, the above global session trace is in violation of Causal consistency.
% \forall i, j, k, o, \mathit{st} \big( \exists \mathit{Op}^k \in  \mathit{st}
%\big( \mathit{Op}^i F \mathit{Op}^j \vee \\ \left( \mathit{Op}^i F \mathit{Op}^k  \wedge
%\mathit{Op}^k F \mathit{Op}^j \right)
%\vee \big( \left( \mathit{Op}^i = W^i \right) \wedge \left( \mathit{Op}^j = R^j \right) \wedge \\
%\left( \left( v_i = v_j \right) \vee \left( \left( v_i = v_k \right)
% \wedge \left( v_k = v_j \right) \right) \big) \right) \big)
%\\ \Rightarrow \exists \mathit{Si}_p \left( \forall \mathit{Op}^i F \mathit{Op}^j \in \mathit{Si}_p \right)
%\wedge \not\exists  \mathit{st} \left( W^m F \mathit{Op}^i F \mathit{Op}^j \in \mathit{st} \right) \\
%\wedge \left( v^j = v^m \right) \big)
 %The operation $r^1(x){2}$ returns 2, which does not match the write operation
% $w^1(x,1)$ that directly preceded $r^1(x){2}$. Similarly, $r^3(x){1}$  does not return the correct value written by
% the latest write $w^2(x,2)$ which directly precedes $r^3(x){1}$. Thus, $S_3$ does not satisfy the conditions in Equation
% \ref{eqn:Causal}.
% \par All the above session traces violate the specification of Sequential Consistency (SC), given in Equation
% \ref{eqn:SC}. Consider the session traces $\mathit{st}_6$, $\mathit{st}_6^{'}$, and $\mathit{st}_6^{''}$, which can be transformed into the valid partial order $\preccurlyeq$. %, which is, in this case, equivalent to  $\preccurlyeq_{\mathit{st}+w}$ in absence of writes from other
% % client applications in the given session history (see above).
%  The sequence of operations $w^1(x,1)$ and
% $r^1(x){2}$ in the above session trace satisfies the LHS of the expression $E^S_C$, i.e., the condition
% $\mathit{Op}^i(x) X \mathit{Op}^j(x) $ holds where $\mathit{Op}^i(x) = W^1(x)$ and $\mathit{Op}^j(x) = W^2(x)$ . %Since %$v_i \not= v_j$,
%  The above sequence of write and read operations
% %do not satisfy the condition  in the RHS of $E^S_C$, i.e., it
% violates the condition $W^1(x) \preccurlyeq R^1(x)$.
% % For the anomaly condition $C$ to hold for the above sequence of operations, let us consider the
%% sequence of operations $w^2(x,2)$ and $r^3(x)1$. For the RHS of $C$ to hold, there cannot a exist write operations $r^k$ following the read $r^3(x)1$ such that the
%%  LTL condition $\big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge
%% \not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \big) \\
%% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$
%% holds.
%% We can assign $r^k = r^4$ since $r^4(x)2$ follows $r^3(x)1$. Subsequently the conditions \\ $\left( {v^k}^{''} = {v^i}^{''} \right)$
%%and $\left( {v^j}^{'} \not= {v^i}^{'} \right)$ holds, since $r^j$ yields $v_j$ = 1, and
%% $r^k$ yields $v_k$ = 2.
% Thus, the above session trace violates the anomaly condition in Equation \ref{eqn:SC}, violating SC.
%  \par Consider a group of 2 clients (or processors), namely $\mathit{Cl}_1$ and $\mathit{Cl}^2$, respectively.  Let us
%  consider  that operations are invoked from the above 2 clients, and a session trace  $\mathit{st}_6$ is
%  collected as follows.
%  $\mathit{st}_6$: $w^1(x,1), r^1(y){1}$, $\mathit{st}_6^{'}$: $w^2(y,1), r^2(x){2}$. % In
%%   $\mathit{st}_6$, the order of write operations $w^1(x,1)$ and $w^2(y,1)$ are different in each of the
%%  2 session traces. In $\mathit{st}^2$, $r^2(x){1}$ returned while $w^1(x,1)$ did not yet execute. In
%%  $\mathit{st}_1$, $w^1(x,1)$ executed but $r^2(x){1}$ did not execute.
%  For the above session trace to satisfy TSO consistency, the condition \\
%  $\left( {W^i}^{'}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right) \wedge
%    \left( {v_j}^{''} \not= {v_i}^{'} \right)  \wedge \\
%  %\big( \not\exists \big( \left({R^k}(x)^{'} \in \mathit{st}^{'} \right) \wedge  \\
%  \left( {R^k}^{''}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right)
%     \wedge \left( {v_k}^{''} \not= {v_i}^{'} \right)  \\
%     \wedge
% %\not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right)  \wedge
%%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) %\big) \\
%\wedge \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \\
%\big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee
%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)  \wedge \\
% \not\exists  {W^m}^{'} \left( {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big)$
%  must hold. In the above session traces, let us assign the operation  $w^1(x,1)$ as $w^i$. $r^2(x){2}$ occurs in another session trace, and thus invoked was from a different client. Further,
%  $r^2(x){2}$ follows $w^1(x,1)$ in the global session order. Hence we can assign the operation
%  $r^2(x){2}$ as $r^j$. Since $r^2(x){2}$ returns 2 instead of 1, the condition ${v_j}^{''} \not= {v_i}^{'} $ does not hold.
%  Also, there doesn't exist an operation $r^k$ preceding $r^2(x){2}$ that satisfies the condition ${v_k}^{''} \not= {v_i}^{'} $.
%  Thus, the given session trace violates Equation \ref{eqn:TSO}.

As an example that obeys causal consistency, consider a global session trace comprising the following session traces:

$\mathit{st}'_1$: $w(x,1)$,

 $\mathit{st}'_2$: $r(x){1}, w'(x,2)$,

 and  $\mathit{st}'_3$: $r'(x){1}, r''(x){2}$

In this case, any partial order  $\preccurlyeq$  that meets the following constraints:

\begin{itemize}

\item $W^x_{\mathit{st}}   \preccurlyeq R^x_{\mathit{st}} $
\item $W^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}} $
\item $R^x_{\mathit{st}} ,  R'^x_{\mathit{st}}   \preccurlyeq W'^x_{\mathit{st}} $
\item $ W'^x_{\mathit{st}} \preccurlyeq R''^x_{\mathit{st}}$
\end{itemize}

\noindent satisfies the right and side of the implication of Equation \ref{eqn:Causal} for all pairs of operations that satisfy its left hand side. The following partial order satisfies all of the above conditions: $\preccurlyeq^5$ = $W^x_{\mathit{st}}   \preccurlyeq R^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}}  \preccurlyeq  W'^x_{\mathit{st}}   \preccurlyeq R''^x_{\mathit{st}} $.  Thus the above  global session trace satisfies Causal consistency.

% Causal+ consistency
% %, which is the strongest consistency that can  be implemented in  a highly available manner (i.e.,  the system is available in presence of partitions)
% is defined and implemented by Lloyd et al.~\cite{Lloyd:2011:DSE:2043556.2043593}. It states that in addition to preserving the causality condition of causal consistency, writes on a given object must be observed in the same precedence order by all clients in a system. %We formalise this definition in terms of ConSpec  as follows.
% Apart from respecting the causality condition, valid partial orders $\preccurlyeq_{\mathit{st}+w}$ and  $\preccurlyeq_{\mathit{st}^{'}+w}$, which restrict precedence among operations from
% sessions $\mathit{st}$ and $ \mathit{st}^{'}$, must comprise a pair of conflicting writes $w(x)$ and $ w^{'} (x)$ on a common data object $x$ according to a common precedence order. The later constraint can be expressed as $W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (x) \Rightarrow W^{'}(x) \preccurlyeq_{{st}^{'}+w} W^{''} (x)$.  Thus, the above condition can be expressed as a conjunction over the causality condition (Equation \ref{eqn:Causal}) and the additional condition  on conflicting writes, as follows.
%
% \begin{align}\label{eqn:Causal2}
% \begin{split}
% E^S_C = & \; \forall \; \mathit{st}, \mathit{st}', \in \mathcal{S}_t, \; {\mathit{Op}}', {\mathit{Op}}'', W'(x),  W''(x) \in \mathit{st} : \;
% {\mathit{Op}}' \operatorname{\it F}_\mathit{st} {\mathit{Op}}''  \Rightarrow {\mathit{Op}}' \preccurlyeq {\mathit{Op}}''\\
% & \wedge \quad W'(x) \preccurlyeq_{\mathit{st}+w} W''(x) \Rightarrow W'(x) \preccurlyeq_{{st}'+w} W''(x)
% \end{split}
% \end{align}
%
% %%%%%%%%%%%%%%%%%%%% BEGIN of Causal+ Simplification %%%%%%%%%%%%%%%%%%%%%%%%%%
% % which we simplify as follows. % where $ \preccurlyeq_{\mathit{st}+w}$ and $\preccurlyeq_{{st}^{'}}$ are partial orders  restricted to  the elements of sessions $\mathit{st}$ and $\mathit{st}^{'}$ plus writes from other clients, respectively.  %$ \preccurlyeq_{\mathit{st}+w}$ and $\preccurlyeq_{{st}^{'}+w}$ denote  partial orders  over operations on a given object $x$ restricted to  the elements of sessions $\mathit{st}$ and $\mathit{st}^{'}$ plus writes from other clients, respectively.
% %  The above equation comprises a conjunction of two implies expressions, one expression (lets refer to this expression as $A \Rightarrow B$) corresponds to the the causality condition, and the other (let it be  $C \Rightarrow D$) corresponds to  conflicting writes.  By inspection,   Conditions B and C specify the same partial order relation $ \preccurlyeq_{\mathit{st}+w}$. The operands of B are any operations in $\mathit{st}$, while operands of C are writes in $\mathit{st}$. Thus C is contained within  B, i.e., $C \subset B$. Hence,  without any loss of information, the expression $A \Rightarrow B \wedge C \Rightarrow D$ can be expressed as  $A \Rightarrow B \wedge D$. %$ {\mathit{Op}}^{'} F_ \mathit{st} {\mathit{Op}}^{''}
% %  %\Rightarrow {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (x) \Rightarrow W^{'}(x) \preccurlyeq_{{st}^{'}+w} W^{''} (x)$ can be expressed as
% %  %${\mathit{Op}}^{''}
% %  %\Rightarrow {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \%preccurlyeq_{\mathit{st}+w}  W^{''} (x) \wedge W^{'} (x) \preccurlyeq_{{st}^{'}+w} W^{''}(x) $.
% %  Thus, the above equation can be rewritten as $E^S_C = \forall \mathit{st}, \mathit{st}^{'}, \in \mathcal{S}_t, {\mathit{Op}}^{'}, {\mathit{Op}}^{''}, W^{'}(x),  W^{''} (x) \in \mathit{st} \big(  {\mathit{Op}}^{'} F _ \mathit{st} {\mathit{Op}}^{''}
% %  \Rightarrow {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge %W^{'}(x) \preccurlyeq_{\mathit{st}+w}  W^{''} (x) \wedge
% %   W^{'} (x) \preccurlyeq_{{st}^{'}+w} W^{''}(x)  \big)$.  Let ${\mathcal{W}_{St}}$ denotes the set comprising write operations  present in all session traces in $\mathcal{S}_t$.
% %  Replacing the partial order relations ${\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''} $ %, $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (x)   \right)$,
% %  and $ W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{'} (x)  $ with the corresponding partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$ %, $\left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$,
% %  and $\left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$,  the RHS condition of the $ \Rightarrow$ operator in the above equation can be expressed as ${\mathit{Op}}^{'}, {\mathit{Op}}^{''}  \in \left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right) % \wedge W^{'}(x), W^{''} (x)  \in   \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (x)   \right)
% %   \wedge W^{'}(x), W^{''} (x)  \in   \left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
% %  Further, the RHS can be expressed as ${\mathit{Op}}^{'}, {\mathit{Op}}^{''} \in \left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right),$  where the partial order set $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right)$ is given as $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right) \equiv \left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right) % \cap \left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)
% %   \cap \left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. %an intersection of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
% %  Since  ${\mathit{Op}}^{'}, {\mathit{Op}}^{''}  \in \left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right) \equiv {\mathit{Op}}^{'} \preccurlyeq^{'} {\mathit{Op}}^{''} $, Causal+ can be rewritten into the following form.
% %    \begin{align}\label{eqn:CausalC}
% % \begin{split}
% % E^S_C = \forall \mathit{st}, \mathit{st}^{'}, \in \mathcal{S}_t, {\mathit{Op}}^{'}, {\mathit{Op}}^{''} \in \mathit{st} \big(  {\mathit{Op}}^{'} F_ \mathit{st} {\mathit{Op}}^{''}
% %  \Rightarrow {\mathit{Op}}^{'} \preccurlyeq^{'} {\mathit{Op}}^{''}\big).
% %   \end{split}
% %   \end{align}
% %  %\begin{align*}
% % %\forall i, j, k, l, m, n, q, t, u, x, y, z, a \\
% % % \big(\star W^j(v_l) F^{o}  \left( W^n(v_q) X^{o} R^z{v_a}\oplus R^k{v_m} \right) \star \big)_{o}^\mathit{po} \\
% % %\Rightarrow \big(G\; \star \left( v_q = v_l \right) \oplus \left( W^j(v_l) F^{o} W^t(v_u) F^{o} W^n(v_q)  \right) \\ \oplus \left( v_l = v_m \right) \oplus \left( W^j(v_l) F^{o} W^x(v_y) F^{o} R^k(v_m)  \right) \star \big)_{o}^\mathit{st}.
% % %  \end{align*}\label{eqn:Causal} %where $\oplus$ is the logical operator exclusive or (x-or). An expression $a \oplus b$ denotes that either $a$ is true or $b$ is true, but both $a$ and $b$ can not be true or false simultaneously.
% %%%%%%%%%%%%%%%%%%%% END of Causal+ Simplification %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% %  Strict Serializability \cite{Herlihy:1990:LCC:78969.78972} is a consistency model that adds the restriction of linearizability to serializability. In addition to the existential quantification over an equivalent legal serialization over the global session trace, it further specifies: any session trace must observe latest result of all operations in a client application. Using the notion of serialization of a client, given in Equation \ref{def:clientser},  Strict Serializability is expressed as follows. \\
%  %\begin{align}\label{eqn:Strict}
% %\begin{split}
% %\forall{i,j}\; \left(\star \mathit{o}_iX^{o}\mathit{o}_j \star \right)_{{o},{o_j}}^\mathit{po} \vdash \bigcap_{\mathit{st}\in \mathcal{S}} \left(G\; \star \mathit{o}_iX^{o}\mathit{o}_j \star \right)_{{o},{o_j}}^\mathit{st}c,
% % \end{split}
% %  \end{align}
% % \begin{align}\label{eqn:Strict}
% %\begin{split}
% %E^S_C =  \forall \mathit{st} \in \mathcal{S}_t, {\mathit{Op}^i}^{'}, {\mathit{Op}^j}^{'} \in \mathit{st} \big( \mathit{Op}^i X^o {\mathit{Op}^j}^{'} \in \mathit{st}
% %\Rightarrow
% %\exists S_c \\ \left( {\mathit{Op}^i}^{'} X^o {\mathit{Op}^j}^{'} \in S_c \right) \big).
% %E^S_C =  \forall \mathit{st} \in \mathcal{S}_t, {\mathit{Op}}^{'}, {\mathit{Op}}^{''} \in \mathit{st} \big( \mathit{Op}^{'} X^o {\mathit{Op}}^{''} \in \mathit{st}
% %\Rightarrow \left( {\mathit{Op}}^{'} \preccurlyeq {\mathit{Op}}^{''} \right) \big), %; \\
% %\vee \exists \left( \mathit{st}^{'} \in \mathcal{S}_t \; \wedge \;  {\mathit{Op}^k}^{''} \in \mathit{st}^{'} \right)
% % \\ \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^k}^{''} F {\mathit{Op}^j}^{'} \in S \right) \big) \big) \\
%  %C =  \left( \not\exists {R^k}^{''} \in \mathcal{S}_t \right)
% % \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
% % \left( {R^j}^{''} F {R^k}^{''} \in \mathcal{S}_t \right)  \wedge \\
% %   \left( {v^k}^{''} = {v^i}^{'} \right)
% %   \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge
% % \left( \not\exists {R^k}^{''}, {R^l}^{'}, {\mathit{Op}^i}^{'} \in \mathcal{S}_t \right) \\
% % \big( \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge
% %\left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \\ \wedge
% %   \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)
% % \not\exists \big( \left( {R^i}^{'} F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \left( {R^i}^{''} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \big) \\
% % \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big) \wedge
% % \not\exists \big( \left( {W^i}^{'} F {W^j}^{'} F {R^k}^{'} \in \mathit{st} \right) \wedge \\
% % \left( {W^i}^{'} F {W^j}^{'} F {R^k}^{''} F {R^l}^{l'} \in \mathcal{S}_t \right) \big)
% % \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{'} \not= {v^i}^{'} \right) \big)
% %\forall \left( \left( {W^i}^{'}(x) F {R^j}^{'}(y) \in \mathit{st} \right) \wedge \left( {W^k}^{'}(y) F {R^l}^{'}(x) \in \mathit{st} \right) \right) \\
% % \big( \not\exists \left( %\mathit{st}^{'} \in \mathcal{S}_t \; \wedge \;
% %  {W^m}^{''}(x) F {W^i}^{''}(x) F {R^l}^{''}(x) \in \mathit{st}  \right)
% % \left( {v^l}^{''} = {v^m}^{''} \right) \wedge \\
% % \not\exists \left( %\mathit{st}^{''} \in \mathcal{S}_t \; \wedge \;
% %  {W^n}^{'''}(y) F {W^k}^{'''}(y) F {R^j}^{'''}(y) \in \mathit{st}  \right)
% % \left( {v^j}^{'''} = {v^n}^{'''} \right) \big)
% % \wedge
% %\big( \not\exists W^m(x), W^n(y) \in \mathit{st} \\ \big( \left( W^m(x) F W^i(x) F R^k(y) \in \mathit{st} \right) \wedge  \\
% % \left( W^n(y) F W^l(y) F R^j(x) \in \mathit{st} \right) \wedge \left( v_k = v_l \right) \wedge \\
% % \left( v_j = v_m \vee v_i = v_l \right) \big) \big) \big)  %\left( \mathit{Op}^i X^o \mathit{Op}^j \in S \right) \\ \wedge \forall \mathit{st}  \left( \mathit{Op}^j X^o R^k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right) \big)
% % \end{split}
% %  \end{align} where the partial order $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ is a partial order over operations in a global execution comprising operations executed by all clients executing on the system. %It restricts an equivalent serialization of a client $S_c$, defined in Definition \ref{def:clientser}, to respect the order of successive operations in a given session trace. %where $\mathit{o}_i$ is any operation (read or write), and $\mathcal{S}$ is the set of all session traces for a given client application. % scope.



\subsection{Sequential Consistency}

Our final example definition is  Sequential consistency (SC), which is a strong consistency model that enforces global ordering among operations executed from concurrent client processes. SC requires that a global execution comprising operations executed from one or more clients must be equivalent to the result of executing the operations in a sequential order, such that the order among operations from each client in that sequence matches the invocation order of the operations.  Hence, there must exist a valid partial order set $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ comprising all operations in a given global session trace $\mathcal{S}_t$ that satisfies the following condition. The precedence order among every pair of operations $O^{x}_\mathit{st} $ and $O'^{y}_\mathit{st} $ in  $ \preccurlyeq$ must follow the  precedence order among $O^{x}_\mathit{st} $ and $O'^{y}_\mathit{st} $ in each session trace $\mathit{st}$ comprised in  $\mathcal{S}_t$.  This condition can be given as $\square \left( O_\mathit{st}^x \rightarrow \lozenge O'^{y}_\mathit{st}  \right)
 %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
 \rightarrow O_\mathit{st}^x \preccurlyeq O'^{y}_\mathit{st}$. Additionally, the result of every pair of operations must be equivalent to that of performing a sequential execution of the operations, i.e., there must exist an equivalent total order among all the operations. Combining the above conditions, SC can be expressed as follows.
% \begin{align}\label{eqn:SC}
% \begin{split}
%   E^S_C =  \forall {\mathit{Op}}', {\mathit{Op}}'' \in \mathcal{O}_{St} : \; \left({\mathit{Op}}' \preccurlyeq {\mathit{Op}}''  \vee  {\mathit{Op}}''  \preccurlyeq {\mathit{Op}}'\right) \wedge \left( (
% \exists \mathit{st}\in \mathcal{S}_t:\mathit{Op}' \operatorname{\it F}_\mathit{st}  {\mathit{Op}}'')
% \Rightarrow  {\mathit{Op}}' \preccurlyeq {\mathit{Op}}''  \right)
% \end{split}
%   \end{align}
%
\begin{align}\label{eqn:SC}
\begin{split}
      E^S_C =  %(\forall \mathit{st} \in \mathcal{S}_t, \; {\mathit{Op}}, {\mathit{Op}}'(x) \in \mathit{st}: \\
 % \square\; \mathit{Op}(x) \operatorname{\it F}_\mathit{st} {\mathit{Op}}'(x) \Rightarrow  {\mathit{Op}}(x) \preccurlyeq {\mathit{Op}}'(x)) \quad
   \forall x,y \in \mathcal{X}, \mathit{st} \in \mathcal{S}_t, O_\mathit{st}^x, O'^{y}_\mathit{st} \in \mathit{st}:  \\
     \big( \square \left( O_\mathit{st}^x \rightarrow \lozenge O'^{y}_\mathit{st} \right)
 %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
 \rightarrow O_\mathit{st}^x \preccurlyeq O'^{y}_\mathit{st}  \; \wedge
 \\
 \forall O'', O''' \in \mathcal{S}_t:
 O'' \preccurlyeq O''' \vee O''' \preccurlyeq O'' \big). %\\
%\left({\mathit{Op}}'' \prec {\mathit{Op}}'''  \vee  {\mathit{Op}}'''  \preccurlyeq {\mathit{Op}}''\right)
\end{split}
\end{align}

\noindent \emph{\textbf{Examples.}}
%Figure~\ref{fig:example} shows an example execution where the global session trace contains two sessions, each with three operations (two writes followed by a read).
Let us consider a global session trace comprising following two sessions, each with three operations (two writes followed by a read).

 $\mathit{st}_8^{''}$:   $w(x, 1), w'(x,99), r(y){1}$, and

 $\mathit{st}_8^{''}$:  $w(y, 1), w'(y,99), r(x){1}$

 This global session trace meets all the consistency levels we defined so far with the exception of sequential consistency.
 In particular, for sequential consistency, the constraints in $E^S_C$ require the partial order to be a total order, which is impossible to achieve while also obeying the session order and explaining the results that are observed according to the sequential specification of a read/write interface. This is because one would have to serialize both reads before the respective writes of value 99, but that would be impossible to achieve in a total order that respects the session orders.
%$\square W'^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$. %, where $W'^x_{\mathit{st}}$ denotes the operation $w'(x,2)$ and
  %$R'^x_{\mathit{st}}$ denotes the operation $r'(x){1}$.
  %Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does exist
%  a write operation $W^k$ = $W^1$ such that the LTL condition $W^k F^x W^i F^x R^j$ holds,  where $W^i$ = $W^2$ and
%  $R^j$ = $R^2$. Further, the read operation
%  $R^2$ returns a value 1 which was written by the write operation $W^1$ that precedes $W^2$. Thus the condition $v_j=v_k$
%  holds, and thus, in turn, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
%  For anomaly
%  condition $C$  in Equation \ref{eqn:RYW} to hold, their cannot exist in the global session trace a read operation $r^k$ preceding the read operation
%  $r^j$ (which is $r^2(x){1}$) and a write operation $w^l$ preceding $w^i$ (which is $w^2(x,2)$ in this case)
%   such that the LTL condition $\left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big(\left( {v^j}^{'} = {v^l}^{'} \right) \vee
%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big)$ hold.
%However, in the given session trace  $\mathit{st}_1$, there does exist a read $r^1(x){2}$ and a write $w^1(x,1)$, such that
%conditions $\left(  {v^k}^{'} = {v^i}^{'} \right) $ and $\left( {v^j}^{'} = {v^l}^{'} \right)$ hold, thus, in turn,
%violating the anomaly condition.
  %This causes violation of the RHS of Equation  \ref{eqn:RYW},
  Therefore, we can conclude that there does not exist a valid partial order that satisfies Equation~\ref{eqn:SC} for all write-read pairs in $\mathit{st}_1$, which means that the SC session guarantee is not upheld.
% ConSpec definitions of some more popular consistency models are given in Section  \ref{sec:appendix} along with accompanying examples of session traces to demonstrate each of the definitions.
 %In Section \ref{sec:derive}, we show that the ConSpec specifications of  consistency models  and original definitions \cite{Chockler2000, Ahamad:1993:PPC:165231.165264, Owens:2009:BXM:1616077.1616107} are in fact equivalent.
%\begin{align}\label{eqn:SC}
%\begin{split}
%    E^S_C =  \; \forall \mathit{st} \in \mathcal{S}_t, \; {\mathit{Op}}, {\mathit{Op}}' \in \mathit{st}, \; {\mathit{Op}}'', {\mathit{Op}}''' \in \mathcal{O}_{St} : \\
% \mathit{Op} \operatorname{\it F}_\mathit{st} {\mathit{Op}}' \Rightarrow  {\mathit{Op}} \preccurlyeq {\mathit{Op}}' \quad \wedge {\mathit{Op}}'' \prec {\mathit{Op}}''' %\\
%%\left({\mathit{Op}}'' \prec {\mathit{Op}}'''  \vee  {\mathit{Op}}'''  \preccurlyeq {\mathit{Op}}''\right)
%\end{split}
%\end{align}

%\begin{figure}%[t]
%        %\begin{center}
%        \includegraphics[width=2.8in,height=1.8in]
%                    {examplepo} %\vspace{-5em}
%          %\end{center}
%        \caption{Example of a global session trace and an example partial order that %is a superset of a partial order that
%         can be used by each of the ConSpec definitions we studied (except for Sequential Consistency, whose constraints are not met). Some of the ordering constraints are not required by the each of the session guarantees, depending on the type of the pair of operations ordered. Furthermore, the set of operations being considered must be adapted to exclude the reads from the sessions other than the one from the standpoint of which the session guarantees are being upheld. Note that in the case of a read operation that is partially ordered after two concurrent writes, the definition allows us to pick any of the linear extensions of the partial order.}
%        \label{fig:example}
%\end{figure}
%
%\par Figure~\ref{fig:example} shows an example execution where the global session trace contains two sessions, each with three operations (two writes followed by a read). This execution meets all the consistency levels we defined with the exception of sequential consistency. The right hand side of the figure shows a partial order that %is a superset of what
%  can be used to support the execution (i.e., meets condition (1) of the ConSpec general definition), and that also meets the constraints ($E^S_C$) specified by all the consistency levels we presented except sequential consistency. For sequential consistency, the constraints would require the partial order to be a total order, which is impossible to achieve while also obeying the session order and explaining the results that are observed according to the sequential specification of a read/write interface. This is because one would have to serialize both reads before the respective writes of value 99, but that would be impossible to achieve in a total order that respects the session orders.


% where $\prec$ denotes a total order over operations in a global execution comprising operations executed by all clients executing on the system. The total order relation $\left( {\mathit{Op}}^{'} \prec {\mathit{Op}}^{''} \right)$ implies
% $\left( {\mathit{Op}}^{'} \preccurlyeq {\mathit{Op}}^{''} \right) \vee \left( {\mathit{Op}}^{''}  \preccurlyeq {\mathit{Op}}^{'}\right)$, where  $\preccurlyeq$ denotes a partial order relation, and $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ is the corresponding partial order set.

%  \section{Verifying Traces Against ConSpec Specifications -- REMOVE SECTION?}\label{sec:examples}
%  Using examples of global session traces, we illustrate both cases where a consistency model is met by the trace, and cases where a model is violated, according to the corresponding ConSpec definition.
% %    \begin{figure}%[t]
% %        %\begin{center}
% %        \includegraphics[width=3.5in,height=4.5in]
% %                    {examplepo.eps} %\vspace{-5em}
% %          %\end{center}
% %        \caption{Example of a global session trace and an example partial order that %is a superset of a partial order that
% %         can be used by each of the ConSpec definitions we studied (except for Sequential Consistency, whose constraints are not met). Some of the ordering constraints are not required by the each of the session guarantees, depending on the type of the pair of operations ordered. Furthermore, the set of operations being considered must be adapted to exclude the reads from the sessions other than the one from the standpoint of which the session guarantees are being upheld. Note that in the case of a read operation that is partially ordered after two concurrent writes, the definition allows us to pick any of the linear extensions of the partial order.}
% %        \label{fig:example}
% %\end{figure}
% % Figure~\ref{fig:example} shows an example execution where the global session trace contains two sessions, each with three operations (two writes followed by a read). This global session trace meets all the consistency levels we defined in the previous section with the exception of sequential consistency. The right hand side of the figure shows a partial order that %is a superset of what
% %  can be used to support the execution (i.e., meets condition (1) of the ConSpec general definition), and that also meets the constraints ($E^S_C$) specified by the consistency levels we presented except sequential consistency. For sequential consistency, the constraints would require the partial order to be a total order, which is impossible to achieve while also obeying the session order and explaining the results that are observed according to the sequential specification of a read/write interface. This is because one would have to serialize both reads before the respective writes of value 99, but that would be impossible to achieve in a total order that respects the session orders.
% %  Let us consider a
% %session trace $\mathit{st}_1$: $w^1(x,1), w^2(x,2), r^1(x){2}, r^2(x){1}$ to demonstrate how violation of RYW consistency can occur.
% %% From the session trace $\mathit{st}_1$, the following LTL expression  \\ $W^1 F W^2 F R^1 F R^2$ follows
% %% directly from the temporal order of execution as per the session trace.
% % In $\mathit{st}_1$, the read operation $r^1(x){2}$
% % follows the write operation $w^1(x,1)$, and this temporal order can be expressed by the LTL expression $W^1(x) F R^1(x)$; which satisfies the
% % condition given in LHS (i.e., left hand side) of the specification $E^S_C$ given in Equation \ref{eqn:RYW}. %, where $W^i$ = $W^1$, $R^j$ = $R^1$.
% %  The session trace
% % $\mathit{st}_1$ can be transformed into the following  partial orders that satisfy Condition 1 in Definition \ref{def:form0}, which also comprise write operations from other
% % clients: \begin{itemize}
% % \item $\preccurlyeq_{\mathit{st}+w}^1$ = $W^1(x) \preccurlyeq_{\mathit{st}+w}^1 R^2(x) \preccurlyeq_{\mathit{st}+w}^1 W^2(x)
% %  \preccurlyeq_{\mathit{st}+w}^1 R^1(x)$
% %  \item $\preccurlyeq_{\mathit{st}+w}^2$ = $W^2(x) \preccurlyeq_{\mathit{st}+w}^2 R^1(x) \preccurlyeq_{\mathit{st}+w}^2 W^1(x) \preccurlyeq_{\mathit{st}+w}^2 R^2(x)$
% %  \item $\preccurlyeq_{\mathit{st}+w}^3$ = $R^1(x) \preccurlyeq_{\mathit{st}+w}^3 W^2(x) \preccurlyeq_{\mathit{st}+w}^3 W^1(x) \preccurlyeq_{\mathit{st}+w}^3 R^2(x)$
% %  \end{itemize}
% % Only for $\preccurlyeq_{\mathit{st}+w}^1$, the condition $W^1(x) \preccurlyeq_{\mathit{st}+w} R^1(x)$ holds, which does not hold for $\preccurlyeq_{\mathit{st}+w}^2$ and $\preccurlyeq_{\mathit{st}+w}^3$.
% % Thus the condition corresponding to the RHS of the implies operator $\Rightarrow$ in $E^S_C$ , given in Equation \ref{eqn:RYW}, holds.
% %  %$W^k$ preceding  $W^1$ such that the above LTL condition holds.
% %  Next, we consider the sequence in the session trace where the
% %   write operation $w^1(x,1)$ is followed by the read operation  $r^2(x){1}$, expressed by the LTL expression $W^1(x) F R^2(x)$. As discussed before, a partial
% %  order $\preccurlyeq_{\mathit{st}+w}^1$ exists for the session trace such that $W^1(x) \preccurlyeq_{\mathit{st}+w}^1 R^2(x)$, satisfying the first
% %  condition in the RHS of Equation \ref{eqn:RYW}.
% %  %Also, following the same argument as
% %%   above, there does not exist a $w^k$ such that the temporal order represented by the LTL condition $W^k F^x W^1 F^x R^2$ holds.
% %  Next, we consider the sequence where the write operation $W^2(x)$ is followed by the read $R^1(x)$ in the session trace, given as $W^2(x) F R^1(x)$.
% %  This implies that the condition $W^i(x) F R^j(x)$ in the LHS of the $E^S_C$ condition in Equation \ref{eqn:RYW} holds, where $W^i(x)$ = $W^2(x)$ and
% %  $R^j(x)$ = $R^1(x)$. Again a valid partial order $\preccurlyeq_{\mathit{st}+w}^1$ exists such that $W^2(x) \preccurlyeq_{\mathit{st}+w} R^1(x)$.
% %%  Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does not exist
% %%  a write operation $W^k$ such that the LTL conditions $W^k F^x W^i F^x R^j$ and $v_j=v_k$ hold, where $W^i$ = $W^2$
% %%  and $R^j$ = $R^1$. Thus, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% %% \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
% %  %$R^1$ returns a value 2 was written by the write operation $W^1$ which precedes $W^2$.
% %%   Thus the condition
% %%  $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% %% \wedge \left( v^j = v^k \right)$ holds, where $\mathit{st}$ = $\mathit{st}_1$.
% %  Next, we consider the sequence where the write operation $W^2(x)$  is followed by the read $R^2(x)$ in the session trace, given as $W^2 F R^2$.
% %  This implies that the condition $W^i(x) F R^j(x)$ in the LHS of $E^S_C$ specified in Equation \ref{eqn:RYW} holds, where $W^i(x)$ = $W^2(x)$ and
% %  $R^j(x)$ = $R^2(x)$. $\preccurlyeq_{\mathit{st}+w}^1$ is the only valid partial order that satisfies the condition $W^i(x) \preccurlyeq_{\mathit{st}+w}^1 R^j(x)$
% %   in the RHS of Equation \ref{eqn:RYW} for all the above write-read operation sequences. However, $\preccurlyeq_{\mathit{st}+w}^1$ does not satisfy
% %  $W^i(x) \preccurlyeq_{\mathit{st}+w}^1 R^j(x) $ for the write-read sequence $W^2 F R^2$, where $W^i(x)$ = $W^2(x)$ and
% %  $R^j(x)$ = $R^2(x)$.
% %  %Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does exist
% %%  a write operation $W^k$ = $W^1$ such that the LTL condition $W^k F^x W^i F^x R^j$ holds,  where $W^i$ = $W^2$ and
% %%  $R^j$ = $R^2$. Further, the read operation
% %%  $R^2$ returns a value 1 which was written by the write operation $W^1$ that precedes $W^2$. Thus the condition $v_j=v_k$
% %%  holds, and thus, in turn, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% %% \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
% %%  For anomaly
% %%  condition $C$  in Equation \ref{eqn:RYW} to hold, their cannot exist in the global session trace a read operation $r^k$ preceding the read operation
% %%  $r^j$ (which is $r^2(x){1}$) and a write operation $w^l$ preceding $w^i$ (which is $w^2(x,2)$ in this case)
% %%   such that the LTL condition $\left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big(\left( {v^j}^{'} = {v^l}^{'} \right) \vee
% %%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big)$ hold.
% %%However, in the given session trace  $\mathit{st}_1$, there does exist a read $r^1(x){2}$ and a write $w^1(x,1)$, such that
% %%conditions $\left(  {v^k}^{'} = {v^i}^{'} \right) $ and $\left( {v^j}^{'} = {v^l}^{'} \right)$ hold, thus, in turn,
% %%violating the anomaly condition.
% %  Hence, the RYW condition is violated for the given session trace.
% % %In $\mathit{st}_1$, read operations $r^1(x){2}$ and $r^2(x){1}$ follow the $w^2(x,2)$, the latest write operation on $x$,
% %%   satisfying the RHS of Equation \ref{eqn:RYW}. However, the value returned by $r^2(x){1}$ is 1, which does not match the
% %%    value written by the latest write operation $w^2(x,2)$ preceding $r^2(x){1}$; hence, $S_1 $does not satisfy the
% %%    condition $v_m = v_l$ in Equation \ref{eqn:RYW}.  Further, the value written by $w^2(x,2)$ is not overwritten by any
% %%     subsequent write preceding $r^2(x){1}$; hence, $S_1$ does not satisfy the condition
% %%     $W^j(v_l) F^{o} W^p(v_q) F^{o} R^k{v_m}$ in  Equation \ref{eqn:RYW}. Thus $S_1$ does not satisfy Equation
% %%     \ref{eqn:RYW}.
% % \par Let us consider a session trace $\mathit{st}_2$:  $w^1(x,1)$, $\mathit{st}_2^{'}$: $w^2(x,2)$, and $\mathit{st}_2^{''}$: $r^1(x){1}, r^2(x){2}, r^3(x){1}$ to illustrate how
% % violation of MR consistency can occur. Since the above session traces comprise write operations followed by multiple reads on common objects, there are read-read sequences that satisfy the conditions stated in LHS of Equation \ref{eqn:MR}.
% % First, let us consider the sequence of read operations $r^1(x){1}$ and $r^2(x){2}$ in $\mathit{st}^2$, given by the LTL expression $R^1(x) F R^2(x)$.
% %Using $R^i(x)$ = $R^1$ and $R^j(x)$ = $R^2(x)$, the above sequence of reads corresponds to the LHS of the expression of  $E^S_C$ in Equation \ref{eqn:MR}.
% %  The above traces can be transformed into a valid partial order $\preccurlyeq_{\mathit{st}+w}$ =
% % $W^1(x) \preccurlyeq_{\mathit{st}+w} R^1(x) \preccurlyeq_{\mathit{st}+w} R^3(x) \preccurlyeq_{\mathit{st}+w} W^2(x) \preccurlyeq_{\mathit{st}+w} R^2(x)$, such that $R^1(x) \preccurlyeq_{\mathit{st}+w} R^2(x)$ holds, thus satisfying
% % the RHS of the implies operator $\Rightarrow$
% % in  $E^S_C$ in Equation \ref{eqn:MR}.
% %   Next, we consider a sequence of reads $r^1(x){1}$ followed by $r^3(x){1}$ in the above traces, given by the LTL expression $R^1(x) F R^3(x)$.
% %   The above sequence satisfies the LHS of expression $E^S_C$ in Equation
% %   \ref{eqn:MR}, using
% %  $R^i(x)$ = $R^1(x)$ and $R^j(x)$ = $R^3(x)$, which, in turn, implies  $R^1(x) F R^3(x) $. % $v_i$ = $v_1$ = 1 and $v_j$ = $v_2$ =1.
% %   As discussed above, a
% %  valid partial order $\preccurlyeq_{\mathit{st}+w}$ exists for the above trace, such that $R^1(x) \preccurlyeq_{\mathit{st}+w} R^3(x)$
% %  holds. Hence, the condition specified in the RHS of Equation \ref{eqn:MR} holds for the above sequence of reads.
% %  %Also, $W^m$ and $W^n$ are the only write operations
% %%  that can satisfy the condition $W^m F^x W^n F^x R^i F^x R^j \in \mathit{st}$. Hence,
% %%  the second condition in the RHS requires that $W^m$ = $W^1$ and $W^n$ = $W^2$, and thus $v_m$ = $v_1$ = 1 and $v_n$ = $v_2$ = 2.
% %%  Hence,  $v_n \not= v_i$, which, in turn, implies that the condition $\left( v^i = v^n \right) \wedge \left( v^j = v^m \right)$
% %%  $\left( v^i = v^n \right) \wedge \left( v^j = v^m \right)$ holds. This, in turn, second condition in the RHS of
% %%  Equation \ref{eqn:MR} holds.
% %   Next, we consider the sequence of reads $r^2(x){2}$ followed by $r^3(x){1}$ in the above traces, given
% %  as $R^2(x) F R^3(x)$. However, the above sequence of reads does not match the order among these reads in the valid partial order  $\preccurlyeq_{\mathit{st}+w}$, i.e.,
% %  $R^2(x) \preccurlyeq_{\mathit{st}+w} R^3(x)$ does not hold;
% %    thus it does not satisfy the first condition in the RHS of Equation \ref{eqn:MR}.
% %%    Further, for the LHS of Equation \ref{eqn:MR} to hold for the above sequence of reads,   $R^i$ = $R^2$ and $R^j$ = $R^3$,
% %%   which, in turn, implies $R^2 F R^3$. % $v_i$ = $v_2$ = 2 and $v_j$ = $v_3$ =1.
% %%   For the anomaly condition $C$ in Equation \ref{eqn:MR} to hold for the sequence of read operations $r^1(x){1}$ followed by $r^3(x){1}$, there cannot exist write
% %%  operations $w^m$ and $w^n$ corresponding to the reads $r^i$ and $r^j$  such that the LTL condition
% %%  $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\ \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big)$ holds.
% %%   Here, $W^m$ = $W^1$ and $W^n$ = $W^2$, since $W^m$ and $W^n$ are the only write operations in the given session history.
% %%   Hence, $v_m$ = $v_1$ = 1 and $v_n$ = $v_2$ = 2. Also, it is given that
% %%  $v_i$ = $v_1$ = 1 and $v_j$ = $v_2$ =2. Hence, the conditions $\left( v^i = v^n \right)$ and $ \left( v^j = v^m \right)$
% %%  is satisfied; thus, in turn, the above LTL condition is also satisfied.
% %% Thus, the violation condition $C$
% %%  in Equation \ref{eqn:MR} holds.
% %   %Also, $W^m$ = $W^1$ and $W^n$ = $W^2$. Hence,
% %%   $v_n$ = $v_i$ and $v_m$ = $v_j$. Thus, the second condition does not hold here.
% %    Hence, the above traces violate the MR condition.
% %   %\par
% % % In $S_2$, $r^1(x){1}$ returns a value 1, whereas it should have returned 2, which is the value written by the latest write operation $w^2(x,2)$ preceding $r^1(x){1}$. Thus, $S_2$ does not satisfy the condition $v_l = v_m$. Since there are not write operations overwriting the latest write operation $w^2(x,2)$ preceding each read, the condition $W^j(v_l) F^{o} W^x(v_y) F^{o} R^k(v_m)$ holds. Following the same line of argument, we can show that $S_2$ does not
% %% satisfy any of the  conditions in RHS of Equation \ref{eqn:MR}. Hence, $S_2$ does not satisfy Equation \ref{eqn:MR}.
% %\par  We consider the session traces \\ $\mathit{st}_3$: $w^1(x,1)$, $\mathit{st}_3^{'}$: $r^1(x){1}, w^2(x,2)$, and
% % $\mathit{st}_3^{''}$: $w^3(x){3}, r^2(x){3}, w^4(x,2), r^3(x){2}, r^4(x){3}$ to show how
% % WFR consistency can be violated. The above session traces can be transformed into two valid partial orders
% % $\preccurlyeq_{\mathit{st}+w}$  = $W^1(x) \preccurlyeq_{\mathit{st}+w} R^1(x) \preccurlyeq_{\mathit{st}+w} W^2(x)$ %\preccurlyeq_{\mathit{st}+w} W^2(x) \preccurlyeq_{\mathit{st}+w} R^2(x)$
% %  and
% %  $\preccurlyeq_{\mathit{st}+w}^{'}$  = $W^3(x) \preccurlyeq_{\mathit{st}+w} R^2(x) \preccurlyeq_{\mathit{st}+w}  R^4(x) \preccurlyeq_{\mathit{st}+w}  W^2(x) \preccurlyeq_{\mathit{st}+w}  W^4(x) \preccurlyeq_{\mathit{st}+w} R^3(x)  \preccurlyeq_{\mathit{st}+w}  W^1(x) $. In the above traces, the write operation $w^4(x,2)$ follows
% %  the read operation $r^2(x){3}$, and is then followed by read operation $r^4(x){3}$. %, and can be expressed as $R^1(x) F W^2(x) F R^4(x)$.
% %  The above sequence of operations satisfies
% % the condition $R^{'}(x) F W^{'}(x)F R^{''}(x)$, where $R^{'}(x)$ = $R^2(x)$, $W^{'}(x)$ = $W^4(x)$, $R^{''}(x)$ = $R^4(x)$. Hence,
% %% the above traces satisfy the
% %% condition $R^i F W^j$ in the LHS of Equation \ref{eqn:WFR}.
% % Further, by observation,
% %  there is no legal serialization comprising the above sequence of read-write
% % operations which satisfies the condition  $R^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{'}(x) \preccurlyeq_{\mathit{st}+w} R^{''}(x)$. Thus, the condition in the RHS of  expression $E^S_C$ given in
% % Equation \ref{eqn:WFR} does not hold. %According to the anomaly condition $C$ in Equation \ref{eqn:WFR}, there must not
% %% exist a read operation $r^n(x)$ such that the conditions $\left( R^i F^x W^j F^x R^n \in \mathit{st} \right) \wedge
% %%\left( W^j F^x R^n \in \mathit{st} \right)$ and $v^n = v^i$ are satisfied. Since $r^2(x){1}$ succeeds  $w^2(x,2)$, we can
% %%assign $R^n$ = $R^2$. But, the read operation $r^2(x){1}$ returns a value 1 which was written by $w^1(x,1)$; thus
% %%the condition $v^n = v^i$ holds.
% %Thus, $\mathit{st}_3$ violates %the second condition in
% % %RHS of Equation \ref{eqn:WFR}; hence, it violates
% % WFR consistency.
% % \par Let us consider the session traces \\ $\mathit{st}_4$: $w^1(x,1), r^1(x){1}, w^2(x,2), r^2(x){2}, r^3(x){1}$ %$\mathit{st}_4^{'}$: $r^3(x){2}$, and \\
% % and $\mathit{st}_4^{'}$: $r^4(x){1}, r^5(x){2}$, and demonstrate violation of
% %  MW consistency with them. The above session trace $\mathit{st}_4$  can be transformed in a valid partial order
% %  $\preccurlyeq_{\mathit{st}+w}^1(x)$ = $W^1(x) \preccurlyeq_{\mathit{st}+w} R^1(x) \preccurlyeq_{\mathit{st}+w} R^3(x) \preccurlyeq_{\mathit{st}+w} W^2(x) \preccurlyeq_{\mathit{st}+w} R^2(x)$.  The above session traces comprise a sequence of successive writes $w^1(x,1), w^2(x,2)$ on a common object $x$ followed by a subsequent read $r^3(x){1}$. Hence
% %   it can be expressed as $W^{'}(x) F W^{''}(x) F R^{'}(x) $, thus satisfying the LHS of  expression $E^S_C$ in Equation \ref{eqn:MW}, where $W^{'}(x)$ = $W^1(x)$, $W^{''}(x)$ = $W^2(x)$, and $R^{'}(x)$ = $R^3(x)$.
% %   There is no legal serialization comprising the above sequence of write operations which satisfies the condition in the RHS of Equation \ref{eqn:MW},
% %  i.e., $W^1(x) \preccurlyeq_{\mathit{st}+w} W^2(x)  \preccurlyeq_{\mathit{st}+w} R^3(x)$.  %thus satisfying the first condition in the RHS of Equation \ref{eqn:MW}.
% %%   For the anomaly condition $C$ to hold, there cannot exist a sequence of write operations $w^1(x,1)$ and
% %%    $w^2(x,2)$ followed by a sequence of read operations $r^k$ and $r^l$ such that the following condition holds:
% %%  $\left( \not\exists  {R^k}^{'} F  {R^l}^{'} \in \mathcal{S}_t \right)
% %%   \wedge  \left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
% %%   \left( {v_l}^{'} = {v_i}^{'} \right)$. For the above session trace,
% %%  we assign the operations $r^2(x){2}$ and $r^3(x){1}$ to the read operation $r^k$ and $r^l$. However, the above
% %%  read operations $r^k$ yields $v_k$ = 2, and $r^l$ yields $v_l$ = 1, such that the condition
% %%  $\left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
% %%   \left( {v_l}^{'} = {v_i}^{'} \right)$ holds.
% %   %According to the RHS of Equation \ref{eqn:MW},  there must not exist a read operation $r^n(x)$ that satisfies the
% %%   conditions $ W^i F^x W^j F^x R^n \in \mathit{st}$ and $v^n = v^i$. In other words, any operation that
% %%   follows the above write sequence must not return a value updated by a write operation that precedes the latest write.
% %%   Since the read operation $r^1(x){1}$ succeeds the sequence of writes $W^1 F^x W^2$, $R^n$ = $R^1$. But, $r^1(x){1}$
% %%   returns the value 1; thus, the condition $v^n = v^i$ holds.
% %Thus, $\mathit{st}_4$ violates the RHS of Equation \ref{eqn:MW},
% %    and, in turn, violates MW consistency.
%    First, let us consider a
% session trace $\mathit{st}_1$: $w(x,1), w'(x,2), r(x){2}, r'(x){1}$ to demonstrate how violation of RYW consistency can occur.
% % From the session trace $\mathit{st}_1$, the following LTL expression  \\ $W^1 F W^2 F R^1 F R^2$ follows
% % directly from the temporal order of execution as per the session trace.
%   The session trace
%  $\mathit{st}_1$ can be transformed into the following  partial orders that satisfy Condition 1 in Definition \ref{def:form0}, which also comprise write operations from other
%  clients: \begin{itemize}
%  \item $\preccurlyeq_{\mathit{st}+w}^1$ = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 W'^x_{\mathit{st}}
%   \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}$
%   \item $\preccurlyeq_{\mathit{st}+w}^2$ = $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 R'^x_{\mathit{st}}$
%   \item $\preccurlyeq_{\mathit{st}+w}^3$ = $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 R'^x_{\mathit{st}}$
%   \end{itemize}
%  For $\mathit{st}_1$ to satisfy RYW, there must exist a valid partial order for $\mathit{st}_1$ which satisfies the RHS (i.e., right hand side) of Equation \ref{eqn:RYW} for all write-read pairs in $\mathit{st}_1$ (i.e., for all write follows read sequences in $\mathit{st}_1$) which satisfy the LHS of the specification $E^S_C$ given in Equation  \ref{eqn:RYW}.  In $\mathit{st}_1$, the read operation $r(x){2}$
%  follows the write operation $w(x,1)$, and this temporal order can be expressed by the LTL expression $\square W^x_{\mathit{st}} \rightarrow \lozenge R^x_{\mathit{st}}$; which satisfies the
%  condition given in LHS (i.e., left hand side) of the specification $E^S_C$ given in Equation \ref{eqn:RYW}. %, where $W^i$ = $W^1$, $R^j$ = $R^1$.
%  Only for $\preccurlyeq_{\mathit{st}+w}^1$, the condition $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}$ holds for the above write-read pair. %, which does not hold for .
%  Thus, only $\preccurlyeq_{\mathit{st}+w}^1$ satisfies the RHS of %implies operator $\rightarrow$ in $E^S_C$ , given in
%   Equation \ref{eqn:RYW} for the above write-read pair. %, holds.
%   %$W^k$ preceding  $W^1$ such that the above LTL condition holds.
%   Next, we consider the % sequence in the session trace where the
%    write operation $w(x,1)$ followed by the read operation  $r'(x){1}$ which satisfies the LHS of Equation  \ref{eqn:RYW}. %, expressed by the LTL expression $\square W^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$. %As discussed before, a partial
%   For the partial order $\preccurlyeq_{\mathit{st}+w}^1$, %exists for the session trace such that
%   the condition $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R'^x_{\mathit{st}}$ holds, satisfying the
%   the RHS of Equation \ref{eqn:RYW}.
%   %Also, following the same argument as
% %   above, there does not exist a $w^k$ such that the temporal order represented by the LTL condition $W^k F^x W^1 F^x R^2$ holds.
%   Next, we consider the write operation $w'(x,2)$ followed by the read $r(x){2}$ in the session trace which satisfies the LHS of Equation  \ref{eqn:RYW}.
%   %This implies that the condition $\square W'^x_{\mathit{st}}
% %  \rightarrow \lozenge R^x_{\mathit{st}}$ holds, which in turn, implies that the LHS of the $E^S_C$ condition in Equation \ref{eqn:RYW} holds. %, where $W^x_{\mathit{st}}$ denotes the $W'^x_{\mathit{st}}$ and
%   %$R^x_{\mathit{st}}$ = $R^x_{\mathit{st}}$.
%   Again the partial order $\preccurlyeq_{\mathit{st}+w}^1$ satisfies the condition $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}}$, which in turn, implies that the RHS of the RYW condition is true.
% %  Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does not exist
% %  a write operation $W^k$ such that the LTL conditions $W^k F^x W^i F^x R^j$ and $v_j=v_k$ hold, where $W^i$ = $W^2$
% %  and $R^j$ = $R^1$. Thus, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% % \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
%   %$R^1$ returns a value 2 was written by the write operation $W^1$ which precedes $W^2$.
% %   Thus the condition
% %  $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% % \wedge \left( v^j = v^k \right)$ holds, where $\mathit{st}$ = $\mathit{st}_1$.
%   Next, we consider the write operation $w'(x,2)$  followed by the read $r'(x){2}$ in the session trace, which satisfies the LHS of Equation  \ref{eqn:RYW}. %given as $\square W'^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$.
%   %This implies that the condition %$\square W'^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$
%    %in the LHS of $E^S_C$ specified in Equation \ref{eqn:RYW} holds. %, where $W'^x_{\mathit{st}}$ denotes the operation $w'(x,2)$ and
%   %$R'^x_{\mathit{st}}$ denotes the operation $r'(x){1}$.
%  %Following the above line of reasoning, the partial order $\preccurlyeq_{\mathit{st}+w}^1$ %is the only valid partial order that
%  %satisfies the condition $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}$; thus
%     %the RHS of Equation \ref{eqn:RYW} for this above write-read pair.
%     However, $\preccurlyeq_{\mathit{st}+w}^1$ does not satisfy the condition
%  RHS of Equation  \ref{eqn:RYW} for the above write-read sequence.  %$\square W'^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$. %, where $W'^x_{\mathit{st}}$ denotes the operation $w'(x,2)$ and
%   %$R'^x_{\mathit{st}}$ denotes the operation $r'(x){1}$.
%   %Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does exist
% %  a write operation $W^k$ = $W^1$ such that the LTL condition $W^k F^x W^i F^x R^j$ holds,  where $W^i$ = $W^2$ and
% %  $R^j$ = $R^2$. Further, the read operation
% %  $R^2$ returns a value 1 which was written by the write operation $W^1$ that precedes $W^2$. Thus the condition $v_j=v_k$
% %  holds, and thus, in turn, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% % \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
% %  For anomaly
% %  condition $C$  in Equation \ref{eqn:RYW} to hold, their cannot exist in the global session trace a read operation $r^k$ preceding the read operation
% %  $r^j$ (which is $r^2(x){1}$) and a write operation $w^l$ preceding $w^i$ (which is $w^2(x,2)$ in this case)
% %   such that the LTL condition $\left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big(\left( {v^j}^{'} = {v^l}^{'} \right) \vee
% %\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big)$ hold.
% %However, in the given session trace  $\mathit{st}_1$, there does exist a read $r^1(x){2}$ and a write $w^1(x,1)$, such that
% %conditions $\left(  {v^k}^{'} = {v^i}^{'} \right) $ and $\left( {v^j}^{'} = {v^l}^{'} \right)$ hold, thus, in turn,
% %violating the anomaly condition.
%   %This causes violation of the RHS of Equation  \ref{eqn:RYW},
%   Thus there does not exist a valid partial order that satisfies the RHS of  Equation  \ref{eqn:RYW} for all write-read pairs in $\mathit{st}_1$ which meet the LHS of Equation  \ref{eqn:RYW}. This, in turn, results in violation of the RYW condition for $\mathit{st}_1$.
%   On the other hand,  a session trace $\mathit{st}^{'}_1$: $w(x,1), w'(x,2), r(x){2}, r'(x){2}$ preserves the RYW consistency model. There exists a valid partial order $\preccurlyeq_{\mathit{st}+w}^1$ = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}
%   \preccurlyeq_{\mathit{st}+w}^1 R'^x_{\mathit{st}}$ which satisfies the RHS for all write-read pairs in $\mathit{st}^{'}_1$ of Equation  \ref{eqn:RYW}. %The reads $ r(x){2}$ and $r'(x){2}$ return the value 2 written by the latest write $w'(x,2)$.
%  %In $\mathit{st}_1$, read operations $r^1(x){2}$ and $r^2(x){1}$ follow the $w^2(x,2)$, the latest write operation on $x$,
% %   satisfying the RHS of Equation \ref{eqn:RYW}. However, the value returned by $r^2(x){1}$ is 1, which does not match the
% %    value written by the latest write operation $w^2(x,2)$ preceding $r^2(x){1}$; hence, $S_1 $does not satisfy the
% %    condition $v_m = v_l$ in Equation \ref{eqn:RYW}.  Further, the value written by $w^2(x,2)$ is not overwritten by any
% %     subsequent write preceding $r^2(x){1}$; hence, $S_1$ does not satisfy the condition
% %     $W^j(v_l) F^{o} W^p(v_q) F^{o} R^k{v_m}$ in  Equation \ref{eqn:RYW}. Thus $S_1$ does not satisfy Equation
% %     \ref{eqn:RYW}.
%  \begin{figure}%[t]
%         %\begin{center}
%         \includegraphics[width=3.5in,height=4.5in]
%                     {examplepo.eps} %\vspace{-5em}
%           %\end{center}
%         \caption{Example of a global session trace and an example partial order that %is a superset of a partial order that
%          can be used by each of the ConSpec definitions we studied (except for Sequential Consistency, whose constraints are not met). Some of the ordering constraints are not required by the each of the session guarantees, depending on the type of the pair of operations ordered. Furthermore, the set of operations being considered must be adapted to exclude the reads from the sessions other than the one from the standpoint of which the session guarantees are being upheld. Note that in the case of a read operation that is partially ordered after two concurrent writes, the definition allows us to pick any of the linear extensions of the partial order.}
%         \label{fig:example}
% \end{figure}
%  \par Let us consider a global session trace $\mathit{st}_2$:  $w(x,1)$, $\mathit{st}_2^{'}$: $w'(x,2)$, and $\mathit{st}_2^{''}$: $r(x){1}, r'(x){2}, r''(x){1}$ to illustrate how
%  violation of MR consistency can occur. Since the above session traces comprise write operations followed by multiple reads on common objects, there are read-read sequences that satisfy the condition  in the LHS of Equation \ref{eqn:MR}.
%  The above traces can be transformed into a valid partial order $\preccurlyeq_{\mathit{st}+w}$ =
%  $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'^x_{\mathit{st}}$.  First, let us consider the sequence of read operations $r(x){1}$ and $r'(x){2}$ in $\mathit{st}^2$.
% Using $R^x_{\mathit{st}}$ to denote the operation  $r(x){1}$, and $R'^x_{\mathit{st}}$  to denote $r'(x){2}$, the above sequence of reads directly reduces  to the LHS of the expression of  $E^S_C$ in Equation \ref{eqn:MR}, given by the LTL expression $\square R^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$.
%   The above sequence of reads satisfy the RHS of Equation \ref{eqn:MR}  since $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'^x_{\mathit{st}}$ holds. % thus satisfying
%  %the RHS of the implies operator $\Rightarrow$
%  %in  $E^S_C$ in Equation \ref{eqn:MR}.
%    Next, we consider a sequence of reads $r(x){1}$ followed by $r''(x){1}$ in the above traces. The precedence among the reads in this sequence can be expressed by the LTL expression $\square R^x_{\mathit{st}} \rightarrow \lozenge R''^x_{\mathit{st}}$.
%    Thus, the above sequence satisfies the LHS of expression $E^S_C$ in Equation
%    \ref{eqn:MR}. %, using
%  % $R^x_{\mathit{st}}$ to denote the operation $r(x){1}$ and $R''^x_{\mathit{st}}$  to denote $r''(x){1}$, which, in turn, implies  $\square R^1(x) \rightarrow \lozenge R^3(x) $. % $v_i$ = $v_1$ = 1 and $v_j$ = $v_2$ =1.
%    As already stated, a
%   valid partial order $\preccurlyeq_{\mathit{st}+w}$ exists for the above trace. Trivially,  the condition $\square R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}}$
%   holds in $\preccurlyeq_{\mathit{st}+w}$. Hence, the above sequence of reads satisfies the condition  in the RHS of Equation \ref{eqn:MR}.
%   %Also, $W^m$ and $W^n$ are the only write operations
% %  that can satisfy the condition $W^m F^x W^n F^x R^i F^x R^j \in \mathit{st}$. Hence,
% %  the second condition in the RHS requires that $W^m$ = $W^1$ and $W^n$ = $W^2$, and thus $v_m$ = $v_1$ = 1 and $v_n$ = $v_2$ = 2.
% %  Hence,  $v_n \not= v_i$, which, in turn, implies that the condition $\left( v^i = v^n \right) \wedge \left( v^j = v^m \right)$
% %  $\left( v^i = v^n \right) \wedge \left( v^j = v^m \right)$ holds. This, in turn, second condition in the RHS of
% %  Equation \ref{eqn:MR} holds.
%    Next, we consider the sequence of reads $r'(x){2}$ followed by $r''(x){1}$ in the above traces which satisfies the LHS of Equation \ref{eqn:MR}. %, given
%   %as $\square R'^x_{\mathit{st}} \rightarrow \lozenge R''^x_{\mathit{st}}$.
%    However, the above sequence of reads does not satisfy the RHS of Equation \ref{eqn:MR} since
%   $R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}}$ does not hold.
%     Thus,  the given global session trace does not satisfy the MR consistency model defined in Equation \ref{eqn:MR}.
% %    Further, for the LHS of Equation \ref{eqn:MR} to hold for the above sequence of reads,   $R^i$ = $R^2$ and $R^j$ = $R^3$,
% %   which, in turn, implies $R^2 F R^3$. % $v_i$ = $v_2$ = 2 and $v_j$ = $v_3$ =1.
% %   For the anomaly condition $C$ in Equation \ref{eqn:MR} to hold for the sequence of read operations $r^1(x){1}$ followed by $r^3(x){1}$, there cannot exist write
% %  operations $w^m$ and $w^n$ corresponding to the reads $r^i$ and $r^j$  such that the LTL condition
% %  $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\ \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big)$ holds.
% %   Here, $W^m$ = $W^1$ and $W^n$ = $W^2$, since $W^m$ and $W^n$ are the only write operations in the given session history.
% %   Hence, $v_m$ = $v_1$ = 1 and $v_n$ = $v_2$ = 2. Also, it is given that
% %  $v_i$ = $v_1$ = 1 and $v_j$ = $v_2$ =2. Hence, the conditions $\left( v^i = v^n \right)$ and $ \left( v^j = v^m \right)$
% %  is satisfied; thus, in turn, the above LTL condition is also satisfied.
% % Thus, the violation condition $C$
% %  in Equation \ref{eqn:MR} holds.
%    %Also, $W^m$ = $W^1$ and $W^n$ = $W^2$. Hence,
% %   $v_n$ = $v_i$ and $v_m$ = $v_j$. Thus, the second condition does not hold here.
%     %Hence, the above global session trace violate the MR condition.
%      However, the session trace $\mathit{st}^{'}_2$:  $w(x,1)$, $\mathit{st}_2^{'}$: $w'(x,2)$, and $\mathit{st}_2^{''}$: $r(x){1}, r'(x){2}, r''(x){2}$ satisfies the MR definition. There exists a valid partial order  $\preccurlyeq_{\mathit{st}+w}'$ =
%  $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}'  W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R''^x_{\mathit{st}}$, such that $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R'^x_{\mathit{st}}$, $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R''^x_{\mathit{st}}$, and $R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R''^x_{\mathit{st}}$ hold. This, in turn, implies that all read-read sequences which satisfy LHS of  Equation \ref{eqn:MR}, also satisfies the RHS of Equation \ref{eqn:MR}.
%    %\par
%  % In $S_2$, $r^1(x){1}$ returns a value 1, whereas it should have returned 2, which is the value written by the latest write operation $w^2(x,2)$ preceding $r^1(x){1}$. Thus, $S_2$ does not satisfy the condition $v_l = v_m$. Since there are not write operations overwriting the latest write operation $w^2(x,2)$ preceding each read, the condition $W^j(v_l) F^{o} W^x(v_y) F^{o} R^k(v_m)$ holds. Following the same line of argument, we can show that $S_2$ does not
% % satisfy any of the  conditions in RHS of Equation \ref{eqn:MR}. Hence, $S_2$ does not satisfy Equation \ref{eqn:MR}.
% \par  We consider the global session trace comprising the following session traces: \\ $\mathit{st}_3$: $w(x,1)$, $\mathit{st}_3^{'}$: $r(x){1}, w'(x,2)$, and
%  $\mathit{st}_3^{''}$: $w''(x){3}, r'(x){3}, w'''(x,2), r''(x){2}, r'''(x){3}$ to show how
%  WFR consistency can be violated. The above session traces can be transformed into the following two valid partial orders:
%  $\preccurlyeq_{\mathit{st}+w}$  = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'^x_{\mathit{st}}$ %\preccurlyeq_{\mathit{st}+w} W^2(x) \preccurlyeq_{\mathit{st}+w} R^2(x)$
%   and
%   $\preccurlyeq_{\mathit{st}+w}^{'}$  = $W''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  R'''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  W''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  W'''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}}  \preccurlyeq_{\mathit{st}+w}  W^x_{\mathit{st}} $. In the above traces, the write operation $w'''(x,2)$ follows
%   the read operation $r'(x){3}$, and is then followed by read operation $r'''(x){3}$. %, and can be expressed as $R^1(x) F W^2(x) F R^4(x)$.
%   The above sequence of operations satisfies
%  the condition $\square R'^x_{\mathit{st}} \rightarrow \lozenge W'''^x_{\mathit{st}} \rightarrow \lozenge R'''^x_{\mathit{st}}$. %, where $R^{'}(x)$ = $R^2(x)$, $W^{'}(x)$ = $W^4(x)$, $R^{''}(x)$ = $R^4(x)$. Hence,
% % the above traces satisfy the
% % condition $R^i F W^j$ in the LHS of Equation \ref{eqn:WFR}.
%  Further, by observation,
%   there is no valid partial order comprising the above sequence of read-write
%  operations which satisfies the condition  $R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'''^x_{\mathit{st}}$. Thus, the condition in the RHS of  expression $E^S_C$ given in
%  Equation \ref{eqn:WFR} does not hold. %According to the anomaly condition $C$ in Equation \ref{eqn:WFR}, there must not
% % exist a read operation $r^n(x)$ such that the conditions $\left( R^i F^x W^j F^x R^n \in \mathit{st} \right) \wedge
% %\left( W^j F^x R^n \in \mathit{st} \right)$ and $v^n = v^i$ are satisfied. Since $r^2(x){1}$ succeeds  $w^2(x,2)$, we can
% %assign $R^n$ = $R^2$. But, the read operation $r^2(x){1}$ returns a value 1 which was written by $w^1(x,1)$; thus
% %the condition $v^n = v^i$ holds.
% Thus, $\mathit{st}_3$ violates %the second condition in
%  %RHS of Equation \ref{eqn:WFR}; hence, it violates
%  WFR consistency.
%   On the other hand, session traces $\mathit{st}^{''}_3$: $w(x,1)$, $\mathit{st}_3^{'''}$: $r(x){1}, w'(x,2)$, and
%  $\mathit{st}_3^{'''}$: $w''(x){3}, r'(x){3}, w'''(x,2), r''(x){2}, r'''(x){2}$ satisfy WFR consistency since a valid partial order $\preccurlyeq_{\mathit{st}+w}^{''}$  exists, such that $\preccurlyeq_{\mathit{st}+w}^{''}$  = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  W'''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'''^x_{\mathit{st}}  \preccurlyeq_{\mathit{st}+w}  W''^x_{\mathit{st}}  \preccurlyeq_{\mathit{st}+w}  R'^x_{\mathit{st}} $  holds for all read-write-read sequences in $\mathit{st}_3^{'''}$ that meets the LHS of Equation \ref{eqn:WFR}.
%  \par Let us consider the session traces \\ $\mathit{st}_4$: $w(x,1), r(x){1}, w'(x,2), r'(x){2}, r''(x){1}$ %$\mathit{st}_4^{'}$: $r^3(x){2}$, and \\
%  and $\mathit{st}_4^{'}$: $r'''(x){1}, r''''(x){2}$, and demonstrate violation of
%   MW consistency with them. The session trace $\mathit{st}_4$  can be transformed in a valid partial order
%   $\preccurlyeq_{\mathit{st}+w}^1(''')$ = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'^x_{\mathit{st}}$.  The above session traces comprise a sequence of successive writes $w(x,1), w'(x,2)$ on a common object $x$ followed by a subsequent read $r''(x){1}$. This sequence of writes and reads can be expressed as $\square W^x_{\mathit{st}} \rightarrow \lozenge W'^x_{\mathit{st}} \rightarrow \lozenge R''^x_{\mathit{st}} $, which satisfy the LHS of Equation \ref{eqn:MW}. %, where $W^x_{\mathit{st}}$ = $W^1(x)$, $W^{''}(x)$ = $W^2(x)$, and $R^{'}(x)$ = $R^3(x)$.
%    However, there is no valid partial order comprising the above sequence of write operations which satisfies the RHS of Equation \ref{eqn:MW},
%   i.e., there is no  valid $ \preccurlyeq_{\mathit{st}+w} $ such that $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'^x_{\mathit{st}}  \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}}$.  %thus satisfying the first condition in the RHS of Equation \ref{eqn:MW}.
% %   For the anomaly condition $C$ to hold, there cannot exist a sequence of write operations $w^1(x,1)$ and
% %    $w^2(x,2)$ followed by a sequence of read operations $r^k$ and $r^l$ such that the following condition holds:
% %  $\left( \not\exists  {R^k}^{'} F  {R^l}^{'} \in \mathcal{S}_t \right)
% %   \wedge  \left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
% %   \left( {v_l}^{'} = {v_i}^{'} \right)$. For the above session trace,
% %  we assign the operations $r^2(x){2}$ and $r^3(x){1}$ to the read operation $r^k$ and $r^l$. However, the above
% %  read operations $r^k$ yields $v_k$ = 2, and $r^l$ yields $v_l$ = 1, such that the condition
% %  $\left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
% %   \left( {v_l}^{'} = {v_i}^{'} \right)$ holds.
%    %According to the RHS of Equation \ref{eqn:MW},  there must not exist a read operation $r^n(x)$ that satisfies the
% %   conditions $ W^i F^x W^j F^x R^n \in \mathit{st}$ and $v^n = v^i$. In other words, any operation that
% %   follows the above write sequence must not return a value updated by a write operation that precedes the latest write.
% %   Since the read operation $r^1(x){1}$ succeeds the sequence of writes $W^1 F^x W^2$, $R^n$ = $R^1$. But, $r^1(x){1}$
% %   returns the value 1; thus, the condition $v^n = v^i$ holds.
% Thus, $\mathit{st}_4$ violates the RHS of Equation \ref{eqn:MW},
%     and, in turn, violates MW consistency.
%     In contrast, the session traces $\mathit{st}^{''}_4$: $w(x,1), r(x){1}, w'(x,2), r'(x){2}, r''(x){2}$ %$\mathit{st}_4^{'}$: $r^3(x){2}$, and \\
%  and $\mathit{st}_4^{''}$: $r'''(x){1}, r''''(x){2}$ satisfy MW consistency since there exists a valid partial order $\preccurlyeq_{\mathit{st}+w}^{'''}$ = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''''^x_{\mathit{st}}$. which satisfies the RHS for all pairs of write sequences that satisfy the LHS of Equation \ref{eqn:MW}. Thus,  MW holds for $\mathit{st}^{''}_4$ .
%  \par Next, let us analyse a global session trace comprising the following session traces: $\mathit{st}_1$: $w(x,1)$, %r^1(x){2}$,
%  $\mathit{st}_2$: $r(x){1}, w'(x,2)$, %, r^3(x){1}$,
%  and  $\mathit{st}_3$: $r'(x){2}, r''(x){1}$. The list of valid partial orders, comprising all operations in $\mathcal{S}_t$, which satisfy Condition 1 in Definition \ref{def:form0} are given as follows.
%  \begin{itemize}
%  \item [$\preccurlyeq^1$ =] $W^x_{\mathit{st}}   \preccurlyeq R^x_{\mathit{st}}  \preccurlyeq R''^x_{\mathit{st}}  \preccurlyeq W'^x_{\mathit{st}}   \preccurlyeq R'^x_{\mathit{st}} $
%  \item [$\preccurlyeq^2$ =] $ W^x_{\mathit{st}}   \preccurlyeq R''^x_{\mathit{st}}  \preccurlyeq R^x_{\mathit{st}}   \preccurlyeq W'^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}}$
%  \item [$\preccurlyeq^3$ =] $   W'^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}} \preccurlyeq  W^x_{\mathit{st}}  \preccurlyeq R^x_{\mathit{st}} \preccurlyeq R''^x_{\mathit{st}}$
%  \item [$\preccurlyeq^4$ =] $  W'^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}} \preccurlyeq W^x_{\mathit{st}}  \preccurlyeq R''^x_{\mathit{st}} \preccurlyeq R^x_{\mathit{st}}  $
%  \end{itemize} %There are successive operations with direct precedence relation on the object $x$, namely operations $w^2(x,2)$ and $r^3(x){1}$ in $\mathit{st}_5$; hence $\mathit{st}_5$,
%  %satisfies LHS of the expression $E^S_C$ specified in Equation \ref{eqn:Causal}.
%  Since the session trace  $\mathit{st}_1$ comprises a single write it vacuously satisfies the Causal consistency condition  in Equation \ref{eqn:Causal}, given that this condition constrains pairs of operations in the trace.
%    Next, we consider the  session trace $\mathit{st}_2$ in $\mathcal{S}_t$, comprising operations $r(x){1}$ and $w'(x,2)$. $\mathit{st}_2$ only matches the LTL condition $ \square\;  {\mathit{O}}^x_{\mathit{st}} \rightarrow \lozenge {\mathit{O}}'^x_{\mathit{st}}$ for ${\mathit{O}}^x_{\mathit{st}}$ = $r(x){1}$ and  ${\mathit{O}}'^x_{\mathit{st}}$ = $w'(x,2)$.  From the above list of valid partial orders, only $\preccurlyeq^1$ and $\preccurlyeq^2$ satisfy the  condition ${\mathit{O}}^x_{\mathit{st}} \preccurlyeq {\mathit{O}}'^x_{\mathit{st}}$ where ${\mathit{O}}^x_{\mathit{st}}$ = $r(x){1}$ and  ${\mathit{O}}'^x_{\mathit{st}}$ = $w'(x,2)$. Thus, $\mathit{st}_2$ reduces the set of valid partial orders to the set $\preccurlyeq^1, \preccurlyeq^2$.
% % also satisfies the Causal consistency condition in Equation \ref{eqn:Causal}.  % \preccurlyeq W^2(x) \preccurlyeq R^1(x) \preccurlyeq R^4(x)$.
%   %First, let us consider the sequence of operations
%  %$w^1(x,1)$ and $r^1(x){2}$ in the above traces, given by the LTL expression $W^1(x) F R^1(x)$. The above expression satisfies
% %the condition $\mathit{Op}^i(x) F \mathit{Op}^j(x)$, where $\mathit{Op}^i(x)$ = $W^1(x)$ and $\mathit{Op}^j(x)$ = $R^1(x)$;
% % thus this sequence satisfies the LHS of the implies operator $\Rightarrow$ in $E^S_C$ in Equation \ref{eqn:Causal}. The above sequence of
%  %writes and reads satisfies the condition $W^1(x) \preccurlyeq R^1(x)$, thus satisfying the first condition the RHS of
%  %the implies operator $\Rightarrow$ in expression $E^S_C$ in Equation \ref{eqn:Causal}.
%  %For the second condition in the RHS of
% % Equation \ref{eqn:Causal} to hold, there cannot exist write  operations $W^m$ such that the LTL conditions
% %   $W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}$ and $v^j = v^m$ hold.
% % Since there is no such $W^m$ preceding $\mathit{Op}^i$, the second condition in the RHS of Equation \ref{eqn:Causal}
% % holds for the above sequence of operations.
%  %Following the same line of argument, the sequence of operations
%   %$w^1(x,1)$ and $r^2(x){1}$, $w^1(x,1)$ and $r^3(x){1}$, $w^1(x,1)$ and $r^4(x){2}$, $w^1(x,1)$ and $r^5(x){1}$
%   %and $w^1(x,1)$ and  $w^2(x,2)$ satisfy the LHS and RHS of $E^S_C$ in the Equation \ref{eqn:Causal}. Next,
%   %Let us consider
%   Finally, let us consider the session trace $\mathit{st}_3$  in $\mathcal{S}_t$, comprising operations $w'(x,2)$ and $r''(x){1}$. Again, $\mathit{st}_3$ matches the LTL condition $ \square\;  {\mathit{O}}'^x_{\mathit{st}} \rightarrow \lozenge {\mathit{O}}''^x_{\mathit{st}}$ for ${\mathit{O}}'^x_{\mathit{st}}$ = $w'(x,2)$ and  ${\mathit{O}}''^x_{\mathit{st}}$ = $r''(x){1}$.  From the list of valid partial order given above, the only valid partial orders which satisfy the condition ${\mathit{O}}'^x_{\mathit{st}} \preccurlyeq {\mathit{O}}''^x_{\mathit{st}}$ are  $\preccurlyeq^3$ and $\preccurlyeq^4$.
% Putting together the previous requirements, we can see that only the partial orders $\preccurlyeq^1$ and $\preccurlyeq^2$ meet the condition in Equation \ref{eqn:Causal}) for $\mathit{st}_1$ and $\mathit{st}_2$, whereas only $\preccurlyeq^3$ and $\preccurlyeq^4$ meet the same condition for $\mathit{st}_3$. Thus, there does not exist a single valid partial order that satisfies the causal consistency  condition for all the session traces in $\mathcal{S}_t$. %; causing a violation of Causal consistency.
%  %The precedence between $w^2(x,2)$ and $r^3(x){1}$ in $\mathit{st}_5$ can be expressed as $W^2(x) F R^3(x)$.
% %Thus, the above sequence satisfies LHS of $E^S_C$ in the Equation \ref{eqn:Causal}. There does not exist a legal serialization %that  satisfies the condition $W^2(x) \preccurlyeq R^3(x)$, violating the RHS of $E^S_C$ in Equation \ref{eqn:Causal}.
% %  Let us consider the anomaly condition $C$ in Equation \ref{eqn:Causal} for the write and read operations $w^2(x,2)$ (which is
% %  $w^i$ in this case) and $r^3(x){1}$ (which is $r^j$ in this case). Since  $w^2(x,2)$ is followed by $r^3(x){1}$ in the session trace, they satisfy the LHS of the condition
% %  $C$. For the RHS of $C$ to hold, there cannot a exist write operations $w^m$ preceding the write $w^2(x,2)$ such that the
% %  LTL condition $\left( {v^j}^{'} = {v^m}^{''} \right) \vee
% % \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
% %\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big)$
% % holds.
% % We can assign $W^m = W^1$ since $w^1(x,1)$ precedes $w^2(x,2)$. Subsequently the condition \\ $\left( {v^j}^{'} = {v^m}^{''} \right)$
% % holds (since $R^j$ = $R^3$ and $v_j$ = 1 in this case). Hence, the RHS of $C$ is satisfied for Equation \ref{eqn:Causal} for the above sequence of operations.
% %Also, we can assign $W^m$ = $W^1$,
% %   $\mathit{Op}^i$ = $W^2$, and $\mathit{Op}^j$ = $R^3$, such that the LTL conditions
% %   $W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}$ holds. Further, $v_j$ = $v_m$ = 1, violating
% %   the condition $\not\exists  \mathit{st} \left( W^m F^x \mathit{Op}^i F^x \mathit{Op}^j \in \mathit{st}
% %   \right) \wedge \left( v^j = v^m \right)$, violating the RHS of Equation \ref{eqn:Causal}.
% % Hence, the above global session trace is in violation of Causal consistency.
% % \forall i, j, k, o, \mathit{st} \big( \exists \mathit{Op}^k \in  \mathit{st}
% %\big( \mathit{Op}^i F \mathit{Op}^j \vee \\ \left( \mathit{Op}^i F \mathit{Op}^k  \wedge
% %\mathit{Op}^k F \mathit{Op}^j \right)
% %\vee \big( \left( \mathit{Op}^i = W^i \right) \wedge \left( \mathit{Op}^j = R^j \right) \wedge \\
% %\left( \left( v_i = v_j \right) \vee \left( \left( v_i = v_k \right)
% % \wedge \left( v_k = v_j \right) \right) \big) \right) \big)
% %\\ \Rightarrow \exists \mathit{Si}_p \left( \forall \mathit{Op}^i F \mathit{Op}^j \in \mathit{Si}_p \right)
% %\wedge \not\exists  \mathit{st} \left( W^m F \mathit{Op}^i F \mathit{Op}^j \in \mathit{st} \right) \\
% %\wedge \left( v^j = v^m \right) \big)
%  %The operation $r^1(x){2}$ returns 2, which does not match the write operation
% % $w^1(x,1)$ that directly preceded $r^1(x){2}$. Similarly, $r^3(x){1}$  does not return the correct value written by
% % the latest write $w^2(x,2)$ which directly precedes $r^3(x){1}$. Thus, $S_3$ does not satisfy the conditions in Equation
% % \ref{eqn:Causal}.
% % \par All the above session traces violate the specification of Sequential Consistency (SC), given in Equation
% % \ref{eqn:SC}. Consider the session traces $\mathit{st}_6$, $\mathit{st}_6^{'}$, and $\mathit{st}_6^{''}$, which can be transformed into the valid partial order $\preccurlyeq$. %, which is, in this case, equivalent to  $\preccurlyeq_{\mathit{st}+w}$ in absence of writes from other
% % % client applications in the given session history (see above).
% %  The sequence of operations $w^1(x,1)$ and
% % $r^1(x){2}$ in the above session trace satisfies the LHS of the expression $E^S_C$, i.e., the condition
% % $\mathit{Op}^i(x) X \mathit{Op}^j(x) $ holds where $\mathit{Op}^i(x) = W^1(x)$ and $\mathit{Op}^j(x) = W^2(x)$ . %Since %$v_i \not= v_j$,
% %  The above sequence of write and read operations
% % %do not satisfy the condition  in the RHS of $E^S_C$, i.e., it
% % violates the condition $W^1(x) \preccurlyeq R^1(x)$.
% % % For the anomaly condition $C$ to hold for the above sequence of operations, let us consider the
% %% sequence of operations $w^2(x,2)$ and $r^3(x)1$. For the RHS of $C$ to hold, there cannot a exist write operations $r^k$ following the read $r^3(x)1$ such that the
% %%  LTL condition $\big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge
% %% \not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \big) \\
% %% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$
% %% holds.
% %% We can assign $r^k = r^4$ since $r^4(x)2$ follows $r^3(x)1$. Subsequently the conditions \\ $\left( {v^k}^{''} = {v^i}^{''} \right)$
% %%and $\left( {v^j}^{'} \not= {v^i}^{'} \right)$ holds, since $r^j$ yields $v_j$ = 1, and
% %% $r^k$ yields $v_k$ = 2.
% % Thus, the above session trace violates the anomaly condition in Equation \ref{eqn:SC}, violating SC.
% %  \par Consider a group of 2 clients (or processors), namely $\mathit{Cl}_1$ and $\mathit{Cl}^2$, respectively.  Let us
% %  consider  that operations are invoked from the above 2 clients, and a session trace  $\mathit{st}_6$ is
% %  collected as follows.
% %  $\mathit{st}_6$: $w^1(x,1), r^1(y){1}$, $\mathit{st}_6^{'}$: $w^2(y,1), r^2(x){2}$. % In
% %%   $\mathit{st}_6$, the order of write operations $w^1(x,1)$ and $w^2(y,1)$ are different in each of the
% %%  2 session traces. In $\mathit{st}^2$, $r^2(x){1}$ returned while $w^1(x,1)$ did not yet execute. In
% %%  $\mathit{st}_1$, $w^1(x,1)$ executed but $r^2(x){1}$ did not execute.
% %  For the above session trace to satisfy TSO consistency, the condition \\
% %  $\left( {W^i}^{'}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right) \wedge
% %    \left( {v_j}^{''} \not= {v_i}^{'} \right)  \wedge \\
% %  %\big( \not\exists \big( \left({R^k}(x)^{'} \in \mathit{st}^{'} \right) \wedge  \\
% %  \left( {R^k}^{''}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right)
% %     \wedge \left( {v_k}^{''} \not= {v_i}^{'} \right)  \\
% %     \wedge
% % %\not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
% %\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right)  \wedge
% %%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
% %\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) %\big) \\
% %\wedge \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \\
% %\big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee
% %\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)  \wedge \\
% % \not\exists  {W^m}^{'} \left( {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big)$
% %  must hold. In the above session traces, let us assign the operation  $w^1(x,1)$ as $w^i$. $r^2(x){2}$ occurs in another session trace, and thus invoked was from a different client. Further,
% %  $r^2(x){2}$ follows $w^1(x,1)$ in the global session order. Hence we can assign the operation
% %  $r^2(x){2}$ as $r^j$. Since $r^2(x){2}$ returns 2 instead of 1, the condition ${v_j}^{''} \not= {v_i}^{'} $ does not hold.
% %  Also, there doesn't exist an operation $r^k$ preceding $r^2(x){2}$ that satisfies the condition ${v_k}^{''} \not= {v_i}^{'} $.
% %  Thus, the given session trace violates Equation \ref{eqn:TSO}.
% On the other hand, a global session trace comprising the following session traces $\mathit{st}'_1$: $w(x,1)$, %r^1(x){2}$,
%  $\mathit{st}'_2$: $r(x){1}, w'(x,2)$, %, r^3(x){1}$,
%  and  $\mathit{st}'_3$: $r'(x){1}, r''(x){2}$ satisfies Causal consistency. There exists a valid partial order  $\preccurlyeq$ such that $W^x_{\mathit{st}}   \preccurlyeq R^x_{\mathit{st}}  \preccurlyeq R'^x_{\mathit{st}}  \preccurlyeq W'^x_{\mathit{st}}   \preccurlyeq R''^x_{\mathit{st}} $ holds, i.e.,  $\preccurlyeq$ satisfies the RHS of Equation \ref{eqn:Causal} for all pairs of operations which satisfy the LHS.
%     \par For PC, consider
%     % two client applications (or processors), namely $\mathit{Cl}_1$ and $\mathit{Cl}^2$,
%   %respectively.  First, consider
%    the  following global session trace discussed by Ahamad et al. in \cite{Ahamad:1993:PPC:165231.165264} which is the reference for our definition of PC. $\mathit{st}_6$: $w(x,0), w(y,0)$, $\mathit{st}_6^{'}$:  $ r(y){0}, r(x){1}$, and $\mathit{st}_6^{'}$:  $ r'(x){1}, r''(x){0}$. There exists following two valid legal serializations for which the order of the writes are different.   $\preccurlyeq_{\mathit{st}+w}^{'}$  = $R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  W^y_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^y_{\mathit{st}}$ and $\preccurlyeq_{\mathit{st}+w}^{''}$  = $W'^y_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^y_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}  R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R''^x_{\mathit{st}}$. Hence the above session trace is in violation of the PC condition.
%    For the converse case, consider a session trace collected by executing operations on the above client  applications as follows.   $\mathit{st}_7$: $w(x,1), w'(x,3)$, $\mathit{st}_7^{'}$:  $ r(x){1}, r'(x){3}$,    %$\mathit{st}_7^{'}$: $r^1(x){1}$,
%     $\mathit{st}_7^{''}$:
%   $w(y){1}, w'(y){2}$, and $\mathit{st}_7^{''}$:
%   $r(y){1}, r(y){2}$.
% %  To satisfy the PC consistency, any sequence of write operations $w^i$ and $w^j$ invoked by a client must satisfy
% %  the condition $\big(\not\exists \left( {W^i}^{'} F {W^j}^{'} \right) \wedge
% %  \left( \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
% %  \left( {R^k}^{'} F {R^l}^{'} \in \mathit{st}^{'} \right) \big)
% % \big( \left( v_k^{''} = v_j^{'} \right) \wedge \left( v_l^{'} = v_i^{'} \right)\big)$. Thus, there must not exists a sequence of
% % reads $r^k$ and $r^l$ such that the condition  $\left( v_k^{''} = v_j^{'} \right) \wedge \left( v_l^{'} = v_i^{'} \right)$
% % holds.
%   The above session traces satisfy PC %the write operations  are %executed according to the precedence order
%  % $w(x,1)$ followed by $ w'(y,1)$. %, hence we assign $w^1(x,1)$ and $ w^2(y,1)$ as $w^{'}(x)$ and $w^{'}(y)$. Also, let us assign
%   %the sequence of read operations $r(x){1}$  and $r^2(y){1}$ as $r^k(x)$ and $r^l(x)$, respectively.
%    since results of the write operations are observed by corresponding read operations on the respective objects in an identical order in all processors.
% %   However, in the given session trace, the client application
% %  $\mathit{Cl}_2$ observes the above writes out of order with $\mathit{Cl}_1$. Since  $r(y){1}$ executes before $r'(x){1}$ in the above session
% %  trace $\mathit{st}_6^{'}$, $\mathit{Cl}_2$ observes the result of $w'(y,1)$ before observing result of $w(x,1)$ which contradicts the order $r(y){1}, r'(x){1}$ in $\mathit{Cl}_1$.
%  \par Figure~\ref{fig:example} shows an example execution where the global session trace contains two sessions, each with three operations (two writes followed by a read). This global session trace meets all the consistency levels we defined in the previous section with the exception of sequential consistency. The right hand side of the figure shows a partial order that %is a superset of what
%   can be used to support the execution (i.e., meets condition (1) of the ConSpec general definition), and that also meets the constraints ($E^S_C$) specified by the consistency levels we presented except sequential consistency. For sequential consistency, the constraints would require the partial order to be a total order, which is impossible to achieve while also obeying the session order and explaining the results that are observed according to the sequential specification of a read/write interface. This is because one would have to serialize both reads before the respective writes of value 99, but that would be impossible to achieve in a total order that respects the session orders.

\section{Rewriting the CAP Theorem in terms of ConSpec}\label{sec:cap}
The CAP conjecture was initially stated informally as the impossibility of simultaneously achieving strong Consistency, Availability, and Partition tolerance in a replicated system~\cite{brew:cap}. When this was subsequently proven by Gilbert and Lynch~\cite{Gilbert:2002:BCF:564585.564601}, these three properties were stated precisely, and, in this context, strong consistency was defined as atomicity (or linearizability~\cite{Herlihy:1990:LCC:78969.78972}).

The fact that the original proof of CAP is restricted to linearizability raises the question of whether CAP holds using other definitions from
 the wide array of consistency models supported by an increasingly large set of storage systems that propose new consistency definitions.
 In this section, we rewrite the CAP theorem in terms of ConSpec to precisely define the class of consistency models that can and cannot be implemented in a highly-available, partition-tolerant way.




To begin with, we need a helper definition to enumerate all admissible partial orders for a given restriction condition $E^S_C$ and set of operations in a global session invocation trace $\mathcal{S}_{it}$.

\begin{definition}[Partial order enumeration] \label{def:allpos}
Given a global session invocation trace $\mathcal{S}_{it}$ and a restrictive condition $E^S_C$
for a ConSpec definition, we define the partial order enumeration
of this session invocation trace and condition, $\Pi(\mathcal{S}_{it},E^S_C)$, as
the set of partial orders over the elements of any compatible global session trace $\mathcal{S}_{t}$ that are valid
under $E^S_C$, i.e.:


$\Pi(\mathcal{S}_{it},E^S_C) \equiv  \{\preccurlyeq: \exists \mathcal{S}_{t} \left(  E^S_C\; \vDash \; \left( {\mathcal{S}_{t}}, \preccurlyeq \right) \wedge \mathcal{S}_{t}\bowtie \mathcal{S}_{it} \right) \}$
\end{definition}

This allows us to define the following necessary and sufficient condition
for a consistency model to have an available and partition tolerant
implementation.

\begin{theorem}[Generalized CAP theorem]\label{thrm:capan}
In an asynchronous system, it is possible to implement a consistency model $E^S_C$ while simultaneously providing availability and partition tolerance if and only if for any global session invocation trace $\mathcal{S}_{it}$ and all of its partial orderings that are allowed by $E^S_C$, when you consider the set of maxima of each partial order, it is always possible to make them depend only on the previous operation in the same session and still obtain a valid partial order, i.e., the following holds:

%there exists a corresponding partial order enumeration that does not constrain elements of different sessions according to the respective partial order, i.e.:

%\noindent $\forall \mathcal{S}_{it} ~ \forall \preccurlyeq \in \Pi(\mathcal{S}_{it},E^S_C) ~ \forall o \in max(\mathcal{S}_{it}, \preccurlyeq) ~ (\textsc{RemoveAllExceptSession}(\preccurlyeq,o) \in \Pi(\mathcal{S}_{it},E^S_C) ~ ) $
 $\forall \mathcal{S}_{it} \; \forall \preccurlyeq \in \Pi(\mathcal{S}_{it},E^S_C) \; \forall o \in max(\preccurlyeq) \\ (\textsc{RemoveAllExceptSession}(\preccurlyeq,o) \in \Pi(\mathcal{S}_{it},E^S_C) ) $

where we define {\sc RemoveAllExceptSession} as a partial order where the maximum $o$ is only directly ordered after prior operations in the same session, i.e.:

\noindent {\sc RemoveAllExceptSession}$(\preccurlyeq,o(x)) \equiv \; \preccurlyeq \setminus \{ \langle o'(x),o(x) \rangle$ , where $\langle o'(x),o(x) \rangle$ belongs to the transitive reduction of $\preccurlyeq$, and $o'(x)$ does not belong to the same session as $o(x)\}$.


%$\forall \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t ~ \exists \preccurlyeq \in \Pi(\mathcal{S}_t,E^S_C) ~ \forall o, o' \in \mathcal{S}_t (o \in \mathit{st} \wedge o' \in \mathit{st}^{'} \wedge \mathit{st} \not= \mathit{st}^{'} \Rightarrow o \not\preccurlyeq o' \wedge o' \not\preccurlyeq o)$

 \end{theorem}


%% to take into account this wide array of consistency models. Here, we analyze
%%  the specifications of consistency models, and derive the condition that makes a particular consistency model
%%  CAP-strong, i.e., strong enough to be bounded by the constraints of CAP theorem, as follows. First, we state and prove the condition for a consistency model to be CAP-strong, and then we state and prove the opposite case, i.e., we prove the condition for a consistency model to be CAP-weak.  %. We rewrite CAP as follows.
% First, we define a property called Global Write Order per Object (GWO) which can be imposed by a partial order $\preccurlyeq$ specified  by a ConSpec specification (refer to \ref{def:form0}).  GWO requires that all clients executing in a system observe write operations on each data object according to a global order, i.e., writes to each data object follow a common precedence order in all session traces.
%\begin{definition}{Global Write Order per Object (GWO):}\label{def:gwo}
%Global Write Order per Object (GWO)  is a property which requires a global order among results of write operations to each object across all clients in a system. A partial order $\preccurlyeq$ satisfies GWO if $\preccurlyeq \; = \; \forall  x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, w(x,v), w^{'}(x,v^{'}) \in {\mathcal{O}_{St}}  \left( {W}^{'}  \preccurlyeq_{st} {W}^{''} \wedge {W}^{'}  \preccurlyeq_{st}^{'} {W}^{''} \right),$ where $\preccurlyeq_{st}$ and $\preccurlyeq_{st}^{'}$ are the restriction of the partial order  $\preccurlyeq$ to operations from a pair of clients, observed in the respective session traces $\mathit{st}$ and $\mathit{st}^{'}$.
%\end{definition}
%In light of the above GWO property given in Definition \ref{def:gwo}, we restate the CAP theorem as follows.
%\begin{theorem}[Extended CAP theorem]
%It is impossible for a storage system to satisfy a consistency model that enforces a GWO  among write operations to each data object across different clients executing on the system, while simultaneously providing high availability and partition tolerance.
%% It is impossible for a storage system to satisfy a consistency model that enforces restrictions on order  among the  results of operations performed by different clients executing on the system, while simultaneously providing high availability and partition tolerance.
% \end{theorem} \label{th:cap}
% To elaborate, if a partial order enumeration exists for the specification  $E^S_C$  of a consistency model $\mathcal{C}$  that imposes constraints on operations from different sessions (i.e., clients),  $\mathcal{C}$ is regarded as a CAP-strong consistency model.   For instance, the consistency models Causal, SC, PC, and TSO are CAP-strong, since any valid $\mathcal{S}_t$ for  these consistency models require the existence of a valid partial order, hence a valid partial order enumeration, comprising operations performed from different sessions. Hence, according to Theorem \ref{thrm:cap}, these consistency models can not be implemented in a highly available and partition tolerant manner.
 %On the other hand, the specifications for RYW, MR, WFR, and  MW  imply that a partial order $\preccurlyeq_{\mathit{st}+w}$ must exist for any $\mathcal{S}_t$ that follow these models, comprising only operations performed from a given session, i.e., they do not consider results of reads from other clients, performed by a given client in a global execution is regarded as CAP-weak. %Since they do not consider results of reads from other clients in the partial order $\preccurlyeq_{\mathit{st}+w}$,  they do not impose restrictions on the results of writes across all clients.
  % To elaborate, if the specification $E^S_C$ (following the generic specification format given in Definition \ref{def:form0}) of a consistency model imposes a partial order $\preccurlyeq$ among results observed by pairs of operations performed by different clients executing on underlying storage system (i.e., among  operations from different clients comprised in a global execution represented by a global session trace $\mathcal{S}_t$), that consistency model is regarded as a CAP-strong consistency model. In other words, for a CAP-strong consistency model, Condition 1 in  Definition \ref{def:form0} can be rewritten as follows.
%  The condition $\forall \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, {\mathit{o}} \in \mathit{st}, {\mathit{o}}^{'} \in \mathit{st}^{'}: {\mathit{Op}}^{'} \preccurlyeq {\mathit{Op}}^{''} \vee {\mathit{Op}}^{''} \preccurlyeq {\mathit{Op}}^{'}$
% must hold,  where local session traces
%  $\mathit{st}$ and $\mathit{st}^{'}$  comprise results observed for operations performed by clients $\mathit{Cl}_1$ and $\mathit{Cl}_2$, respectively. %, represented by the observed global session trace
%%  $\mathcal{S}_t$.
%On the other hand, a consistency model that imposes a partial order $\preccurlyeq$ only among results observed by operations performed by a single client  in a global execution is regarded as CAP-weak. It directly follows from Theorem \ref{th:cap} that the CAP-weak condition, in turn,
% implies that the specified partial order $\preccurlyeq$ as per Definition \ref{def:form0} must be a partial order comprising only operations from a given client. In other words, a CAP-weak consistency model restricts a partial order $\preccurlyeq_{st}$, comprising results observed in  a given session trace $\mathit{st}$ (comprising operations performed by a single client), or a partial order $\preccurlyeq_{\mathit{st}+w}$ comprising operations performed by a single client as well as all writes from other clients (since writes alone from the other clients do not have any implication with respect to the observed results,  $\preccurlyeq_{\mathit{st}+w}$ can be considered as  partial order over operations from he given client only).  %Next, we state the reverse of CAP theorem.

%%{\bf [RR: Side note: below, the global session trace should only include the operations and not their return values, check this. Also check if you depend on operation from same session other than preceding one.]}

\par \textbf{Proof:} We start by proving the implication in the direction $(\Rightarrow)$. Following the proof style of Gilbert et al.~\cite{Gilbert:2002:BCF:564585.564601}, we prove this by contradiction as follows.  Let us assume, by contradiction, that consistency model $E^S_C$ is implemented by an algorithm that is highly available during partitions but does not meet the condition at the end of the Theorem. Let us consider initially that there are only two clients, $c_1$ and $c_2$, with sessions $s1$ and $s2$, respectively. The fact that $E^S_C$  does not meet this condition means, given the definition of partial order enumeration and its use in the extended CAP theorem, that it is possible to produce an execution corresponding to a global session trace $\mathcal{S}_t$ with a valid partial order $\preccurlyeq$ that has a maximum element $o_{s1}(x)$ such that $o_{s2}(x)\preccurlyeq o_{s1}(x)$ (where $o_{s1}(x),o_{s2}(x)$ belong to $s1$ and $s2$), and where it is not admissible to have a partial order where $o_{s2}(x)\not\preccurlyeq o_{s1}(x)$.
% Without loss of generality, consider that $c_1$ and $c_2$ are the only two clients in the system. {\bf [CHECK IF IT REALLY DOES NOT LOSE GENERALITY!]}
%and a pair of operations in distinct sessions, $o_{s1}$ and $o_{s2}$ (from clients $c_1$ and $c_2$), where, for every admissible partial order $\prec$, one of the operation must see the effects of the other, i.e., $o_{s1}\prec o_{s2} \vee o_{s2}\prec o_{s1}$.

Now let us construct the following execution. First, we run the system under the exact same conditions that produced $\mathcal{S}_t$ until client $c_1$ is about to execute $o_{s1}(x)$ and client $c_2$ is about to execute $o_{s2}(x)$. At this point, a partition occurs that separates $c_1$ and $c_2$, which persists until the end of the execution. By the availability and partition-tolerance properties, the operations $o_{s1}(x)$ and $o_{s2}(x)$ will eventually complete and, by our initial assumption in the previous paragraph, the former operation must see the effects of the latter, i.e., the partial order that supports that execution must be such that $o_{s2}(x)\preccurlyeq o_{s1}(x)$. Now run the exact same execution, but where the client $c_2$ crashes right before invoking $o_{s2}(x)$. This execution is indistinguishable from the previous one from the standpoint of $c_1$. Thus $c_1$ will follow the same sequence of states and produce the same outputs as in the previous execution. This would mean that the algorithm would not meet its ConSpec specification, since $o_{s1}(x)$ would reflect the execution of an operation that was not part of the global session trace $\mathcal{S}_t$, namely $o_{s2}(x)$. This contradicts the fact that the employed algorithm meets that specification and the CAP properties.

The assumption about there being only two clients does not lose generality because, with more clients, a pair of clients $c_1$, $c_2$ under the conditions above must also exist. Then the proof generalizes beyond two clients by partitioning the clients into two sets, one containing $c_1$ and another containing $c_2$, and crashing all the clients in the same side of the partition as $c_2$.

Next we focus on the implication in the direction $\Leftarrow$. Here, we need to prove that if a consistency model $E^S_C$ meets the condition:

\noindent $\forall \mathcal{S}_{it} ~ \forall \preccurlyeq \in \Pi(\mathcal{S}_{it},E^S_C) ~ \forall o(x) \in max(\mathcal{S}_{it}, \preccurlyeq) ~ (\textsc{RemoveAllExceptSession}(\preccurlyeq,o(x)) \in \Pi(\mathcal{S}_{it},E^S_C) ~ ) $

then it has an available and partition-tolerant implementation.



Given any global session invocation trace $\mathcal{S}_{it}$, we prove this by induction on the length of the execution that produced $\mathcal{S}_{it}$. The base case with an empty execution is vacuously true, since an empty trace meets any consistency condition (no safety properties are ever violated by an empty trace). For the induction step, we need to prove that, given an execution for which an available and partition-tolerant implementation produced a trace that conforms to $E^S_C$, it is possible for a client to invoke a new operation and produce an output that is also consistent. This is true because, even in the case that the client that invokes the new operation is partitioned from all or a subset of the remaining processes, the consistency model allows for the newly invoked operation to depend only on prior operations from the same session and all the operations that transitively precede them according to $\preccurlyeq$. (This is because, if that was not the case, then this would invalidate the hypothesis on the right hand side of the equivalence stated in Theorem, since a valid partial order would not meet the property that removing all but the edges in the same session would be a part of the partial order enumeration for $E^S_C$.)  Furthermore, the valid output of this operation can be determined by using only information that is local to the session, by running the sequential specification of the system on the graph of preceding operations.$\Box$

%\begin{flushright}
%$\square$
%\end{flushright}

%\section{Implication with respect to CAC Theorem: Under the Assumption of Convergence}
%Mahajan et al. \cite{mahajan11cacTR}  propose  \emph{CAC} Theorem --- a variation of the CAP theorem, which considers the tradeoff between \emph{C}onsistency,  \emph{A}vailability, and  \emph{C}onvergence (CAC).  CAC segregates details of the system model like network reliability from properties like availability and consistency; hence CAC does not consider partition tolerance as a property to tradeoff.
% CAC %, unlike the CAP theorem,
%  states that it is impossible to support a consistency model  which is stronger than real time causal consistency \footnote{Real time causal consistency imposes an additional constraint on the original condition of causal consistency, i.e., it restricts that an operation can not observe results of an operation such that start time of the former operation exceeds the end time of the latter operation.} while simultaneously supporting high availability and \emph{one-way convergence} (from here onwards by convergence we always imply one-way convergence).  One-way convergence \cite{mahajan11cacTR} is defined as follows. If two nodes (i.e., in our case, nodes that host the clients $c_1$ and $c_2$) do not issue any new requests, and do not communicate with other nodes in the system (i.e., other than $c_1$ and $c_2$), then eventually one of these two nodes will send a sequence of requests to the other node, such that any subsequent request on a common object to either of these nodes will return an identical value.
% %\par %Though the CAC theorem does not explicitly address partition tolerance as a property to trade off, they do state that both CAP and CAC assume  an unreliable network which is prone to Byzantine and omission failures; thus CAC does consider the tradeoff with partition tolerance.
%   %of the additional convergence property in CAC in our formulation of the tradeoff between availability, partition tolerance, and consistency. % with respect to our extended CAP theorem. %We show that considering this additional  property as a precondition does not affect our proof in any tangible sense.
%\par  In section  \ref{sec:cap}, we have extended the CAP theorem to state that availability and partition tolerance can't be simultaneously satisfied in a system which implements  a consistency model that enforces partial order among operations from different sessions. However,  by consistency CAP implies linearizability, which in turn, subsumes the property of convergence \cite{mahajan11cacTR}. Hence the original CAP theorem does not consider the tradeoff between convergence and consistency.  Mahajan et al., in their so-called CAC theorem,  states what is the strongest consistency model  that is able to simultaneously provide convergence and high availability.  %To the best of our knowledge, CAC is the only work that proposes which consistency models can be provided in an asynchronous system while simultaneously supporting high availability and convergence. %, and partition tolerance.
%   %In this section, we discuss what are the implications of the additional convergence property in CAC in our formulation of the tradeoff between availability %, partition tolerance,
%   %and consistency.  % and partition tolerance.
%  We argue that the ``C" in CAC, i.e., convergence, is one  of  the properties which a consistency model $E^S_C$ may or may not satisfy, similar to the condition on the allowed partial orders ${\sc RemoveAllExceptSession}$  defined in Theorem \ref{thrm:cap}.
% %Only a subset of existing consistency models satisfy specific degrees of convergence. But the CAC paper only considers the tradeoff of one-way convergence with availability and consistency. Hence, the CAC theorem inherits the lack of preciseness of CAP; just as CAP is only limited to linearlizabilty while addressing consistency, CAC is limited to only those consistency models that support one-way convergence.
%Originally the CAC theorem state that real time causal consistency is the strongest consistency model that can be satisfied while supporting availabilty and convergence. Here we further extend the
%  CAC theorem to state the properties which make it possible for a consistency model to support convergence and %as well as
%   high availability. % and partition tolerance.
%    \par In this section, we show that, using a similar approach as the one taken with CAP theorem in section  \ref{sec:cap}, the CAC theorem can also be extended to categorize consistency models as CAC-feasible or CAC-infeasible.  We argue that convergence is just another additional property that a consistency model $E^S_C$ must satisfy, in addition to the condition on ${\sc RemoveAllExceptSession}$ defined in Theorem \ref{thrm:cap}, to make it possible to be implemented while also supporting availability. % and partition tolerance.
%     First, we lay the ground for our CAC formulation by postulating the following Lemma.
%  \begin{lemma}%[Impossibility Result]
% If any global session invocation trace $\mathcal{S}_{it}$ for a given asynchronous system satisfies the condition \noindent $\forall \mathcal{S}_{it} ~ \forall \preccurlyeq \in \Pi(\mathcal{S}_{it},E^S_C) ~ \forall o(x) \in max(\mathcal{S}_{it}, \preccurlyeq) ~ (\textsc{RemoveAllExceptSession}(\preccurlyeq,o(x)) \in \Pi(\mathcal{S}_{it},E^S_C) ~ ) $, then the system provides one-way convergence.
% \end{lemma} \label{cor:conv}
% \textbf{Proof:}  Recall that  the condition ${\sc RemoveAllExceptSession}$ on a given global session trace implies that any valid partial order for such a global session trace will order operations performed in that global session trace i%n each session trace  corresponding to each of the above clients
%  such that each operation depends solely on previous operations in the same session trace. Thus, ${\sc RemoveAllExceptSession}$ imposes the condition that in absence of concurrent operations to overwrite operations performed by clients  $c_1$ and $c_2$,  result of each operation in $c_1$ depend only on the operations performed by the same client.  The above statement corresponds to the one-way convergence property, which states that in absence of communications from other clients with  $c_1$ and $c_2$, operations from $c_1$ can always observe results of   $c_2$ according to the invocation order of  $c_1$. Hence it can be said that the condition ${\sc RemoveAllExceptSession}$ implies one-way convergence.
% \par As a direct consequence of Lemma \ref{cor:conv}, it can be stated that the condition for Theorem \ref{thrm:cap} subsumes the convergence condition. Hence the CAC theorem can be restated  as an extension of Theorem  \ref{thrm:cap},  i.e., CAC can state that convergence, in addition to availability, % and partition tolerance,
%  can be simultaneously achieved if and only if the condition  ${\sc RemoveAllExceptSession}$ is met.   In other words, the statement of CAC can be reformulated to state:  it is feasible to implement a consistency model $E^S_C$ which satisfies convergence and meets the condition  ${\sc RemoveAllExceptSession}$ while supporting availability. % and partition tolerance. This statement can be further rephrased to make it resemble the original statement of CAC as follows.
%  \begin{theorem}[Extended CAC theorem]
%  It is feasible to implement a consistency model $E^S_C$ while simultaneously providing availability %, partition tolerance,
%   and convergence if  and only if $E^S_C$  meets the condition  \noindent $\forall \mathcal{S}_{it} ~ \forall \preccurlyeq \in \Pi(\mathcal{S}_{it},E^S_C) ~ \forall o(x) \in max(\mathcal{S}_{it}, \preccurlyeq) ~ (\textsc{RemoveAllExceptSession}(\preccurlyeq,o(x)) \in \Pi(\mathcal{S}_{it},E^S_C) ~ ) $. %if the set of maxima in a valid partial orderings according to $E^S_C$  it is always possible to make them depend only on the previous operation in the same session and still obtain a valid partial order, i.e.: %depends only on one or more operations in the a different session.
%   \end{theorem} \label{thrm:cac}%Hence, we do not address CAC separately in this paper.
%  %Next, we show that by introducing the constraint of convergence as an additional precondition to our statement of CAP theorem, the original claims of the theorem (refer to Theorem  \ref{thrm:cap}) remain unchanged, i.e, the condition for a storage system to remain highly available under partitions, as stated in Theorem \ref{thrm:cap}, still holds.
%  \textbf{Proof:}  %Assuming that the storage system satisfies the above convergence condition,
%  Let us consider the proof of the implication of the above theorem in the direction $(\Rightarrow)$. For the above proof, we construct an execution which is identical to the one constructed in the course of the original proof.   CAC assumes  an unreliable network which is prone to Byzantine and omission failures. Hence we assume, as before, that  a partition occurs at the instance when  client $c_1$ is going to perform an operation $o_{s1}$ and client $c_2$ is going to perform an operation $o_{s2}$. Because of the partition, requests from $c_2$ can not reach $c_1$. Hence, the precondition for convergence ``one of these two nodes will send a sequence of requests to the other node" does not hold during this partition. Thus, the postcondition for convergence also does not hold, i.e., subsequent requests from $c_1$ can not return the value written by operation $o_{s2}$ issued from $c_2$.
% \par The rest of the proof proceeds exactly like the proof of Theorem \ref{thrm:cap}.   Following directly from  Lemma \ref{cor:conv} under the assumption that the system is convergent, the following condition must hold. For the system to remain available,
%  $o_{s1}(x)$ and $o_{s2}(x)$ eventually must finish, and result of $o_{s2}(x)$ must be visible from $o_{s1}(x)$, i.e., $o_{s2}(x)\preccurlyeq o_{s1}(x)$ must hold. Next, we run the same execution with the only change that we crash $c_2$ before invoking $o_{s2}(x)$. As a result of the above step, we still produce an execution that is identical to the previous one from the viewpoint of $c_1$. Hence, $c_1$ follows the same path of execution and produces results identical to the previous execution. Thus, the system fails to satisfy its ConSpec specification, since $o_{s1}(x)$  produces a result that is equivalent to result of an execution comprising the operation $o_{s2}(x)$; but  $o_{s2}(x)$ does not belong to global session trace $\mathcal{S}_t$. This, in turn, contradicts the assumption that the execution satisfies ConSpec specification of the system, as well as the original assumptions regarding the CAC properties. Thus, despite the convergence condition, the proof proceeds exactly as before. %Hence, application of the convergence condition does not produce any added value to the paper.
% \par As in the case of CAP,  we prove of the implication in the direction $(\Leftarrow)$ applying inductive reasoning on the length of the execution. %This proof is identical to the proof of the direction $(\Rightarrow)$ in the manner in which it constructs an execution to consider the effect of partition. Hence, this proof, given below, is also unaffected under the assumption of convergence.
%  As before, the base case comprising a ``null" execution is trivially true. For the induction step, we need to prove that, given an execution which has resulted in a consistent state in a highly available and convergent %and partition tolerant
%   system in an unreliable network, a client can invoke a new operation which results in a consistent output.  This is true because, even if the client invoking the new operation is partitioned from the remaining of the clients, it is always legal to produce an operation that depends on a prior operation from the same session and all the operations that transitively precede it according to $\preccurlyeq$ because of following reasons. The convergence property enforces that any given pair of nodes in a system must eventually exchange messages such that any subsequent request on a common object to either of these nodes will return an identical value. %Further, the inductive reasoning logic assumes that every operation depends on the prior operation at every step of inductive proof.
%     Hence, a new operation invoked by a client in a  convergent system will be followed by a sequence of subsequent invocations, which, in turn, will result in an execution that is consistent with respect to prior operations in the same session. Furthermore, the valid set of outputs for this operation can be determined by using only session-specific information depending on the partial order of preceding operations in that session.
%% consider a pair of sessions from , namely $\mathit{Cl}_1$ and $\mathit{Cl}_2$ executing
%% on two storage server nodes $N_1$ and $N_2$.
%% Let us consider that the network between $N_1$ and $N_2$ is partitioned at a particular instant $T_i$ of execution of the
%% clients, i.e., all communication between $\mathit{Cl}_1$  and  $\mathit{Cl}_2$ are lost. Further let us assume
%%  that $\mathit{Cl}_1$  and  $\mathit{Cl}_2$ comprise a sequence of one or more operations on a common data object $x$.
%%  % Let us assume a system with at least two available processes p1 and
%% %p2 that are managing a single shared variable x with a global agreement on the order of writes.
%%  The clients perform a sequence of operations $\alpha$  onto $x$ until a network partition occurs, and they are
%%  placed in two disjoint components of the  network ${G_1, G_2}$. Since the system is still available, both servers accept
%%  client requests, and apply the corresponding writes onto local copies of $x$. Because of this, $\mathit{Cl}_1$ (located
%%  in $N_1$) applies a new sequence of writes $\beta$ onto $x$ while $\mathit{Cl}_2$ (located in $N_2$) applies a different sequence of writes $\gamma$
%% to $x$. Since
%% these components are disconnected, none of these writes are propagated among the servers $N_1$ and $N_2$ during the partition.
%% To remain available and partition tolerant, the system must continue to serve requests uninterruptedly from the clients even in the presence of the partition.  Thus, each of the  servers $N_1$ and  $N_2$ must immediately perform the operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ from the clients $\mathit{Cl}_1$ and $\mathit{Cl}_2$, respectively,   and return the results, without waiting for the write from the other server to reach it.
%%  Therefore, the session traces $\mathit{st}$ and $\mathit{st}^{'}$ observed by  $\mathit{Cl}_1$ and $\mathit{Cl}_2$ are a pair of disparate sequences $\alpha, \beta$ and $\alpha, \gamma$
%%  for the conflicting object $x$. %; whereas  $\mathcal{S}_t$, as observed by $\mathit{Cl}_2$,  is a sequence $\alpha, \gamma$.
%%   Let operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$  be the prefix of the sequences  $\beta$, and $\gamma$, comprised in $\mathit{st}$ and $\mathit{st}^{'}$, respectively.
%%  The  system satisfies a consistency model $\mathcal{C}$, defined as $E^S_C$, which specifies that a valid partial order enumeration  $\Pi(\mathcal{S}_t,E^S_C)$  for a given global session trace $\mathcal{S}_t$  in the system does not constrain  operations performed by different sessions.  In other words, a valid $\Pi(\mathcal{S}_t,E^S_C)$ does not comprise a partial order which restricts operations from different sessions. Let us consider that the observed $\Pi(\mathcal{S}_t,E^S_C)$ for a global session trace $\mathcal{S}_t$ observed in the system comprises a comprises partial order $\preccurlyeq$
%%  %partial orders $\preccurlyeq_{st}$ and $\preccurlyeq_{st}^{'}$ restricted to session traces  $\mathit{st}$ and $\mathit{st}^{'}$ for the clients $\mathit{Cl}_1$ and $\mathit{Cl}_2$, respectively.  Thus, any valid partial order  $ \preccurlyeq$ for  in  $\Pi(\mathcal{S}_t,E^S_C)$ does not comprise operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ observed from $\mathit{st}$ and $\mathit{st}^{'}$.
%%  According to  $\mathcal{C}$, a valid $\preccurlyeq$ for $\mathcal{S}_t$ does not need to comprise both the operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ observed in the session traces $\mathit{st}$ and $\mathit{st}^{'}$.
%%  The above relaxation in the condition for  $\mathcal{C}$ enables the system to remain available despite the disruption in the connection between $N_1$ and $N_2$ in the presence of the partition, while satisfying $\mathcal{C}$.
%%  Because of the above disruption of  communication, results of operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ observed in the respective session traces  $\mathit{st}$ and $\mathit{st}^{'}$  for $\mathit{Cl}_1$  and $\mathit{Cl}_2$ are not propagated among the servers  $N_1$ and  $N_2$.
%%  %Hence, the partial order partial order $\alpha  \preccurlyeq_{st} \beta$, whereas $\mathit{st}^{'}$ observes a  partial order $\preccurlyeq_{st}$ = $\alpha  \preccurlyeq_{st} \gamma$.
%%   That is,  the observed partial order $\preccurlyeq$ is given as either $\alpha  \preccurlyeq \beta$ or $\alpha  \preccurlyeq \gamma$.  Since prefixes of $\beta$ and $\gamma$ are $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$, respectively, $ \beta \not= \gamma$. Hence, the partial order $\preccurlyeq$  does not consist both operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$.
%%  %$\preccurlyeq$ is either for the session $\mathit{st}$   does not comprise the operations  $\mathit{o}^{'}(x,v^{'})$ from the other  session  $\mathit{st}$.  Similarly, the partial order $\preccurlyeq_{st}^{'}$  for the session $\mathit{st}^{'}$ does not comprise operation  $\mathit{o}(x,v)$ from a different  session  $\mathit{st}$.
%% However, $\preccurlyeq$ is valid according to  $\mathcal{C}$ since $\mathcal{C}$ does not need  a valid partial order to  constrain operations from different sessions.
%%  This, in turn, implies that the  partial orders enumeration $\Pi(\mathcal{S}_t,E^S_C)$ corresponding to $\preccurlyeq$ is valid according to $\mathcal{C}$.
%%  Hence, in presence of partitions, the system satisfies the specified consistency model $\mathcal{C}$, while continuing to provide high availability. Thus, such a consistency model can be implemented in a manner that  simultaneously achieves high availability and partition tolerance.


%%  \begin{theorem}
%%  It is impossible for a storage system to satisfy a consistency model $E^S_C$ while simultaneously providing high availability and partition tolerance if and only if for any global session trace $\mathcal{S}_t$, there exists a corresponding partial order enumeration which constrain elements of different sessions according to the respective partial order, i.e.:

%% $\forall \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t ~ \exists \preccurlyeq \in \Pi(\mathcal{S}_t,E^S_C) ~ \exists o, o' \in \mathcal{S}_t (o \in \mathit{st} \wedge o' \in \mathit{st}^{'} \wedge \mathit{st} \not= \mathit{st}^{'} \Rightarrow o \preccurlyeq o' \vee o' \preccurlyeq o)$
%% % It is possible for a storage system to satisfy a consistency model that does not impose GWO  among writes on each data object across multiple clients executing on the system, while simultaneously providing high availability and partition tolerance.
%% % It is possible for a storage system to satisfy a consistency model that enforces a partial order among results observed by operations performed by the same client executing on the system, while simultaneously providing high availability and partition tolerance.
%%  \end{theorem}
%% \par \textbf{Proof:}   Following the approach of the proof to Theorem \ref{thrm:cap}, this theorem is proved  as follows.
%% We consider two servers $N_1$ and $N_2$ that serve requests from clients  $\mathit{Cl}_1$ and $\mathit{Cl}_2$. We consider that a partition occurs at a particular instant between the servers $N_1$ and $N_2$.  A partition occurs after the clients perform a sequence of operations $\alpha$ comprising one more operations on  an object $x$, severing the communication between  $N_1$ and $N_2$.
%%  %must, by definition of a strict partial order, satisfy the following properties: 1)  irreflexivity, 2) transitivity, and 3) asymmetry. The results in each of the above  global session traces $\mathcal{S}_t$ are resulting from a linear execution of operations from each client $\mathit{Cl}_1$ and $\mathit{Cl}_2$, i.e., each client executes its operations according to the sequence specified in its respective program order.  Thus each operation can not loop into itself (state diagram for an execution must be devoid of self loops); hence, condition 1 is trivially satisfied in the above execution.  Since the operations performed by clients $\mathit{Cl}_1$ and $\mathit{Cl}_2$ are executed in  a linear temporal order which follows from the program order of each client, there can not be any cycle among the operations in each of the above session traces; hence, condition 2 also holds for the above execution.
%%  A global session trace $\mathcal{S}_t$ for the above system comprises session traces  $\mathit{st}$ and $\mathit{st}^{'}$ consisting of  sequences of operations performed by the clients $\mathit{Cl}_1$  and  $\mathit{Cl}_2$, respectively.  Again, let the prefix of the executions  $\beta$, and $\gamma$ observed by clients $\mathit{Cl}_1$ and $\mathit{Cl}_2$ be writes
%%   $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$, respectively.
%%  Because of the lack of communication of updates between the servers $N_1$ and $N_2$ serving $\mathit{Cl}_1$ and $\mathit{Cl}_2$ in presence of a partition, results of the operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ are not propagated among the servers $N_1$ and $N_2$.
%%  However, in order to maintain high availability, the system must continue serving the clients even in the presence of the partition. Thus, each of the servers  $N_1$ and $N_2$  must immediately apply the writes from the disconnected clients $\mathit{Cl}_1$  and  $\mathit{Cl}_2$, respectively, and return the results, without waiting for the writes from the other client to be propagated.
%%  However,  to work in such a disconnected mode, the system violates the specified consistency model $\mathcal{C}$  as follows.
%%  By our assumption, the storage system enforces a consistency model $\mathcal{C}$  which specifies that, for any global session trace $\mathcal{S}_t$ in the system, there exists a valid partial order enumeration $\Pi(\mathcal{S}_t,E^S_C)$,  which comprises partial orders that impose restrictions on the ordering of operations from different sessions. %Let $\mathit{st}$ and $\mathit{st}^{'}$ for the clients $\mathit{Cl}_1$ and $\mathit{Cl}_2$, respectively. %By definition, apart from transitivity and antisymmetry, a total order $\preccurlyeq$ relation requires satisfaction of the
%% %\emph{totality} condition, i.e.,
%% According to the above condition implied by the specification $E^S_C$ for $\mathcal{C}$, any valid partial order in the enumeration  $\Pi(\mathcal{S}_t,E^S_C)$ for a valid global session trace $\mathcal{S}_t$ must comprise operations from different sessions in  $\mathcal{S}_t$. Therefore,  a valid partial order $\preccurlyeq$ for  $\mathcal{S}_t$ must  comprising operations from both the session traces $\mathit{st}$ and $\mathit{st}^{'}$. %This implies that $\preccurlyeq$ must order the observed sequences $\alpha, \beta$ and $\alpha, \gamma$ as $\alpha \preccurlyeq \beta$ and $\alpha \preccurlyeq \gamma$.
%% % for the conflicting object $x$. %; whereas  $\mathcal{S}_t$, as observed by $\mathit{Cl}_2$,  is a sequence $\alpha, \gamma$.
%%   Session traces $\mathit{st}$ and $\mathit{st}^{'}$ comprise a pair of execution sequences  $\alpha, \beta$ and  $\alpha, \gamma$, respectively, where $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$  are prefix of   $\beta$ and $\gamma$, respectively.
%%   To be deemed valid according to $\mathcal{C}$, $\preccurlyeq$  must comprise both operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ from $\mathit{st}$ and $\mathit{st}^{'}$.
%% %That is, $\preccurlyeq_{st}$ implies ${W}^{'}  \preccurlyeq_{st} {W}^{''}$, and $\preccurlyeq_{st}^{'}$ implies $ {W}^{'}  \preccurlyeq_{st}^{'} {W}^{''}$, or $\preccurlyeq_{st}$ implies ${W}^{''}  \preccurlyeq_{st} {W}^{'}$, and $\preccurlyeq_{st}^{'}$ implies ${W}^{''}  \preccurlyeq_{st}^{'} {W}^{'}$. %, but not both simultaneously.
%%   However, in the presence of the partition, results of $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ are not propagated among the disconnected servers, i.e., $\beta \not= \gamma$. Hence, there does not exist a  valid partial orders $\preccurlyeq$ that comprises both operations $\mathit{o}(x,v)$ and $\mathit{o}^{'}(x,v^{'})$ from sessions $\mathit{st}$ and $\mathit{st}^{'}$. Thus, in presence of the partition, there does not exist a valid enumeration $\Pi(\mathcal{S}_t,E^S_C)$ for $\mathcal{C}$ . %, observed in the session traces $\mathit{st}$ and $\mathit{st}^{'}$.
%% %   Thus, ${W}^{'}  \preccurlyeq_{st} {W}^{''}$ holds in $\beta$, while ${W}^{''}  \preccurlyeq_{st}^{'} {W}^{'}$ holds in $\gamma$.
%%  This contradicts our assumption that $\mathcal{C}$ implies the existence of a valid partial order enumeration  comprising  operations from different sessions.  Hence, a system that implements $\mathcal{C}$ can not achieve high availability and partition tolerance at the same time.


% {\bf [RR: Add corollary saying: the consistency models Causal, SC, PC, and TSO are CAP-strong, since any valid $\mathcal{S}_t$ for  these consistency models require the existence of a valid partial order, hence a valid partial order enumeration, comprising operations performed from different sessions. Hence, according to Theorem \ref{thrm:cap}, these consistency models can not be implemented in a highly available and partition tolerant manner. ]}

% \begin{corollary}[Impossibility Result]
%The consistency models Causal, Causal+, SC, and TSO are CAP-strong, since any valid $\mathcal{S}_t$ for  these consistency models require the existence of a valid partial order, hence a valid partial order enumeration, comprising operations performed from different sessions. Hence, according to Theorem \ref{thrm:cap}, these consistency models can not be implemented in a highly available and partition tolerant manner.
%
% \end{corollary} \label{cor:cap}

\section{Analysis of Consistency Models With Respect to CAP}\label{sec:capanalyze}

The previous section defined necessary and sufficient conditions for
a consistency model $\mathcal{C}$ to have an available and partition-tolerant
implementation. Now, we analyze the $E^S_C$-expression for the consistency models that we presented in Section~\ref{sec:list}, to determine how it fares with respect to Theorem \ref{thrm:capan}.

We can see that the session guarantees (MR, MW, RYW, WFR) and both the causal and processor consistency definitions  are  only forcing constraints on the partial ordering across operations from the same session. This implies that these constraints are compatible with the conditions on the right hand side of the equivalence of Theorem~\ref{thrm:cap}. In particular, it is the case that it is always legal to remove orderings between operations across sessions, since these are never constrained by the implications in the various different $E^S_C$ expressions. Therefore, we conclude that Causal Consistency, Processor Consistency, and all four session guarantees are not affected by CAP, i.e., they can have a highly available and partition-tolerant implementation.

% it can be observed that   all of these expressions specify that precedence order among operations from a session trace $\mathit{st}$ must be preserved in any valid partial order $\preccurlyeq_{\mathit{st}+w}$ belonging to a valid partial order enumeration $\Pi(\mathcal{S}_t,E^S_C) $ (refer to Definition \label{def:allpos}) for a valid global session trace $\mathcal{S}_t$ for $E^S_C$.  Similarly, the $E^S_C$-expressions for Causal and Causal+ consistency models restrict the above condition must be respected in each session trace $\mathit{st}$ in $\mathcal{S}_t$, corresponding to each client in the system.  Similarly, Processor consistency (PC) restricts that  a valid partial order  $\preccurlyeq_{\mathit{st}+w}$  among operations in a given client $\mathit{st}$ must always match the invocation order, i.e., no client may observe the operations from $\mathit{st}$ in an order that differs from the invocation order in $\mathit{st}$.   A valid partial order  $\preccurlyeq_{\mathit{st}+w}$ for $E^S_C$ comprises operations from a given session trace $\mathit{st}$ plus all writes in  $\mathcal{S}_t$. Since $\preccurlyeq_{\mathit{st}+w}$ does not comprise reads from other clients, hence does not restrict results observed in other clients all of these consistency models, these models, are CAP-weak. Intuitively, writes from concurrent sessions are allowed to interleave between operations in a given session $\mathit{st}$ in any manner in $\preccurlyeq_{\mathit{st}+w}$, as long as precedence order among operations from  $\mathit{st}$ in $\preccurlyeq_{\mathit{st}+w}$ matches the  precedence order in $\mathit{st}$. These models are not dependent on reliable communication among concurrent clients, for synchronization tasks like broadcasting of results or meta data, or blocking of conflicting operations. Hence, the above consistency models can be implemented in a system without expensive synchronization protocols, which prevent or resolve conflicts among concurrent clients using locks or consensus.  They can be implemented using asynchronous techniques, like local snapshot or checkpointing, which can preserve correctness of local operations,  independent of global state of the system. Among these, Causal and Causal+ are strongest, since they require some mechanism for merging snapshots of local executions from multiple clients. % Under these consistency models,
% a pair of concurrent clients, namely $\mathit{Cl}_1$ and $\mathit{Cl}_2$, can continue providing high availability guarantees in a partitioned network, where there
% all communication between $\mathit{Cl}_1$  and  $\mathit{Cl}_2$ are lost. Hence, the above consistency models are CAP-relaxed.
 %For Strict Serialization, $E^S_C$ imposes a restrictive conditions that mutual order among operations performed by each client
% in a global execution must be preserved in an equivalent legal serialization $S_c$, where $S_c$ is a restriction of the
% legal serialization $\mathit{Ser}$ with respect to a given
%client $\mathit{Cl}$.
% Using the expression for $S_c$ from Definition \ref{def:clientser} in Equation \ref{eqn:Strict}, the specification for Strict
% Serializability can be given in the same manner as Chockler et al., as follows.
% $E^S_C =  \forall \mathit{st} \big( \mathit{Op}^{'} X^o {\mathit{Op}}^{''} \in \mathit{st}
%\\ \Rightarrow
%\exists \left( {\mathit{Op}^i}^{'}, {\mathit{Op}}^{''} \in \mathit{Ser} \wedge {\mathit{Op}}^{'}, {\mathit{Op}}^{''} \in \mathit{st} \right) \\
%\left( {\mathit{Op}}^{'} X^o {\mathit{Op}}^{''} \in S_c \right) \big).$
%Since, $ \mathit{S_c} \subset \mathit{Ser}$, ${\mathit{Op}}^{'} X^o {\mathit{Op}}^{''} \in \mathit{S_c}$ implies ${\mathit{Op}}^{'} X^o {\mathit{Op}}^{''} \in \mathit{Ser}$
%Hence, moving the existential quantifier out of the enclosing scope of the universal quantifier, the above expression can be rewritten as
%\\ $E^S_C =  \exists \left( {\mathit{Op}}^{'}, {\mathit{Op}}^{''} \in \mathit{Ser} \right) \forall \mathit{st} \big( \mathit{Op} X^o {\mathit{Op}}^{''} \in \mathit{st}
%\\ \Rightarrow \left( {\mathit{Op}}^{'} X^o {\mathit{Op}}^{''} \in \mathit{Ser} \right) \big).$
% Thus,
\par %Legal serialization $\mathit{Ser}$ strictly orders results of all operations from all clients
% such that each read operation performed by each client returns the result of the preceding write performed by the same client.
 %Hence, Strict Serializability imposes strong restrictions on the execution order and observed results for each clients, such that
% a concurrent client may not overwrite the results of an operation performed by a given client. %In Equation \ref{form-1},
% the LTL operators $R$ and $R^{'}$ can imply constraints
% either on the observed results (in the form of equality relation among values observed) or precedence relation (denoted by
% eventually operator $F$ or special-purpose next operator $X^o$) among each pair of operations.

In contrast,  SC requires that the visibility order $\preccurlyeq$ among operations from all the clients in the system forms a total order. This implies that if an operation is related by the transitive reduction of $\preccurlyeq$  to a previous operation from another session, it is not possible to remove this element of the partial order and still obtain a valid partial order, since it would violate the condition in the definition of SC that any two operations need to be ordered with respect to each other. Thus, this does not meet the necessary and sufficient condition for a partition-tolerant, highly available implementation.

%Similarly, in PC, if a write in a given session is related by the transitive reduction of $\preccurlyeq$  to a previous write from another session, then removing this element of the partial order could result in an invalid order in case the two writes had been ordered in that way by another session. Therefore PC is also a strong consistency definition that can be used as a C in the CAP theorem.


 %% $\preccurlyeq$ in a valid partial order enumeration $\Pi(\mathcal{S}_t,E^S_C) $,  comprising operations from all clients. Similarly, TSO
 %%  restricts that read operations can not return results of a write operation from another client unless all clients have observed the result of a preceding write to a  common data object. This, in turn, requires that read-write pairs from different  clients must be applied in the same precedence order in all valid partial orders,, hence in all valid $\Pi(\mathcal{S}_t,E^S_C) $,  for a given $\mathcal{S}_t$. Thus, any valid $\mathcal{S}_t$ for  these consistency models require the existence of a valid partial order enumeration $\Pi(\mathcal{S}_t,E^S_C) $, comprising operations performed from different sessions. Hence, according to Theorem \ref{thrm:cap}, these consistency models SC and TSO are CAP-strong, i.e., they can not be implemented in a highly available and partition tolerant manner.
 %% They can not be implemented using asynchronous mechanisms that simply preserve local system states.  They require some form of synchronization among concurrent clients; e.g., SC requires a  mechanism for  synchronizing conflicting updates, such as some form of locking protocol or consensus-based convergence protocols.


   \section{Implementation}\label{sec:impl}
 We provide an open source automated  tool for verifying whether a session trace meets a given consistency model. This tool was built using Spin \cite{Holzmann:2003:SMC:1405716}, a widely used open source software verification framework. The source code of the ConSpec tool along with instructions for running it are publicly available at \url{https://github.com/ssidhanta/ConSpecTool}.  %\footnote{\url{https://github.com/ssidhanta/ConSpecTool}}.
  A global session trace is supplied to the tool as input, in the form of a text file containing a sequence of storage operations as a series of rows of comma separated strings. The tool automatically checks whether a given session trace is valid under a given consistency model $\mathcal{C}$, specified in terms of  $E^S_C$, which is in turn a Spin LTL formula modelled using the PROMELA meta language.
  Internally, Spin translates the PROMELA source file into C code. The Spin driver then runs the built-in model checker to check for counter-examples for the above generated C code  against  the Spin formula given as $E^S_C$. % The Spin model checker validates the generated C code with the Spin formula acting as an invariant on the system behaviour modelled by the C code. %, with the set of equivalent legal serializations generated from the given session trace supplied as an input to the model checkers.  %The github repository comprises a PROMELA specification for each of the consistency models and isolation levels, the Spin-based main source file, and the code for generating the list of  equivalent serializations.
   \begin{figure}\caption{ConSpec Specification in PROMELA}\label{format:spec}
\begin{lstlisting}[escapeinside={(*}{*)}]
(*$mtype = \{  r, w, x, y \}$*);
(*$\mathit{typedef} \mathit{Op}$*) {
		(*$mtype\; \mathit{optype}$*);
		(*$mtype\; \mathit{var}$*);
		(*$int\; \mathit{val}$*);}
(*$\mathit{typedef}$*) (*$\mathit{PO}$*) {
		(*$\mathit{Op}\;\mathit{st}[\mathit{max}_\mathit{size}]$*);
		(*$mtype\; \mathit{status}$*);}
 (*$\mathit{Op}$*)  (*$\mathit{st}[\mathit{size}]$*);
(*$\mathit{Op}$*) (*$\mathit{po}[\mathit{po}_\mathit{size}]$*);
(*$ltl$*) (*$\mathit{cc}$*) {(*$\square$*)((*$\lnot$*)((*$\mathit{po}[i].\mathit{st}[j].\mathit{optype}=w$*) (*$\Rightarrow \; \lozenge$*)(*$\mathit{po}[i].\mathit{st}[j].\mathit{optype}=r))$*)}
\end{lstlisting}
\end{figure}
  \par ConSpec provides a library of definitions with one PROMELA source file for each consistency model.
%Given a session trace, the first step of the tool is to execute Spin against the PROMELA file corresponding to the given consistency model on the session trace. Spin accepts specifications of consistency models in the form of Spin LTL  formulas provided in the corresponding PROMELA source files.
%Figure \ref{format:spec} illustrates 
The snippet in Figure \ref{format:spec} is taken from the PROMELA  source file for the RYW consistency model. In the above snippet, $\mathit{cc}$ is a Spin-style declaration of an LTL formula that specifies the RYW consistency model; $\mathit{cc}$ is expressed in terms of the following PROMELA variable declarations provided in the .pml (PROMELA)  file. The event of execution of an operation is declared using the typedef declaration  $\mathit{typedef}\; \mathit{Op}\; ...$, where $\mathit{typedef}$ is the PROMELA syntax for declaring a user-defined data type.
%In the declaration of an operation, the operation type and variable (object) for each operation are declared as  mtype variables $\mathit{optype}$ and $\mathit{var}$, where $\mathit{mtype} $ is a PROMELA-style declaration of a constant ($\mathit{optype}$ can take constant values read or write).
%We refer to the length of the trace as its size, i.e., the number of rows in the trace, which in turn is the number of operations executed.
Each operation in a trace is represented as a tuple  $\mathit{Op}$ comprised of the following elements: the operation type $\mathit{optype}$, the variable name $\mathit{var}$, and the value $\mathit{val}$.  Then, using the statement $\mathit{Op} \; \mathit{st}[\mathit{size}]$, a session trace of length $\mathit{size}$ is declared as an array $\mathit{st} $ of elements belonging to the user-defined datatype $\mathit{Op}$.   A valid partial order for a given session trace is declared using the typedef declaration $\mathit{typedef}\; \mathit{PO}\; ...$  The list of all possible valid partial orders for a session trace $\mathit{st}$ is declared as an array $\mathit{po}$, which is created by the statement $\mathit{PO}\; \mathit{po}[\mathit{po}_\mathit{size}];$ this creates an array of elements belonging to the type $\mathit{PO}$ with an  array-size of $\mathit{po}_\mathit{size}$. Each element in the array $\mathit{po}$ is a permutation of the session trace $\mathit{st}$. The i'th element in the list of all possible partial orders $\mathit{po}$ is accessed as $\mathit{po}[i]$, and the j'th operation in $\mathit{po}[i]$ is accessed as $\mathit{po}[i].\mathit{st}[j]$. In the LTL declaration
%  {\setlength{\abovedisplayskip}{0pt}%
%\setlength{\mathindent}{0pt}
  \begin{align*}%\label{eqn:ltldec}	
%\begin{split}
 ltl \; \mathit{cc}  \; \{  \square ( \lnot (\mathit{po}[i].\mathit{st}[j].\mathit{optype} = w \Rightarrow \\
 \lozenge  \mathit{po}[i].\mathit{st}[j].\mathit{optype} = r)) \},
   % \end{split}
    \end{align*}
   % }%
     derived from Equation \ref{eqn:RYW}, $\mathit{po}[i]. \mathit{st}[j].\mathit{optype}$ denotes the operation type of the j'th operation in the i'th partial order. $\square$ is the LTL operator globally, $\lozenge$ is the LTL operator eventually, $\lnot$ is the negation operator, and   $\Rightarrow$ denotes the implies operator.  Thus, the specification $cc$ in  the above snippet %Figure \ref{format:spec} 
       denotes that if the operation type \emph{optype} of an operation $st[j]$ in a given session trace $st$ is write, then the next read operation, which follows $st[j]$ in the same session trace and reads an  object that was written by $st[j]$, must return the value that was written by $st[j]$.
   The above specification is provided in the pml file, as a declarative statement, followed by the specification of the system behavior, namely the semantics of read and write operations. The pml file is then compiled using the Spinroot compiler with the above LTL specification as the spin invariant. 
   % The  C++ file, which is output of the above compilation step, is then compiled using the gcc compiler. 
   \added[id=1]{The output C++ program is compiled, run, and then output of that C++ program is used to flag if a given input session trace is a case of violation or satisfaction of the consistency model specified in the LTL invariant given in  the above snippet.} %Figure \ref{format:spec}.

%The derivations of rest of the consistency models, which follow the above approach, are given in Section \ref{sec:restderive}.
 \section{Evaluation}\label{sec:eval}
In this section, we evaluate how long the ConSpec tool takes to check the consistency of a  session trace, how this validation time varies depending on the length (or size) of the trace, and that compares to checking traces expressed in conventional syntaxes. In our evaluation, we use two sets of traces, where the first one is generated by executing the Yahoo Cloud Serving Benchmark (YCSB) benchmark suite (YCSB v 0.1.4)  \cite{Cooper:2010:BCS:1807128.1807152}   on top of a Cassandra cluster (Apache Cassandra v 2.1.2)  \cite{Lakshman:2010:CDS:1773912.1773922}, and the second one is obtained by executing the TPC-C benchmark on top of a MySQL database.
% By varying the configuration parameters of YCSB, namely ``thread" and the execution time, we generate a series of global session traces of different length.  % running on an m3.medium Amazon Ec2 instance located in us-west-2a region.
% Using the parameter ``thread", we simulated a number of concurrent YCSB client threads executing the given workload, where the number of clients correspond to the value passed to the thread parameter. Thus each execution of the YCSB client with a given value of the thread parameter generates a global session trace consisting of multiple session traces, where each session trace comprises the entire sequence of operations performed from a specific client thread. We modify the source code of the YCSB Java client to write, for each operation, the execution time, operation type (read or write), keys accessed and corresponding values returned into log files.
 The ConSpec Tool was run over the above traces on an Apple McBook Pro, with 8 GB 1600 MHz DDR3 RAM,  2.9 GHz Intel Core i7 processor, %Intel HD Graphics 4000 1536 MB,
 running McOS Sierra v10.12.4. The partial order generator component of the tool was run on Java 1.8.0\_121, and the PROMELA component were  compiled and run on Spin v6.4.6.
 Throughout the evaluation, by execution time we refer to the time duration beginning with the preprocessing of the input global session trace and ending with printing the result of checking the above  trace against the given ConSpec specification.
 \begin{figure}%[t]
      %\begin{center}
        \includegraphics[width=2.5in,height=1.5in]
                    {oneany.eps} %\vspace{-5em}
          %\end{center}
        \caption{Staleness in Gamma vs Latency with YCSB.}
        \label{fig:oneany}
\end{figure}

  \subsection{Evaluation with YCSB}\label{sec:evalycsb}
      \begin{figure}%[t]
      %\begin{center}
        \includegraphics[width=3.2in,height=2in]
                    {conspecYCSBvarhist.eps} %\vspace{-5em}
          %\end{center}
        \caption{Execution Time of ConSpec Tool Against YCSB Traces.}
        \label{fig:examplefull}
\end{figure}
% \begin{figure}%[t]
%      %\begin{center}
%        \includegraphics[width=3.4in,height=2.8in]
%                    {conspecExecutionTimesFullVariance.eps} %\vspace{-5em}
%          %\end{center}
%        \caption{Variance of Execution Time of ConSpec Tool Against YCSB Trace.}
%        \label{fig:examplefullvar}
      %\end{figure}

In this part of the evaluation, we use YCSB to evaluate the scalability of our verification tool.  To understand how the execution time of the ConSpec tool varies with the length of  the global session trace, we plot the total execution time that the tool incurs as a function of the size of the global session trace measured as the number of operations in that trace. To generate a series of global session traces of  different lengths, we are able to vary two configuration parameters of YCSB, namely the thread count and the execution time.  % running on an m3.medium Amazon Ec2 instance located in us-west-2a region.
 Using the thread count parameter, we simulated a number of concurrent YCSB client threads executing the given workload, where the number of clients corresponds to the value passed to this parameter. Thus, each execution of the YCSB client with a given value of the thread parameter generates a global session trace consisting of multiple session traces, where each session trace comprises the entire sequence of operations performed from a specific client thread. To record each trace, we modify the source code of the YCSB Java client to record the per-operation execution wall-clock time, the operation type (read or write), the keys that were accessed and the respective values returned.
 In this experiment, we verify the YCSB session  trace against the ConSpec definition of the RYW consistency model, which is specified as a Spin LTL formula in the corresponding  PROMELA source file.
 We execute the YCSB client with 50 concurrent client threads; thus, the global session  trace comprises 50 concurrent sessions.
 Then, to obtain global session traces of an increasing length, we created several instances of an execution of the YCSB client, where, for each execution, we increase the length of the global session trace by increasing the  duration of execution of the client while keeping the concurrency level fixed at 50 concurrent threads. Thus, for each execution, the size of the global session trace (i.e., the total number of  operations in that trace) is given by $50 \times op$,  where $op$ is the number of operations executed by one client thread during that run.
   We  preloaded the YCSB backend with $1,000,000$ records.  The ``request distribution'' parameter is used to indicate to the YCSB client which specific random distribution to use for the keys, which, in turn, forms the basis for choosing the records on which a given operation is to be performed. We ran the client with the ``latest'' request distribution of keys, where the latest inserted records comprise the head of the distribution. The  ``target'' parameter is used to throttle  the target number of operations per second; we set the value of ``target'' to 100  operations per second. 
   %We express the inconsistencies observed in our experiments in terms of the observed staleness of the results. Golab et al. \cite{DBLP:conf/cloud/GolabRAKWG13} %\cite{DBLP:conf/cloud/GolabRAKWG13}
  %demonstrate that both the proportion and severity of stale results increases from stronger to weaker consistency levels. We measure staleness in terms of the  {\boldmath$\Gamma$} metric proposed by Golab et al. \cite{DBLP:conf/cloud/GolabRAKWG13}. As demonstrated in the above work, {\boldmath$\Gamma$}  is preferred over other client-centric staleness measures for its proven sensitivity to workload parameters and consistency level. According to \cite{DBLP:conf/bigdataconf/McKenzieFG15}, with increasing values of read proportion, the value of {\boldmath$\Gamma$} metric also increases from 5 to 55. Also, the proportion of positive {\boldmath$\Gamma$} values  increases from 0.005 to 0.045. In our experiments with YCSB the observed  inconsistencies in the results, measured in terms of   {\boldmath$\Gamma$} values, are bounded by the above range.  
To better understand if the original trace was already close to being linearizable or not, we measured the level of deviation from strong consistency using a metric called $\Gamma$ proposed by Golab et al.~\cite{DBLP:conf/cloud/GolabRAKWG13}. Intuitively this
metric captures both the proportion and severity of stale results. The results of applying this metric to the data that is produced by our trace are depicted in Figure~\ref{fig:oneany}. This shows that the values of 95th percentile 
$\Gamma$ score range from 0 to 14 ms, which implies that the severity of observed staleness in our results is negligibly small.


   Figure \ref{fig:examplefull} depicts the variation of the execution time of ConSpec on global session  traces collected from YCSB, as we vary the length of the traces, i.e., the number of operations performed is plotted along the x axis. We repeated the verification of each global session trace 5 times,  and in each case we report the average and, as error bars, the standard deviation of the execution times observed in the 5 runs.
   %   The execution time, in milliseconds,  of ConSpec  is plotted along the y axis, and  the length of the corresponding global session trace is plotted along the x axis.
   The execution time remains within $1$ second for global session traces of size up to $100K$, i.e., comprising up to $100,000$  operations. Furthermore, the straight line appearance of the plot indicates that the performance of ConSpec scales approximately linearly with the size of the global session trace.
   %The averages of execution times observed with the various global session traces are illustrated as a line chart, and the standard deviations of the respective execution times (corresponding to each global session trace) are given as  error bars over the points in the line chart in Figure \ref{fig:examplefull}.
%    The size of each global session trace is plotted along the x axis. The average and  standard deviation of the execution times recorded during 5 runs of ConSpec against each global session trace are plotted along the y axis. % The variance of execution times for a given global session trace is explicitly highlighted as textual labels in the green stacks in the bar corresponding to that global session trace.  %Each bar represents observations against a global session trace of a specific size.
     %The average and the standard deviation of execution times of the runs of ConSpec against a given global session trace are represented as coloured stacks  in the corresponding bar in the stacked bar chart.
     %, with the different coloured stack representing the execution time for each run. %We  record the variances of execution times for each global session trace as labels on each bar  corresponding to the respective global session trace.
   \par This linear scalability was somewhat surprising, since the preprocessing step in ConSpec for generating all possible legal serializations for a given session trace has a complexity $\mathcal{O}(\mathit{l}!),$ where $\mathit{l}$ is the length of the session trace. To understand this performance trend, we note that the ConSpec tool performs the verification of a given session trace with the  Spin model checker, which reduces the verification problem into a graph reachability problem; it internally constructs a graph of all possible states and subsequently determines  reachable states in the graph \cite{Holzmann:1997:MCS:260897.260902}. Next, the Spin model checker  employs the nested depth first search algorithm \cite{DBLP:conf/dimacs/HolzmannPY96} to search for accepting states within the state space comprising all possible reachable states \cite{DBLP:conf/tacas/SchwoonE05}.
    %In the first step, the nested depth first search algorithm reduces the model checking problem into a reachability problem where it searches for accepting states comprised in some strongly connected components in the graph of the given state space. Second, it leverages partial order reduction techniques to look for cycles around the accepting states on-the-fly.  The above two steps are interleaved with each other which enables nested depth first search achieve linear complexity and high memory efficiency.
    While performing the above task, the Spin model checker  applies partial order reduction techniques \cite{Peled1994}, which result in reduction of the search space of reachable states explored during the nested depth first search. In  \cite{Holzmann:1997:MCS:260897.260902}, Holzmann et al.\ provide a complexity analysis of the Spin tool in performing verification of the well known leader election algorithm. Holzmann et al.\ observe a linear growth in the number of reachable states explored by the Spin model checking algorithm instead of an expected exponential growth. They also report a similar linear growth with other typical use cases of the model checker. As such, this is very likely to explain the results we obtained. 
    \added[id=1]{ In Section \ref{sec:additionalYCSBexp}, we elaborate how we further enhance the scalability of the tool using a sliding window approach.}


%    From their analyses and empirical evidences presented in  \cite{Holzmann:1997:MCS:260897.260902}, it can be deduced that for global session traces of reasonable size, i.e., which can fit in the main memory, the Spin model checker, and thus, in turn, the ConSpec tool experiences an approximately linear performance scaling because of this  on-the-fly partial order reduction.
    %We argue that a possible explanation for this fact are the optimizations employed by Spin, which make the verification step very efficient.

%    Hence we can express the execution time for the preprocessing step as $(A \times \mathit{SIZE})!$, where $A$ is a constant term. The length of the session trace $\mathit{SIZE}$ can be given as $\mathit{SIZE}=B \times n$, where $B$ is a constant term, and $n$ is an integer term. By varying $n$, we can vary the size of the session trace as multiples of $B$; for our experiments we use $B$ = 50. In our experiments, we sequentially increase the size of session trace by incrementally varying $n$ from 1 to $500$. Hence the execution time of preprocessing step can be rewritten as  $A \times (n \times B)!$,  which results in a curved plot. %With an increase in length of session trace by $B$, i.e., with a new session trace of length $n \times B + B$, the execution time of Step 1 becomes $(A \times ((n+1)B)!$.   %The new execution time of Step 1 with a new session trace of length $n \times B + B$ is given as $A \times (n+1) \times B!$.
  %It can be trivially deduced that the complexity of Step 2 is $\mathcal{O}(1)$. Let execution time of Step 2 be given as a constant term $D$. Since Step 3 is a special case of exhaustive search algorithm, the complexity of Step 3 is the same as that of exhaustive search, i.e., the complexity can be given as $\mathcal{O}((n \times B)^3)$. Let the execution time of Step 3 be given as $E \times (n \times B)^3$. %The  increase in execution time of Step 3 with a new session trace of length $n \times B + B$  is given as $E\times (((n +1) \times B)^3 - (n \times B)^3)$. Combining the above, the gradient of the plot of execution time against length of session trace is given as $(A \times ((n+1)B! - n \times B!) + (D -D) + E\times (((n +1) \times B)^3 - (n \times B)^3)) / ((n+1) \times B -n \times B)$, which can be simplified as $A/B \times (n \times B)! \times n + E \times B^2 \times (3 \times n^2 + 3 \times n + 1)$.
 %The execution time is  an composite function comprised of the functions $(n \times B)! $ and $(n \times B)^3$. %hence the resultant graph of execution time is a superimposition of the factorial and cubic graphs.
% Since $A$, $B$, and $E$ are constants and $(n \times B)! \ge (n \times B)^3$, $(n \times B)!$ is the dominant term in the expression for  the execution time. %, i.e., it is basically a function of $(n \times B)!$.
%However, the curvature of the graph due to the preprocessing step is smoothed out by optimizations performed internally by the Spin tool, such as minimization of the  frequency of context switching by employing on-the-fly partial order reduction methods. This explains the nature of the above plot in Figure \ref{fig:examplefull}.
% \par This scalability can further be attributed to the design of the exhaustive verifier in the underlying Spin module, which leverages partial order reduction methods to optimize the search space of the verification process.  It performs these partial order reductions on-the-fly, thus restricting the frequency of context switching during the verification to a bare minimum without compromising the soundness of the verification process.  Further, instead of pre-building the state transition graph  for the verified system, it does incremental search, working on a portion of the search space iteratively on-the-fly.
% Due to such optimizations, Spin is able to scale with increasing size of input dataset, and is able to rigorously validate very large systems with very low overhead.
%\begin{figure}%[t]
%        %\begin{center}
%        \includegraphics[width=3.2in,height=2in]
%                    {conspecExecutionTimes.eps} %\vspace{-5em}
%          %\end{center}
%        \caption{Execution Time of ConSpec Tool Against YCSB Trace With Sliding Window size 5.}
%        \label{fig:exampleIter}
%\end{figure}
     \begin{figure}%[t]
      %\begin{center}
        \includegraphics[width=3.2in,height=2in]
                    {conspecTPCCvarhist.eps} %\vspace{-5em}
          %\end{center}
        \caption{Execution Time of ConSpec Tool Against TPCC Trace With respect to ConSpec Definitions vs Burkhardt's Definitions.}
        \label{fig:examplefulltpcc}
\end{figure}
% \begin{figure}%[t]
%      %\begin{center}
%        \includegraphics[width=3.4in,height=2.8in]
%                    {conspecTPCCvar.eps} %\vspace{-5em}
%          %\end{center}
%        \caption{Variance of Execution Time of ConSpec Tool Against TPCC Trace.}
%        \label{fig:examplefullvartpcc}
%\end{figure}
%\begin{figure}%[t]
%        %\begin{center}
%        \includegraphics[width=3.7in,height=3.2in]
%                    {conspecExecutionTimes50Iter.eps} %\vspace{-5em}
%          %\end{center}
%        \caption{Execution Time of ConSpec Tool Against YCSB Trace with sliding Window size of  50.}
%        \label{fig:exampleIter50}
%\end{figure}
%
% \par The approximately linear scalability shown in the previous experiment can be a source of concern for very long traces, e.g., the traces collected from long-running systems. To address these scenarios, we modify the tool to work with only a portion of the global session trace, in a time window of recent events. In particular, we divide the session trace into smaller \emph{trace segments} enclosed within a sliding window, and execute  the tool on  each successive trace segment sequentially.   Figure \ref{fig:exampleIter} depicts the results from a run of the ConSpec tool in this mode of execution, where the size of the input global session traces is plotted along the x axis, and the time taken to verify a session trace containing a sliding window of 5 operations is plotted along the y axis. We increase the size of the session trace to $250,000$ operations, and observe that the tool performs within very reasonable time bounds in the sliding window mode. In particular, the execution time remains below %190 milliseconds and
%   10 millisecond, and varies by up to a factor of approximately 3 times between the fastest and the slowest window to be verified.   Thus, we can conclude that this mode of execution can be a practical approach for handling long-lived systems where the size of the session trace can be very large.
%  \par With the sliding window approach, the tool loops over the input session trace, processing a fixed segment of the trace at a time; the length of the above segment is the same throughout the entire span of the given session trace. During each iteration, the tool processes only a particular segment of the trace and verifies the specification against that segment. Thus, in each iteration of the the above loop, the tool executes  independent of the previous iterations. With increase in the length of the session trace, the verifier takes uniform time to execute each segment comprised in the additional portion of the new session trace. Hence, with increasing size of session trace, the execution time increases in a linear fashion. The demonstrated scalability of the tool makes it a  viable candidate for verifying live enterprise scale application processing petabyte scale datasets.
 \subsection{Evaluation with TPC-C}\label{sec:evaltpcc}
 Analogously to the previous set of experiments, we also ran the TPC-C benchmark for runs of increasing length, and collected global session traces from each run of the TPC-C client. We used an open source java implementation of the TPC-C benchmark developed by CodeFutures Corporation~\cite{Tpcc2015}, and modified the code to record the type of operation  (insert and update queries were marked as write operations, and select queries were marked as read operations), database column, and updated values for each TPC-C operation.  We ran the TPC-C client on a single  machine with a single node MySQL server in the backend. We configured TPC-C with a connection pool of size 30, ramp up time of 30 seconds, and a single warehouse. Before running the TPC-C ``run'' commands, we loaded the TPC-C database tables by running the TPC-C ``load'' command for a period of 60 seconds. Subsequently,  during each experiment, the TPC-C ``run'' command was executed repeatedly, with a duration of 60 seconds for each command, and the global session trace for each experiment was recorded into the TPC-C log files. The size of the log files was gradually increased by increasing the execution time of the TPC-C run command, which, in turn, increased size of the global session trace.  We ran the ConSpec tool against the global session traces that were extracted from the TPC-C log files, where the number of operations performed and the execution time is plotted along the x and y axes, respectively. TPC-C  disallows serialization anomalies and therefore we ran the ConSpec tool with strict serializability. The red points in Figure~\ref{fig:examplefulltpcc} depict the execution time averaged over the five runs, with the red error bars indicating the standard deviations.
 %Each point in the green line represents the average of execution time  observed during 5 runs of the ConSpec tool against a given global session trace of a specific size.  The standard deviation of the execution times observed with each global session trace is  given as a red error bar over the point in the green line which corresponds to the average execution time for that particular global session trace.
      %The coloured stacks in each bar represent the average of execution times of 5 runs of ConSpec tool against a given global session trace, and standard deviation of the respective execution times, respectively.
The results show that the scalability of the tool with the size of the trace follows a pattern that is very similar to the one obtained using YCSB. This suggests that the performance is not very sensitive to the the application and the workloads it generates.

\subsection{Comparison to other definitions}\label{sec:evalcompar}
%  \begin{figure}%[t]
%      %\begin{center}
%        \includegraphics[width=3.7in,height=2.8in]
%                    {conspecTPCCburk.eps} %\vspace{-5em}
%          %\end{center}
%        \caption{Execution Time of ConSpec Tool Against TPCC Trace With respect to Burkhardt's Definition.}
%        \label{fig:examplefulltpccburk}
%\end{figure}


In the final part of the evaluation, we compare ConSpec against a baseline. Since ConSpec is a new language for defining consistency models, we compared it to an existing definition running exactly the same underlying verification system. The definition we chose was based on the work of Burckhardt et al.~\cite{DBLP:journals/ftpl/Burckhardt14}, which we directly encoded in Promela so that we could verify global session traces against this definition using Spin.  Then we compared the time it takes to verify the same traces against these prior definitions from Burckhardt et al.\ and against the corresponding ConSpec definition. For both cases, we chose the RYW definition (referred to as read my writes in Burckhardt et al.~\cite{Burckhardt:2014:PEC:2693641.2693642}). %The ConSpec equivalent of the RYW definition of Burckhardt et al. is given in the PROMELA file as the LTL expression $\forall x \in \mathcal{X}, \mathit{st} \in \mathit{S_t}, O_\mathit{st}^x, {O'}_\mathit{st}^x \in \mathit{st}: \left( \square \left( O_\mathit{st}^x \rightarrow \lozenge {O'}_\mathit{st}^x \right)
 %\rightarrow  \mathit{obj}\left(O_\mathit{st}^x\right) = \mathit{obj}\left({O'}_\mathit{st}^x\right) \right)$, where $\mathit{obj}\left(O_\mathit{st}^x\right)$ and $ \mathit{obj}\left({O'}_\mathit{st}^x\right)$ denote    the objects on which the operations $O$ and ${O'}$, respectively.
 For this comparison, we reused the global session traces collected from TPC-C benchmark experiments in Section \ref{sec:evaltpcc}.

Figure~\ref{fig:examplefulltpcc} shows the results of this comparison, where the results again correspond to the average of 5 runs, and the error bars representing one standard deviation. From Figure \ref{fig:examplefulltpcc}, we can observe the verification time is slightly slower with ConSpec than with the previous definition. Furthermore, the verification time shows comparable scalability with both definitions. %We conclude that, with ConSpec definitions, the tool performs as well as with Burkhardt's. Additionally, Burkhardt's definitions are applicable only to replicated systems whereas ConSpec is independent of the design of the underlying storage system.
 We conclude that, with ConSpec definitions, the tool performs comparably with respect to other existing definition, and that the scalability seems close to linear in both cases.


%%  \par Before we could verify Burckhardt's definitions using ConSpec tool, we had to translate the definitions into the ConSpec syntax as follows.
%%   Burkhardt's definition of RYW is given as
%% \newcommand\myleq{\stackrel{\mathclap{\normalfont\mbox{rb}}}{\leq}}
%% \newcommand\myvis{\stackrel{\mathclap{\normalfont\mbox{vis}}}{\leq}}
%% \newcommand\myss{\stackrel{\mathclap{\normalfont\mbox{ss}}}{\leq}}
%%  %\label{eqn:ltldec}	
%% $\mathit{RYW} \myeq \mathit{so} \subseteq \mathit{vis}$,
%%      where  $\mathit{so}$ and  $\mathit{vis}$ are the relations ``session order" and ``visibility", respectively, defined in \cite{Burckhardt:2014:PEC:2693641.2693642}.
%%      %\label{eqn:ltldec}	
%%    Since $\mathit{so} \myeq \mathit{ss} \wedge \mathit{rb}$, where $\mathit{ss}$ and $\mathit{rb}$ are relations ``same session" and ``return-before", the RYW definition can be rewritten as follows.
%% $\mathit{RYW} \myeq \mathit{ss} \wedge \mathit{rb} \subseteq \mathit{vis}$.
%%     Again, $\mathit{rb}$ is given as $\mathit{rb} \myeq \forall a, b \in E. a \myleq b$, where $E$ is the set of all ``operation events" \cite{Burckhardt:2014:PEC:2693641.2693642}.  $\mathit{vis}$ is defined as an acyclic relation such that $ \forall a, b \in E. a \myvis b \Rightarrow \mathit{obj}(a) = \mathit{obj}(b)$, where $\mathit{obj}(a)$ represents the object on which the operation corresponding to the event $a$ occurs.
%%      Thus, the expression for RYW reduced to
%%    $\mathit{RYW} \myeq  \forall a, b \in E. a \myleq b \wedge a \myss b \Rightarrow \mathit{obj}(a) = \mathit{obj}(b)$.
%%     To verify the above definition of RYW using the ConSpec tool, we rewrite the special-purpose relations  $\myleq$ and $\myss$ in terms of the syntax of ConSpec.  The ConSpec operator $\operatorname{\it F}_\mathit{st}$ is equivalent to the relation $\myss$. By definition of the ConSpec operator $\operatorname{\it F}_\mathit{st}$,  $\forall a, b \in E. a \myleq b \wedge a \myss b$ is equivalent to  $\forall \mathit{st} \in \mathcal{S}_t,\;  a, b \in \mathit{st}:\;  a \operatorname{\it F}_\mathit{st} b$. Thus, the RYW definition in \cite{Burckhardt:2014:PEC:2693641.2693642} is reduced to the following form.
%%     $\mathit{RYW} \myeq  \quad \forall \mathit{st} \in \mathcal{S}_t,\;  a, b \in \mathit{st} :
%%   a \operatorname{\it F}_\mathit{st} b
%%  \Rightarrow  \mathit{obj}(a) = \mathit{obj}(b)$.  Additionally, we implement $\mathit{obj}(a)$ as a new function in the ConSpec tool.
%%      \par However, Burkhardt's definitions usually get much lengthier and difficult to comprehend than the example described above. Let us consider the Causal Consistency model (referred to as Causality in ), defined as $%\label{eqn:ltldec}	
%% \mathit{Causal Consistency} \myeq \mathit{Causal Visibility} \subseteq \mathit{Causal Arbitration}$,
%%  where  $\mathit{Causal Visibility} \myeq \left(\mathit{hb} \subseteq \mathit{vis}\right)$ and $\mathit{Causal Arbitration} \myeq \left(\mathit{hb} \subseteq \mathit{ar}\right)$.  Again, the relation happens-before order $\mathit{hb}$ is defined as  ${\left( \mathit{hb} \myeq \mathit{ss} \vee \mathit{vis}\right)}^{+}$,  respectively. Hence we can rewrite the expression for Causal Consistency as  $\mathit{Causal Consistency} \myeq \left( {\left( \mathit{hb} \myeq \mathit{ss} \vee \mathit{vis}\right)}^{+}  \Rightarrow \mathit{vis} \right) \wedge \left( {\left( \mathit{hb} \myeq \mathit{ss} \vee \mathit{vis}\right)}^{+}  \Rightarrow \mathit{ar} \right)$ . In terms of ConSpec syntax, the above definition reduces to: \\
%%   $ \forall \mathit{st} \in \mathcal{S}_t,\;  a, b \in \mathit{st} :
%%   a \operatorname{\it F}_\mathit{st} b \quad   \mathit{obj}(a) = \mathit{obj}(b)  \quad
%%  \Rightarrow  \mathit{obj}(a) = \mathit{obj}(b) \quad \wedge \quad a \operatorname{\it F}_\mathit{st} b \quad \vee \quad   \mathit{obj}(a) = \mathit{obj}(b)  \quad \Rightarrow \quad a \operatorname{\it F}_\mathit{st} b \vee b \operatorname{\it F}_\mathit{st} a
%%    $, where the relation arbitration $\mathit{ar}$ is a total order defined as  $\forall \mathit{st} \in \mathcal{S}_t,\;  a, b \in \mathit{st}  \mathit{ar} \myeq \left(a \operatorname{\it F}_\mathit{st} b \vee b \operatorname{\it F}_\mathit{st} a\right)$. This definition is much more lengthy and complicated that the definition of Causal Consistency given in terms of ConSpec in Equation \ref{eqn:Causal}. Thus in contrast with Burkhardt's definitions, ConSpec definitions bring about a uniform sense of simplicity for all consistency models irrespective of their degree of strength.  Further, Burkhardt's definition of Causal consistency is expressed in terms of the relation $\mathit{ar}$ which is tied to properties of the underlying implementation, namely the protocol for resolving concurrent operations. In contrast, ConSpec definitions do not address the ordering between concurrent operations since they are equivalent with respect to the partial order $\preccurlyeq$.
  
\section{Conclusions} \label{sec:conc}
In this paper, we presented a generic framework called ConSpec for defining consistency. ConSpec enables definitions that are precise, follow a generic structure, and are independent of implementation details. We used ConSpec to derive several concrete definitions of existing consistency levels. Furthermore, ConSpec also enabled a generic version of the CAP theorem, where the ``C'' property is no longer tied to a specific strong consistency definition. Instead, we define necessary and sufficient conditions for a consistency level to be within the scope of CAP, i.e., for the existence or not of a partition tolerant and available implementation.
Finally, we developed and evaluated an automated tool for verifying whether a given session trace satisfies a consistency model.

ConSpec opens several interesting avenues for future work. First, we intend to apply ConSpec to a wider range of consistency models. Second, we intend to extend it to support isolation levels of transactional systems, where the visibility of individual operations within a transaction must be constrained. Finally, we intend to further develop our automatic verification tool and promote its adoption by the developer community.

%, specified using ConSpec.  %We believe that verification tools based on ConSpec specifications (like the one we presented) should perform better and more reliably than current state-of-the-art tools.
%  In future, we plan to keep working in this direction, and aim to develop an end-to-end framework for building and verifying correct applications and storage systems, based on our generalized specifications.  We also plan to extend ConSpec to specify isolations levels using the same generalized semantics used to define consistency models in this paper.

%\section{SpecCheck: Automated Verification With ConSpec}



% \def\tuple#1{\langle #1\rangle}
%
%   \par According to the state-of-the-art definitions, the specification for Processor Consistency is of the largest size. The total number of characters in the rules for Processor Consistency is  30. It also comprises 3 DSGs, each with 3, 7, and 3 vertices, respectively. Then, using the formula 2V+1 for analyzing the DSGs using Depth first search, the  complexity of DSG analyzing is approximately $(5+13+5) \times s_t$ = $23 \times s_t$. Thus the total complexity of verifying Processor consistency is approximately $53 \times s_t$. On the other hand, the size of the ConSpec specification for Processor Consistency is 31, not counting parenthesis, punctuation symbols, and scope operators. Thus, the complexity of analysis using ConSpec is $31 \times s_t$. Thus, the complexity of verification using ConSpec is considerably less than that using the state-of-the-art. Similarly, it can be shown that the complexity of verifying other consistency models and isolation levels are also lower with ConSpec.

 %$\square \lozenge \oplus \wedge \Rightarrow \models \lnot$
%The \textit{proceedings} are the records of a conference.
%ACM seeks to give these conference by-products a uniform,
%high-quality appearance.  To do this, ACM has some rigid
%requirements for the format of the proceedings documents: there
%is a specified format (balanced  double columns), a specified
%set of fonts (Arial or Helvetica and Times Roman) in
%certain specified sizes (for instance, 9 point for body copy),
%a specified live area (18 $\times$ 23.5 cm [7" $\times$ 9.25"]) centered on
%the page, specified size of margins (1.9 cm [0.75"]) top, (2.54 cm [1"]) bottom
%and (1.9 cm [.75"]) left and right; specified column width
%(8.45 cm [3.33"]) and gutter size (.83 cm [.33"]).
%
%The good news is, with only a handful of manual
%settings\footnote{Two of these, the {\texttt{\char'134 numberofauthors}}
%and {\texttt{\char'134 alignauthor}} commands, you have
%already used; another, {\texttt{\char'134 balancecolumns}}, will
%be used in your very last run of \LaTeX\ to ensure
%balanced column heights on the last page.}, the \LaTeX\ document
%class file handles all of this for you.
%
%The remainder of this document is concerned with showing, in
%the context of an ``actual'' document, the \LaTeX\ commands
%specifically available for denoting the structure of a
%proceedings paper, rather than with giving rigorous descriptions
%or explanations of such commands.
%
%\section{The {\secit Body} of The Paper}
%Typically, the body of a paper is organized
%into a hierarchical structure, with numbered or unnumbered
%headings for sections, subsections, sub-subsections, and even
%smaller sections.  The command \texttt{{\char'134}section} that
%precedes this paragraph is part of such a
%hierarchy.\footnote{This is the second footnote.  It
%starts a series of three footnotes that add nothing
%informational, but just give an idea of how footnotes work
%and look. It is a wordy one, just so you see
%how a longish one plays out.} \LaTeX\ handles the numbering
%and placement of these headings for you, when you use
%the appropriate heading commands around the titles
%of the headings.  If you want a sub-subsection or
%smaller part to be unnumbered in your output, simply append an
%asterisk to the command name.  Examples of both
%numbered and unnumbered headings will appear throughout the
%balance of this sample document.
%
%Because the entire article is contained in
%the \textbf{document} environment, you can indicate the
%start of a new paragraph with a blank line in your
%input file; that is why this sentence forms a separate paragraph.
%
%\subsection{Type Changes and {\subsection Special} Characters}
%We have already seen several typeface changes in this sample.  You
%can indicate italicized words or phrases in your text with
%the command \texttt{{\char'134}textit}; emboldening with the
%command \texttt{{\char'134}textbf}
%and typewriter-style (for instance, for computer code) with
%\texttt{{\char'134}texttt}.  But remember, you do not
%have to indicate typestyle changes when such changes are
%part of the \textit{structural} elements of your
%article; for instance, the heading of this subsection will
%be in a sans serif\footnote{A third footnote, here.
%Let's make this a rather short one to
%see how it looks.} typeface, but that is handled by the
%document class file. Take care with the use
%of\footnote{A fourth, and last, footnote.}
%the curly braces in typeface changes; they mark
%the beginning and end of
%the text that is to be in the different typeface.
%
%You can use whatever symbols, accented characters, or
%non-English characters you need anywhere in your document;
%you can find a complete list of what is
%available in the \textit{\LaTeX\
%User's Guide}\cite{Lamport:LaTeX}.
%
%\subsection{Math Equations}
%You may want to display math equations in three distinct styles:
%inline, numbered or non-numbered display.  Each of
%the three are discussed in the next sections.
%
%\subsubsection{Inline (In-text) Equations}
%A formula that appears in the running text is called an
%inline or in-text formula.  It is produced by the
%\textbf{math} environment, which can be
%invoked with the usual \texttt{{\char'134}begin. . .{\char'134}end}
%construction or with the short form \texttt{\$. . .\$}. You
%can use any of the symbols and structures,
%from $\alpha$ to $\omega$, available in
%\LaTeX\cite{Lamport:LaTeX}; this section will simply show a
%few examples of in-text equations in context. Notice how
%this equation: \begin{math}\lim_{n\Rightarrow \infty}x=0\end{math},
%set here in in-line math style, looks slightly different when
%set in display style.  (See next section).
%
%\subsubsection{Display Equations}
%A numbered display equation -- one set off by vertical space
%from the text and centered horizontally -- is produced
%by the \textbf{equation} environment. An unnumbered display
%equation is produced by the \textbf{displaymath} environment.
%
%Again, in either environment, you can use any of the symbols
%and structures available in \LaTeX; this section will just
%give a couple of examples of display equations in context.
%First, consider the equation, shown as an inline equation above:
%\begin{equation}\lim_{n\Rightarrow \infty}x=0\end{equation}
%Notice how it is formatted somewhat differently in
%the \textbf{displaymath}
%environment.  Now, we'll enter an unnumbered equation:
%\begin{displaymath}\sum_{i=0}^{\infty} x + 1\end{displaymath}
%and follow it with another numbered equation:
%\begin{equation}\sum_{i=0}^{\infty}x_i=\int_{0}^{\pi+2} f\end{equation}
%just to demonstrate \LaTeX's able handling of numbering.
%
%\subsection{Citations}
%Citations to articles \cite{bowman:reasoning,
%clark:pct, braams:babel, herlihy:methodology},
%conference proceedings \cite{clark:pct} or
%books \cite{salas:calculus, Lamport:LaTeX} listed
%in the Bibliography section of your
%article will occur throughout the text of your article.
%You should use BibTeX to automatically produce this bibliography;
%you simply need to insert one of several citation commands with
%a key of the item cited in the proper location in
%the \texttt{.tex} file \cite{Lamport:LaTeX}.
%The key is a short reference you invent to uniquely
%identify each work; in this sample document, the key is
%the first author's surname and a
%word from the title.  This identifying key is included
%with each item in the \texttt{.bib} file for your article.
%
%The details of the construction of the \texttt{.bib} file
%are beyond the scope of this sample document, but more
%information can be found in the \textit{Author's Guide},
%and exhaustive details in the \textit{\LaTeX\ User's
%Guide}\cite{Lamport:LaTeX}.
%
%This article shows only the plainest form
%of the citation command, using \texttt{{\char'134}cite}.
%This is what is stipulated in the SIGS style specifications.
%No other citation format is endorsed or supported.
%
%\subsection{Tables}
%Because tables cannot be split across pages, the best
%placement for them is typically the top of the page
%nearest their initial cite.  To
%ensure this proper ``floating'' placement of tables, use the
%environment \textbf{table} to enclose the table's contents and
%the table caption.  The contents of the table itself must go
%in the \textbf{tabular} environment, to
%be aligned properly in rows and columns, with the desired
%horizontal and vertical rules.  Again, detailed instructions
%on \textbf{tabular} material
%is found in the \textit{\LaTeX\ User's Guide}.
%
%Immediately following this sentence is the point at which
%Table 1 is included in the input file; compare the
%placement of the table here with the table in the printed
%dvi output of this document.
%
%\begin{table}
%\centering
%\caption{Frequency of Special Characters}
%\begin{tabular}{|c|c|l|} \hline
%Non-English or Math&amp;Frequency&amp;Comments\\ \hline
%\O &amp; 1 in 1,000&amp; For Swedish names\\ \hline
%$\pi$ &amp; 1 in 5&amp; Common in math\\ \hline
%\$ &amp; 4 in 5 &amp; Used in business\\ \hline
%$\Psi^2_1$ &amp; 1 in 40,000&amp; Unexplained usage\\
%\hline\end{tabular}
%\end{table}
%
%To set a wider table, which takes up the whole width of
%the page's live area, use the environment
%\textbf{table*} to enclose the table's contents and
%the table caption.  As with a single-column table, this wide
%table will ``float" to a location deemed more desirable.
%Immediately following this sentence is the point at which
%Table 2 is included in the input file; again, it is
%instructive to compare the placement of the
%table here with the table in the printed dvi
%output of this document.
%
%
%\begin{table*}
%\centering
%\caption{Some Typical Commands}
%\begin{tabular}{|c|c|l|} \hline
%Command&amp;A Number&amp;Comments\\ \hline
%\texttt{{\char'134}alignauthor} &amp; 100&amp; Author alignment\\ \hline
%\texttt{{\char'134}numberofauthors}&amp; 200&amp; Author enumeration\\ \hline
%\texttt{{\char'134}table}&amp; 300 &amp; For tables\\ \hline
%\texttt{{\char'134}table*}&amp; 400&amp; For wider tables\\ \hline\end{tabular}
%\end{table*}
%% end the environment with {table*}, NOTE not {table}!
%
%\subsection{Figures}
%Like tables, figures cannot be split across pages; the
%best placement for them
%is typically the top or the bottom of the page nearest
%their initial cite.  To ensure this proper ``floating'' placement
%of figures, use the environment
%\textbf{figure} to enclose the figure and its caption.
%
%This sample document contains examples of \textbf{.eps} files to be
%displayable with \LaTeX.  If you work with pdf\LaTeX, use files in the
%\textbf{.pdf} format.  Note that most modern \TeX\ system will convert
%\textbf{.eps} to \textbf{.pdf} for you on the fly.  More details on
%each of these is found in the \textit{Author's Guide}.
%
%\begin{figure}
%\centering
%\includegraphics{fly}
%\caption{A sample black and white graphic.}
%\end{figure}
%
%\begin{figure}
%\centering
%\includegraphics[height=1in, width=1in]{fly}
%\caption{A sample black and white graphic
%that has been resized with the \texttt{includegraphics} command.}
%\end{figure}
%
%
%As was the case with tables, you may want a figure
%that spans two columns.  To do this, and still to
%ensure proper ``floating'' placement of tables, use the environment
%\textbf{figure*} to enclose the figure and its caption.
%and don't forget to end the environment with
%{figure*}, not {figure}!
%
%\begin{figure*}
%\centering
%\includegraphics{flies}
%\caption{A sample black and white graphic
%that needs to span two columns of text.}
%\end{figure*}
%
%
%\begin{figure}
%\centering
%\includegraphics[height=1in, width=1in]{rosette}
%\caption{A sample black and white graphic that has
%been resized with the \texttt{includegraphics} command.}
%\vskip -6pt
%\end{figure}
%
%\subsection{Theorem-like Constructs}
%Other common constructs that may occur in your article are
%the forms for logical constructs like theorems, axioms,
%corollaries and proofs.  There are
%two forms, one produced by the
%command \texttt{{\char'134}newtheorem} and the
%other by the command \texttt{{\char'134}newdef}; perhaps
%the clearest and easiest way to distinguish them is
%to compare the two in the output of this sample document:
%
%This uses the \textbf{theorem} environment, created by
%the\linebreak\texttt{{\char'134}newtheorem} command:
%\newtheorem{theorem}{Theorem}
%\begin{theorem}
%Let $f$ be continuous on $[a,b]$.  If $G$ is
%an antiderivative for $f$ on $[a,b]$, then
%\begin{displaymath}\int^b_af(t)dt = G(b) - G(a).\end{displaymath}
%\end{theorem}
%
%The other uses the \textbf{definition} environment, created
%by the \texttt{{\char'134}newdef} command:
%\newdef{definition}{Definition}
%\begin{definition}
%If $z$ is irrational, then by $e^z$ we mean the
%unique number which has
%logarithm $z$: \begin{displaymath}{\log e^z = z}\end{displaymath}
%\end{definition}
%
%Two lists of constructs that use one of these
%forms is given in the
%\textit{Author's  Guidelines}.
%
%There is one other similar construct environment, which is
%already set up
%for you; i.e. you must \textit{not} use
%a \texttt{{\char'134}newdef} command to
%create it: the \textbf{proof} environment.  Here
%is a example of its use:
%\begin{proof}
%Suppose on the contrary there exists a real number $L$ such that
%\begin{displaymath}
%\lim_{x\Rightarrow\infty} \frac{f(x)}{g(x)} = L.
%\end{displaymath}
%Then
%\begin{displaymath}
%l=\lim_{x\Rightarrow c} f(x)
%= \lim_{x\Rightarrow c}
%\left[ g{x} \cdot \frac{f(x)}{g(x)} \right ]
%= \lim_{x\Rightarrow c} g(x) \cdot \lim_{x\Rightarrow c}
%\frac{f(x)}{g(x)} = 0\cdot L = 0,
%\end{displaymath}
%which contradicts our assumption that $l\neq 0$.
%\end{proof}
%
%Complete rules about using these environments and using the
%two different creation commands are in the
%\textit{Author's Guide}; please consult it for more
%detailed instructions.  If you need to use another construct,
%not listed therein, which you want to have the same
%formatting as the Theorem
%or the Definition\cite{salas:calculus} shown above,
%use the \texttt{{\char'134}newtheorem} or the
%\texttt{{\char'134}newdef} command,
%respectively, to create it.
%
%\subsection*{A {\secit Caveat} for the \TeX\ Expert}
%Because you have just been given permission to
%use the \texttt{{\char'134}newdef} command to create a
%new form, you might think you can
%use \TeX's \texttt{{\char'134}def} to create a
%new command: \textit{Please refrain from doing this!}
%Remember that your \LaTeX\ source code is primarily intended
%to create camera-ready copy, but may be converted
%to other forms -- e.g. HTML. If you inadvertently omit
%some or all of the \texttt{{\char'134}def}s recompilation will
%be, to say the least, problematic.
%
%\section{Conclusions}
%This paragraph will end the body of this sample document.
%Remember that you might still have Acknowledgments or
%Appendices; brief samples of these
%follow.  There is still the Bibliography to deal with; and
%we will make a disclaimer about that here: with the exception
%of the reference to the \LaTeX\ book, the citations in
%this paper are to articles which have nothing to
%do with the present subject and are used as
%examples only.
%%\end{document}  % This is where a 'short' article might terminate
%
%%ACKNOWLEDGMENTS are optional
%\section{Acknowledgments}
%This section is optional; it is a location for you
%to acknowledge grants, funding, editing assistance and
%what have you.  In the present case, for example, the
%authors would like to thank Gerald Murray of ACM for
%his help in codifying this \textit{Author's Guide}
%and the \textbf{.cls} and \textbf{.tex} files that it describes.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
%\section{Acknowledgement}
%The project is partially supported by Army Research Office (ARO) under Grant W911\-NF1010495.  Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the ARO or the United States Government. Wojciech Golab is supported in part by the Natural Sciences and Engineering Research Council (NSERC) of Canada. Subhajit Sidhanta is supported in part by the Amazon AWS (Amazon Web Services) Research Grant.
\Urlmuskip=0mu plus 1mu\relax
\renewcommand{\bibfont}{\footnotesize}
\bibliographystyle{IEEEtran}
%\bibliography{Consistency1}
%\bibliographystyle{abbrv}
\bibliography{allrec}

%\bibliographystyle{acm}
%\bibliography{allrec}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
%\appendix
%%Appendix A
%\section{Headings in Appendices}
%The rules about hierarchical headings discussed above for
%the body of the article are different in the appendices.
%In the \textbf{appendix} environment, the command
%\textbf{section} is used to
%indicate the start of each Appendix, with alphabetic order
%designation (i.e. the first is A, the second B, etc.) and
%a title (if you include one).  So, if you need
%hierarchical structure
%\textit{within} an Appendix, start with \textbf{subsection} as the
%highest level. Here is an outline of the body of this
%document in Appendix-appropriate form:
%\subsection{Introduction}
%\subsection{The Body of the Paper}
%\subsubsection{Type Changes and  Special Characters}
%\subsubsection{Math Equations}
%\paragraph{Inline (In-text) Equations}
%\paragraph{Display Equations}
%\subsubsection{Citations}
%\subsubsection{Tables}
%\subsubsection{Figures}
%\subsubsection{Theorem-like Constructs}
%\subsubsection*{A Caveat for the \TeX\ Expert}
%\subsection{Conclusions}
%\subsection{Acknowledgments}
%\subsection{Additional Authors}
%This section is inserted by \LaTeX; you do not insert it.
%You just add the names and information in the
%\texttt{{\char'134}additionalauthors} command at the start
%of the document.
%\subsection{References}
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
%% This next section command marks the start of
%% Appendix B, and does not continue the present hierarchy
%\section{More Help for the Hardy}
%The sig-alternate.cls file itself is chock-full of succinct
%and helpful comments.  If you consider yourself a moderately
%experienced to expert user of \LaTeX, you may find reading
%it useful but please remember not to change it.
%\balancecolumns % GM June 2007
% That's all folks!


%\begin{lstlisting}
%-------------------------------- MODULE RYW --------------------------------
%
%EXTENDS Naturals, TLC
%CONSTANT N
%VARIABLE el, op_i, op_j, x_i, x_j, v_i, v_j, W_i, R_j, sip, i, j, el1 , op_i1, op_j1, x_i1, x_j1, v_i1, v_j1, W_i1, R_j1, i1, j1
%
%st == {&lt;&lt;1, "w","x",1&gt;&gt;, &lt;&lt;2, "w","x",2&gt;&gt;, &lt;&lt;3, "r","x",2&gt;&gt;, &lt;&lt;4, "r", "x", 1&gt;&gt;}
%St == {&lt;&lt;1,"w","x",1&gt;&gt;, &lt;&lt;2,"r","x",2&gt;&gt;, &lt;&lt;3,"w","x",2&gt;&gt;, &lt;&lt;4,"r","x",1&gt;&gt;}
%perm == Permutations(st)
%
%Init  ==  /\ el \in st  /\ op_i \in {"r", "w"}  /\ op_j \in {"r", "w"}
%          /\ x_i \in {"x", "y"}  /\ x_j \in {"x", "y"}  /\ i \in 1..999
%          /\ j \in 1..999  /\ v_i \in 1..999  /\ v_j \in 1..999  /\ W_i \in 1..999
%          /\ R_j \in 1..999
%          /\ sip \in {RandomElement(perm) : p \in perm}
%          /\ el1 \in St /\ op_i1 \in {"r", "w"}  /\ op_j1 \in {"r", "w"}
%          /\ x_i1 \in {"x", "y"}  /\ x_j1 \in {"x", "y"}  /\ /\ i1 \in 1..999
%          /\ j1 \in 1..999 /\ v_i1 \in 1..999
%          /\ v_j1 \in 1..999  /\ W_i1 \in 1..999 /\ R_j1 \in 1..999
%
%Next  ==  (/\ el' \in St
%          /\ op_i' = IF el'[2] = "w" THEN el'[2] ELSE "999999999"
%          /\ op_j' = IF el'[2] = "r" THEN el'[2] ELSE "9999999"
%          /\ x_i' = IF op_i' = "w" THEN el'[3] ELSE "999999"
%          /\ x_j' = IF op_j' = "r" THEN el'[3] ELSE "99999"
%          /\ i' = IF op_i' = "w" THEN el'[1] ELSE 999999
%          /\ j' = IF op_j' = "r" THEN el'[1] ELSE 999999
%          /\ v_i' = IF op_i' = "w" THEN el'[4] ELSE 999
%          /\ v_j' = IF op_j' = "r" THEN el'[4] ELSE 999
%          /\ W_i' = IF op_i' = "w" THEN v_i' ELSE 9999
%          /\ R_j' = IF op_j' = "r" THEN v_j' ELSE 9999 )
%          \/ ( el1' \in st
%          /\ op_i1' = IF el1'[2] = "w" THEN el'[2] ELSE "999999999"
%          /\ op_j1' = IF el1'[2] = "r" THEN el'[2] ELSE "9999999"
%          /\ x_i1' = IF op_i1' = "w" THEN el'[3] ELSE "999999"
%          /\ x_j1' = IF op_j' = "r" THEN el'[3] ELSE "99999"
%          /\ i1' = IF op_i1' = "w" THEN el'[1] ELSE 999999
%          /\ j1' = IF op_j1' = "r" THEN el'[1] ELSE 999999
%          /\ v_i1' = IF op_i1' = "w" THEN el'[4] ELSE 999
%          /\ v_j1' = IF op_j1' = "r" THEN el'[4] ELSE 999
%          /\ W_i1' = IF op_i1' = "w" THEN v_i' ELSE 9999
%          /\ R_j1' = IF op_j1' = "r" THEN v_j' ELSE 9999
%          /\ sip' = RandomElement(perm) )
%
%
%LHS == (W_i =&gt; &lt;&gt; R_j) /\ W_i = W_i1 /\ W_i # 9999 /\ R_j # 9999 /\ x_i = x_j /\ (W_i1 =&gt; &lt;&gt; R_j1) /\ R_j1 = R_j1 \*W_i =&gt; &lt;&gt; R_j /\ W_i = R_j /\ W_i # 9999 /\ R_j # 9999 /\ x_i = x_j
%
%RHS == \E s \in sip : [] W_i =&gt; &lt;&gt; R_j  \* /\  PrintT(sip) &lt;&gt; W_i =&gt; &lt;&gt; R_j
%
%Spec  ==  /\ Init /\ [] [Next]_&lt;&lt;el, v_i, v_j, x_i, x_j, op_i, op_j, W_i, R_j, i, j, el1, v_i1, v_j1, x_i1, x_j1, op_i1, op_j1, W_i1, R_j1, i1, j1&gt;&gt;
%
%TypeInvariant  ==  st # {}  \* /\  PrintT(sip)
%
%-----------------------------------------------------------------------
%THEOREM Spec =&gt; [] TypeInvariant /\ LHS \*E_s \/ C
%=============================================================================
%\* Modification History
%\* Last modified Sun Dec 25 17:27:39 GMT 2016 by user
%\* Last modified Mon Dec 12 00:22:23 GMT 2016 by ssidha1
%\* Created Fri Dec 09 12:03:16 GMT 2016 by user
%
%\end{lstlisting}

\section{Appendix}
 \subsection{Specifying  More Existing Consistency Models}\label{sec:morelist}
\added[id=1]{In this section, we present the ConSpec specifications for several other common
consistency models. }
 We start by specifying a series of session guarantees, which were originally proposed by Terry et al.\ in the context of a mobile computing storage system called Bayou~\cite{Terry:1994:SGW:645792.668302}. These are four guarantees that apply to individual sessions, allowing applications to see a view of the storage system that is consistent with their previous operations.
  \subsection{Read Your Writes}
  
  The Read Your Writes (RYW) session guarantee informally precludes a read operation $r(x)v$  from reading a value for object $x$ that precedes a value the same client previously wrote to the same object in the same session.
  % stated as follows. Let us consider that a client application performs
  %    a write operation followed by a read operation on an object $o$, observed in any given session trace, obtained by executing the above client application.
  %    According to RYW, given a session trace,  a read operation within that trace must not observe the result of an earlier write
  %    operation, i.e., it may not observe a value written before the occurrence of the write operation which
  %    immediately precedes the read. In other words, RYW specifies: if an operation $r^j$ reads an object $o$
  %    that was written by a  write $w^i$,  the $r^j$ must not return the value written by write operation $w^k$ that
  %    may have preceded $w^i$.
  %     In other words, it requires that $v_i \not= v_k$, where $\not=$ denotes the traditional arithmetic operator not equals.
  %Let $\wedge$ be the logical operator for conjunction. An expression $A \wedge B$ denotes that both the conditions represented by the propositional logic variables $A$ and $B$ must hold.
  %Similarly, let $\oplus$ be the logical operator ``exclusive-or" (x-or). An expression $C \oplus D$ denotes that either $C$ is true or $D$ is true, but both $C$ and $D$ can not be true or false simultaneously.
  %RYW states: if there exist multiple writes in the session trace preceding the read $r^k(o){v_m}$, $r^k(o){v_m}$ must reflect the result of the most recent write $w^j(o,v_l)$ preceding $r^k(o){v_m}$. Let the propositional logic variables $W^j(v_l)$ and $R^k{v_m}$ represent the events that results of a write operation $w^j(o,v_l)$ and a read operation $r^k(o){v_m}$, respectively, are either observed (or not) in a session trace or the above operations occur in a program order (indicated by the value of the above variables being TRUE or FALSE). Let the wild card character $\star$ is a ``placeholder" for any combination of propositional variables (or none). For example, the expression $* A$ denotes that the propositional variable $A$ maybe preceded by any number of propositional variables, or maybe preceded by nothing.
  %  We use serialization of a partial execution $S_p$, specified in Definition \ref{def:parser}, to denote a legal serialization of all operations comprising a given client
  %  application, as well as all write
  %  operations  executed from all other concurrent client applications.
  Following the format of Definition \ref{def:form0}, RYW can be defined by the following restrictions on $\preccurlyeq$.
  
  %\begin{align}\label{eqn:RYW}
  %\begin{split}
  % \forall i \left(\star w^j_{tx}(o,v_l)X^{o}r^k_{tx}(o){v_m} \star \right)_{o}^\mathit{po} \vdash \left(G\; \star w(o,v)X^{o}r(o) \star \right)_{o}^\mathit{st},
  %  \end{split}
  %  \end{align}
  %\begin{align}
  %  \begin{split}
  %\forall i, j, k, l, m, n, p, q \left(\star W^j(v_l)X^{o}R^k{v_m}\star\right)_{o}^\mathit{po}\\ \Rightarrow \left(G\; \left( W^j(v_l) F^{o} W^p(v_q) F^{o} R^k{v_m} \right) \oplus \left( v_m = v_l \right) \right)_{o}^\mathit{st},
  %  \end{split}
  %  \end{align}\label{eqn:RYW}
  % \begin{align}
  %  \begin{split}
  %\forall i, j, k, l, m, n, p, q \left(\star W^j(v_m)F^{o}W^k(v_n)X^{o}R^l{v_p}\star\right)_{o}^\mathit{po}\\
  %\Rightarrow \big(G\; \left( \star W^j(v_m)F^{o}W^k(v_n)F^{o}R^l{v_p}\star \right) \\
  % \oplus \left(  \star W^k(v_n)F^{o}W^j(v_m)F^{o}R^l{v_p}\star \right) \big)_{o}^\mathit{st},
  %  \end{split}
  %  \end{align}\label{eqn:RYW}
  \begin{align}\label{eqn:RYW}
  \begin{split}
  %  \mathcal{E}^{s} = \forall  \mathit{st} \in \mathcal{S}_t, {W^i}^{'}, {R^j}^{'} \in \mathit{st}
  %  \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right)
  % \Rightarrow \; \exists S_p \\
  % \left(  {W^i}^{'} F {R^j}^{'} \in S_p \right)\big).
  % \mathcal{E}^{s} = \forall  {W^i}^{'}, {R^j}^{'} \in \mathit{st}
  %  \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right)
  % \Rightarrow \\
  % \left(  {W^i}^{'} \preccurlyeq_{\mathit{st}+w} {R^j}^{'} \right)\big),
  %E^S_C = \quad \forall st \in \mathcal{S}_t, \;  {W}'(x), {R}'(x) \in \mathit{st} : \\
  E^S_C =  \forall x \in \mathcal{X}, \mathit{st} \in  \mathcal{S}_t, W_\mathit{st}^x, R_\mathit{st}^x \in \mathit{st}:
  \\ \left( \square \left( W_\mathit{st}^x \rightarrow \lozenge R_\mathit{st}^x \right)
  \rightarrow  W_\mathit{st}^x  \preccurlyeq_{\mathit{st}+w} R_\mathit{st}^x \right),
  %C = \left( \not\exists {R^k}^{'}, {W^l}^{'} \in \mathcal{S}_t \right)   \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
  %\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right)   \\ \wedge
  %%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
  %\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right)  %\big) \\
  %\wedge \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge  \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
  %\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)  \wedge
  %  \not\exists {W^m}^{'} \left( {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big).
  \end{split}
  \end{align} where $\mathit{st}\in \mathcal{S}_t$ is the session from the standpoint of which the session guarantees are being upheld.
  $W_\mathit{st}^x$ and $R_\mathit{st}^x$ are LTL variables which denote the occurrence of a write operation $w(x,v)$ and a read operation $r(x){v'}$ on an object $x$ in the session trace $\mathit{st}$, respectively.
  %$\mathit{st}\in \mathcal{S}_t$ is the session from the standpoint of which the session guarantees are being upheld, and
  The notation $\preccurlyeq_{\mathit{st}+w}$ denotes the restriction of partial order $\preccurlyeq$ to the elements of $\mathit{st}$ and the write operations of all other clients. %The LTL expression ${W}' \operatorname{\it F}_\mathit{st} {R}'
  %\Rightarrow
  %{W}' \preccurlyeq_{\mathit{st}+w} {R}'$ in the above definition implies:
  In a nutshell, this restriction states that if $r(x){v'}$ %eventually becomes true
  appears after $w(x,v)$ in a session trace $\mathit{st}$, %(i.e., operation $w(x,v)$ is eventually followed by the operation  $r(x){v}$ in $\mathit{st}$),
  then there must exist a partial order $\preccurlyeq_{\mathit{st}+w}$ such that $w(x,v) \preccurlyeq_{\mathit{st}+w} r(x){v'}$ holds (i.e., $\preccurlyeq_{\mathit{st}+w}$ orders $w(x,v)$ before $r(x){v'}$).
  
  
  \noindent \emph{\textbf{Examples.}}
  To illustrate how a trace that does not obey RYW fails to meet this definition, consider the
  session trace
  
  $\mathit{st}_1$: $w(x,1), w'(x,2), r(x){2}, r'(x){1}$.
  
  
  Since Condition 1 in Definition \ref{def:form0} constrains that the partial orders in the ConSpec definition must be such that reads return the value written by the latest preceding write according to a linear extension of the partial order, then this session trace can only correspond to one of the following linear extensions of a partial order. \begin{itemize}
  	\item $\preccurlyeq_{\mathit{st}+w}^1$ = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 W'^x_{\mathit{st}}
  	\preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}$
  	\item $\preccurlyeq_{\mathit{st}+w}^2$ = $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 R'^x_{\mathit{st}}$
  	\item $\preccurlyeq_{\mathit{st}+w}^3$ = $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 R'^x_{\mathit{st}}$
  \end{itemize}
  For $\mathit{st}_1$ to satisfy RYW, one of these orders must meet the condition expressed in Equation~\ref{eqn:RYW}. This  states that, for all write follows read sequences that satisfy the left hand side of the implication in $E^S_C$, the partial order must order those pairs of operations (and consequently its linear extension also does so). Next, we analyze, for all pairs of read and write operations where the write precedes the read in the same session, whether any of these orders meets that condition.
  
  In $\mathit{st}_1$, the read operation $r(x){2}$
  follows the write operation $w(x,1)$, i.e., this pair of operations meets the LTL expression $\square W^x_{\mathit{st}} \rightarrow \lozenge R^x_{\mathit{st}}$ in the left hand side of the implication in $E^S_C$ given in Equation \ref{eqn:RYW}. %, where $W^i$ = $W^1$, $R^j$ = $R^1$.
  For this write-read pair, only for $\preccurlyeq_{\mathit{st}+w}^1$, the condition $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}$ holds. %, which does not hold for .
  Thus, only $\preccurlyeq_{\mathit{st}+w}^1$ satisfies the right hand side of the implication in Equation \ref{eqn:RYW} for one of the write-read pairs in the global session trace. %, holds.
  %$W^k$ preceding  $W^1$ such that the above LTL condition holds.
  Next, we consider the % sequence in the session trace where the
  write operation $w(x,1)$ followed by the read operation  $r'(x){1}$, which also satisfies the left hand side of the implication in Equation  \ref{eqn:RYW}. %, expressed by the LTL expression $\square W^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$. %As discussed before, a partial
  For partial order $\preccurlyeq_{\mathit{st}+w}^1$, %exists for the session trace such that
  the condition $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R'^x_{\mathit{st}}$ holds, thus satisfying the
  the right hand side of the implication in Equation \ref{eqn:RYW}.
  %Also, following the same argument as
  %   above, there does not exist a $w^k$ such that the temporal order represented by the LTL condition $W^k F^x W^1 F^x R^2$ holds.
  Next, we consider the write operation $w'(x,2)$ followed by the read $r(x){2}$ in that session trace, which also satisfies the left hand side of the implication in Equation~\ref{eqn:RYW}.
  %This implies that the condition $\square W'^x_{\mathit{st}}
  %  \rightarrow \lozenge R^x_{\mathit{st}}$ holds, which in turn, implies that the LHS of the $E^S_C$ condition in Equation \ref{eqn:RYW} holds. %, where $W^x_{\mathit{st}}$ denotes the $W'^x_{\mathit{st}}$ and
  %$R^x_{\mathit{st}}$ = $R^x_{\mathit{st}}$.
  Again,  partial order $\preccurlyeq_{\mathit{st}+w}^1$ satisfies the condition $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}}$, which in turn, implies that the right hand side of the implication in the RYW condition is true.
  %  Regarding the second condition in the RHS of  Equation \ref{eqn:RYW}, there does not exist
  %  a write operation $W^k$ such that the LTL conditions $W^k F^x W^i F^x R^j$ and $v_j=v_k$ hold, where $W^i$ = $W^2$
  %  and $R^j$ = $R^1$. Thus, the condition $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
  % \wedge \left( v^j = v^k \right)$ does not hold, where $\mathit{st}$ = $\mathit{st}_1$.
  %$R^1$ returns a value 2 was written by the write operation $W^1$ which precedes $W^2$.
  %   Thus the condition
  %  $\not\exists W^k \in \mathit{st} \left( W^k F^x W^i F^x R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
  % \wedge \left( v^j = v^k \right)$ holds, where $\mathit{st}$ = $\mathit{st}_1$.
  Finally, we consider the write operation $w'(x,2)$  followed by the read $r'(x){1}$ in that session trace, which also satisfies the left hand side of the implication in Equation~\ref{eqn:RYW}. %given as $\square W'^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$.
  %This implies that the condition %$\square W'^x_{\mathit{st}} \rightarrow \lozenge R'^x_{\mathit{st}}$
  %in the LHS of $E^S_C$ specified in Equation \ref{eqn:RYW} holds. %, where $W'^x_{\mathit{st}}$ denotes the operation $w'(x,2)$ and
  %$R'^x_{\mathit{st}}$ denotes the operation $r'(x){1}$.
  %Following the above line of reasoning, the partial order $\preccurlyeq_{\mathit{st}+w}^1$ %is the only valid partial order that
  %satisfies the condition $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}$; thus
  %the RHS of Equation \ref{eqn:RYW} for this above write-read pair.
  In the case of this pair, $\preccurlyeq_{\mathit{st}+w}^1$ does not satisfy the condition
  of the right hand side of the implication in Equation  \ref{eqn:RYW}.
  
  Next, we present an example of a  trace that meets the RYW session guarantee. The session trace we consider is $\mathit{st}^{'}_1$: $w(x,1), w'(x,2), r(x){2}, r'(x){2}$. In this case, the following partial order:
  
  $\preccurlyeq_{\mathit{st}+w}^1$ = $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}}
  \preccurlyeq_{\mathit{st}+w}^1 R'^x_{\mathit{st}}$
  
  \noindent is valid since it satisfies the right hand side of the implication for all write-read pairs in that meet the left hand side of the implication of Equation  \ref{eqn:RYW}.
  
  \subsection{Monotonic Reads}
  
  The Read (or Session) Monotonic, also called Monotonic Reads guarantee (MR) specifies intuitively that read operations on a given object invoked from the same session must always return results in an increasing order of recency.   MR is formally represented by the following expression constraining the partial order defined by ConSpec.
  \begin{align}\label{eqn:MR}
  \begin{split}
  %\mathcal{E}^{s} = \forall  \mathit{st} \in \mathcal{S}_t, {R^i}^{'}, {R^j}^{'} \in \mathit{st} \big( {R^i}^{'} F {R^j}^{'} \in \mathit{st}
  % \Rightarrow \;  \exists S_p \\ \left( {R^i}^{'} F {R^j}^{'} \in S_p \right) \big).
  % \mathit{st} \in \mathcal{S}_t,
  E^S_C =  \forall x \in \mathcal{X}, \mathit{st} \in \mathcal{S}_t, R_\mathit{st}^x, R'^x_\mathit{st} \in \mathit{st}: \\
  \left( \square \left( R_\mathit{st}^x \rightarrow \lozenge R'^{x}_\mathit{st} \right)
  %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
  \rightarrow R_\mathit{st}^x \preccurlyeq_{\mathit{st}+w} R'^{x}_\mathit{st} \right),
  %; \\
  %C = \left( \not\exists {W^m}^{''}, {W^n}^{''} \in \mathcal{S}_t \right) \big( \left( {R^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \\ %\left( {\mathit{st}}^{'} \in \mathcal{S}_t \right) \wedge
  % \wedge \left( {W^m}^{''} F {W^n}^{''}  \in \mathcal{S}_t \right) %\left( {W^m}^{''} F {W^n}^{''} F {R^i}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\
  %  \wedge \left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \\ \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)
  % \wedge  \not\exists {W^p}^{'} \left( {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big)
  \end{split}
  \end{align} with the same meaning for $\mathit{st}$ and $\preccurlyeq_{\mathit{st}+w}$ as in the previous definition.
  
  %where $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ constrains  the order among conflicting reads in an equivalent $S_p$.
  %According to the above equation, a session trace comprising an execution sequence that follows MR must return a value according to either of the following conditions: 1) according to the first expression $\left( R^k{v_m}F^{o}R^s{v_t} \right)$ comprising the exclusive-or in the RHS of the operator $\Rightarrow$, it must return the value written by the latest write preceding the operation $r^s(o)v_t$, i.e., the value $v_q$ written by $w^n(o,v_q)$, or 2) according to the second expression $W^n(v_q) F^{o} W^u(v_x) X^{o} R^s v_t$ comprising the exclusive-or in the RHS, it must return the value $v_x$ written by the latest write $W^u(v_x)$ which overwrites $o$.
  %\begin{align*}
  %\begin{split}
  %\forall i, j, k, l, m, n, q, r, s, t \big(\star \left( w^j(o,v_l)X^{o}r^k(o){v_m} \right) \\ \wedge \left( w^n(o,v_q)X^{o}r^s(o){v_t} \right) \wedge \left( r^k(o){v_m}F^{o}r^s(o){v_t} \right) \star \big)^\mathit{po}_{o} \\
  %\vdash \big(G\; \star \left( v_m = v_l \right) \wedge \left( v_t = v_q \right) \\ \wedge \left( v_q \gets \left( r^k(o){v_m}F^{o}r^s(o){v_t} \right) \right) \star \big)_{o}^\mathit{st}.
  %\end{split}
  %\end{align*}\label{eqn:MR}
  %\begin{align}\label{eqn:MR}
  %\begin{split}
  %\forall i, j, k, l, m, n, q, r, s, t, u, w, x, y, z \left(\star w^j(o,v_l)X^{o}r^k(o){v_m} \wedge w^n(o,v_q)X^{o}r^s(o){v_t} \wedge r^u(o){v_w}F^{o}r^x(o){v_y} \star \right)^\mathit{po}_{o} \\
  %\vdash \left(G\; \star w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{st}.
  % \end{split}
  %  \end{align}
  %. the operator $F$ is the LTL operator eventually.
  %In other words, Equation \ref{eqn:MR} mandates that $r^s(o){v_t}$ returns the value $v_q$ written by the latest write operation $w^n(o,v_q)$, or that written by another write $w^u(o,v_x)$ that overwrites $w^n(o,v_q)$). It does not allow $r^s(o){v_t}$ to return a value $v_l$ written by an earlier write operation  $w^j(o,v_l)$ which was invoked earlier than $w^n(o,v_q)$. The above constraint ensures that a read operation always views the latest version of the object $o$.
  
  \noindent \emph{\textbf{Examples.}}
  Consider a global session trace formed by the following three session traces:
  
  $\mathit{st}_2$: $w(x,1)$,
  
  $\mathit{st}_2^{'}$: $w'(x,2)$, and
  
  $\mathit{st}_2^{''}$: $r(x){1}, r'(x){2}, r''(x){1}$,
  
  This global session trace illustrates a
  violation of the Monotonic Reads  guarantee for session $\mathit{st}_2^{''}$. In this case, since session $\mathit{st}_2^{''}$ comprises  multiple reads on common objects, there are several read-read pairs that need to be analyzed according to Equation \ref{eqn:MR}.
  To this end, we first enumerate all the linear extensions of partial orders that can be used to explain the global session trace under the generic ConSpec definition, according to the fact that reads must return the value of the latest preceding write:
  
  \noindent $\preccurlyeq_{\mathit{st}+w}^1$ =
  $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^1 R'^x_{\mathit{st}}$,
  
  \noindent $\preccurlyeq_{\mathit{st}+w}^2$ =
  $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^2 R'^x_{\mathit{st}}$,
  
  %\noindent $\preccurlyeq_{\mathit{st}+w}^3$ = $R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3   R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 R'^x_{\mathit{st}}$, or
  
  %\noindent $\preccurlyeq_{\mathit{st}+w}^4$ = $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4   R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4 R'^x_{\mathit{st}}$, or
  
  %\noindent $\preccurlyeq_{\mathit{st}+w}^5$ = $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^5 R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^5  W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^5 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^5 R'^x_{\mathit{st}}$, or
  
  % \noindent $\preccurlyeq_{\mathit{st}+w}^6$ = $R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^6 R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^6  W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^6 W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^6   R'^x_{\mathit{st}}$, or
  
  \noindent $\preccurlyeq_{\mathit{st}+w}^3$ =
  $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3  R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3  W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3 R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^3  R''^x_{\mathit{st}} $,
  
  \noindent $\preccurlyeq_{\mathit{st}+w}^4$ =
  $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4 R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4 R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^4 R^x_{\mathit{st}}$.
  
  %\noindent $\preccurlyeq_{\mathit{st}+w}^9$ = $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^9 R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^9  R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^9 W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^9   R^x_{\mathit{st}} $, or
  
  %\noindent $\preccurlyeq_{\mathit{st}+w}^{10}$ = $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{10} R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{10} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{10} W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{10}   R''^x_{\mathit{st}} $, or
  
  %\noindent $\preccurlyeq_{\mathit{st}+w}^{11}$ = $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{11} R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{11}  R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{11} R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{11}  W^x_{\mathit{st}} $, or
  
  % \noindent $\preccurlyeq_{\mathit{st}+w}^{12}$ = $W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{12}   R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{12} R''^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{12} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}^{12}  W^x_{\mathit{st}} $, or
  
  For the given global session trace to satisfy the MR consistency model, at least one of the above  orders must satisfy the condition in Equation \ref{eqn:MR}.
  It turns out that none of the  orders do so, since:
  
  \begin{itemize}
  	\item $R''$ appears before $R'$ in $\preccurlyeq_{\mathit{st}+w}^{1}$
  	\item $R''$ appears before $R$ and $R'$ in $\preccurlyeq_{\mathit{st}+w}^{2}$
  	\item $R'$ appears before $R$ in $\preccurlyeq_{\mathit{st}+w}^{3}$
  	\item $R'$ and $R''$ appear before $R$ in $\preccurlyeq_{\mathit{st}+w}^{4}$
  \end{itemize}
  
  
  Next, as an example of an execution that meets the MR session guarantee, we consider the following global session trace:
  
  $\mathit{st}^{'}_2$:  $w(x,1)$,
  
  $\mathit{st}_2^{'}$: $w'(x,2)$, and
  
  $\mathit{st}_2^{''}$: $r(x){1}, r'(x){2}, r''(x){2}$.
  
  In this case, we can consider the following partial order:
  
  \noindent $\preccurlyeq_{\mathit{st}+w}'$ =
  $W^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}'  W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R''^x_{\mathit{st}}$,
  
  which has the property that reads always return the value of the latest preceding write, and furthermore it meets the condition that all read-read sequences that satisfy left hand side of the implication in Equation \ref{eqn:MR}, also satisfy the right hand side of that implication, since: $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R'^x_{\mathit{st}}$, $R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R''^x_{\mathit{st}}$, and $R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}' R''^x_{\mathit{st}}$.
  
  
  \subsection{Monotonic Writes}
  
  The third session guarantee we present is the Monotonic Writes (MW) model, which is specified as follows: successive write operations invoked from the same session $st$ must be applied in all sessions by the order in which they appear in $st$. The problem with defining this model is that, in the absence of an implementation-specific assumption of a version maintenance system to track the values written to objects by successive write operations, it becomes difficult to precisely define what an ordering of writes means. However, by leveraging the generic ConSpec definitions, we can translate that into a constraint on the partial order that explains the visibility relation among operations:
  \begin{align}\label{eqn:MW}
  \begin{split}
  %E^S_C = \forall \mathit{st} \in \mathcal{S}_t, {W^i}^{'}, {W^j}^{'} \in \mathit{st} \big( {W^i}^{'} F {W^j}^{'} \in \mathit{st}  \Rightarrow
  %  \exists S_p \\ \left( {W^i}^{'} F {W^j}^{'} \in S_p \right) \big).
  E^S_C =   \forall x \in \mathcal{X}, \mathit{st} \in mathcal{S}_t, W_\mathit{st}^x, W'^x_\mathit{st} \in \mathit{st}: \\ \left( \square \left( W_\mathit{st}^x \rightarrow \lozenge W'^{x}_\mathit{st} \right)
  %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
  \rightarrow W_\mathit{st}^x \preccurlyeq_{\mathit{st}+w} W'^{x}_\mathit{st} \right),
  %C = \left( \not\exists {R^k}^{''}, {R^l}^{''}, {R^m}^{'} \in \mathcal{S}_t \right)
  %   \big( \left( {W^j}^{'} F  {R^m}^{'} \in \mathit{st} \right) \wedge \\
  %   \left( {v_m}^{'} = {v_i}^{'} \right)
  %  \wedge \left( \not\exists  {R^k}^{'} F  {R^l}^{'} \in \mathcal{S}_t \right) \big(
  %     \left( {v_k}^{'} = {v_j}^{'} \right) \wedge \\
  %   \left( {v_l}^{'} = {v_i}^{'} \right)  \big) \wedge
  %    \left( \not\exists  {W^p}^{'}, {R^n}^{'} \in \mathcal{S}_t  \right)
  %    \big(  \left( {v_p}^{'} = {v_k}^{'} \right) \\
  %    \wedge  \left( {W^p}(x)^{'} F {R^k}(x)^{'} \in \mathcal{S}_t  \right) \wedge
  %   \left(  {W^i}(x)^{'} F {R^n}(x)^{'} \in \mathcal{S}_t \right) \\
  %    \wedge \left( {v_i}^{'} = {v_n}^{'} \right)   \wedge
  %    \left( {W^i}(x)^{'} F  {W^j}(y)^{'} \in \mathit{st} \right)  \wedge \\
  %    \left( {R^l}(y)^{'} F  {R^k}(x)^{'} \in \mathcal{S}_t \right) \wedge
  % \big(  \left( {v_p}^{''} = {v_n}^{''} \right)  \vee \\
  % \big( \left( {W^p}^{'} F {R^n}^{'} \in \mathcal{S}_t \right)  \wedge
  %      \not\exists {W^q}^{'} \left( {W^p}^{'} F {W^q}^{'} F {R^n}^{'} \in \mathcal{S}_t \right)   \big) \big) \big)%\wedge \\
  %\not\exists \left( %\mathit{st}^{'}, \mathit{st}^{''} \in \mathcal{S}_t \; \wedge \;
  % {W^t}^{'''} \in \mathcal{S}_t \right)
  %\big( \left( {W^i}^{'} = {W^m(x)}^{'} \wedge {W^j}^{'} =  {W^n(y)}^{'} \right) \\ \wedge \left( {R^p(y)}^{''} F {R^q(x)}^{''} \in \mathcal{S}_t \right) \wedge
  %\left( \left( {v_q}^{''} = {v_n}^{'} \right) \wedge \left( {v_p}^{''} =  {v_t}^{'''} \right) \right) \big)
  \end{split}
  \end{align} with the same meaning for $\preccurlyeq_{\mathit{st}+w}$ as before.
  %where $\mathit{st}$ denotes the local session trace, and $\preccurlyeq_{\mathit{st}+w}$ denotes the restriction of $\preccurlyeq$ to the elements of $\mathit{st}$ and the write operations of all other clients. %where the partial order $\left( {\mathcal{O}_{St}}, \preccurlyeq \right)$ restricts the order among conflicting writes  in an equivalent $S_p$.
  %\begin{align}\label{eqn:MW}
  %\begin{split}
  %\forall i \left(\star w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{po} \Rightarrow \left(G\; \star w(o,v)F^{o}w^{'}(o,v^{'}) \star \right)_{o}^\mathit{st}.
  %\end{split}
  %  \end{align}
  
  \noindent \emph{\textbf{Examples.}}
  Monotonic writes provides an interesting case of a definition where it becomes impossible to show a counter-example with a violation of these semantics exclusively based on a read-write interface. This is because the definition does not constrain the order of reads, and therefore it is always possible to obey this ordering of writes by reordering the reads appropriately (namely ordering each read right after the write for the same value).
  
  In fact, other authors have implicitly observed this when describing a set of examples of violations of several consistency guarantees~\cite{Burckhardt:2012:ECT:2259248.2259252}. This is because they switched from adopting a read/write interface to exemplify several violations of different consistency levels to using set-add and set-read commands for Monotonic Writes. In particular, they assumed a sequential specification with two operations on a set data structure, to {\tt add} an element to the set, and {\tt read} the state of the set, and the specification that {\tt read} must return the union of all previously {\tt add}ed elements. Then, they presented the following example global session trace:
  
  $\mathit{st}_4$: $\texttt{add}(x,1),\texttt{add}(x,2)$
  
  $\mathit{st}_4^{'}$: $\texttt{read}(x){\{2\}}$.
  
  In this example, the only possible linear extension of a partial order that is compatible with the outputs of session $\mathit{st}_4^{'}$ is the following.
  
  
  \noindent $\preccurlyeq_{\mathit{st'}+w}^1$ = $\texttt{add}(2) \preccurlyeq_{\mathit{st'}+w}^1  \texttt{read} \preccurlyeq_{\mathit{st'}+w}^1 \texttt{add}(1)$
  
  This order, however, fails to meet the restrictions in Equation~\ref{eqn:MW}, since it does not preserve the order of the two consecutive writes that appear in session trace $\mathit{st}_4$.
  
  In contrast, we are able to meet this session guarantee if we replace the output of the read to return both values, i.e., according the following global session trace:
  
  
  $\mathit{st}_4$: $\texttt{add}(x,1),\texttt{add}(x,2)$
  
  $\mathit{st}_4^{'}$: $\texttt{read}(x){\{1,2\}}$.
  
  This is because, in this case, the following partial order meets all the required conditions:
  
  \noindent $\preccurlyeq_{\mathit{st'}+w}^2$ = $\texttt{add}(1) \preccurlyeq_{\mathit{st'}+w}^2  \texttt{add}(2) \preccurlyeq_{\mathit{st'}+w}^2 \texttt{read}$
  
  %\par The definition of MW considers write-read sequences in a partial order like the following: $\texttt{add}(x,2) \preccurlyeq_{\mathit{st'}+w}^2 \texttt{read}(x){\{1,2\}}$ instead of $w(x,2) \preccurlyeq_{\mathit{st'}+w}^2 r(x){2}.$ Following Condition 1 in Definition \ref{def:form0}, we check if the value returned by the read matches the latest write preceding it in the partial order $\preccurlyeq_{\mathit{st'}+w}^2$. However in this case, we consider the last value returned among the set of values  ${\{1,2\}}$ returned by the read to confirm validity of the partial order. On the other hand, other consistency models like RYW since a read returns a single value. Thus, MW (and WFR given below) are a special case derived directly from the generic definition of consistency given in Definition \ref{def:form0}.
  
  
  \subsection{Write Follows Reads}
  
  Write Follows Reads (WFR)  was originally specified by saying that a write operation that follows a read operation in the same session must be ordered in all remaining sessions after any write operations seen by that read. This differs from the previous session guarantees in the fact that it needs to reason more carefully about operations across sessions, as follows. \\
  \begin{align}\label{eqn:WFR}
  \begin{split}
  E^S_C =    \forall x \in \mathcal{X}, \mathit{st}, \mathit{st'}, \mathit{st''} \in \mathcal{S}_t, R_\mathit{st}^x,  W_\mathit{st}^x \in \mathit{st}, W'^x_\mathit{st''} \in \mathit{st''}:  \\
  \left(  \left(
  \square \left( R^x_{\mathit{st}} \rightarrow \lozenge W^x_{\mathit{st}} \right)
  \wedge
  \left(  W'^x_\mathit{st''} \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}} \right)
  \right)
  \rightarrow
  W'^x_{\mathit{st}''} \preccurlyeq_{\mathit{st'}+w} W_{\mathit{st}}^x \right),
  \end{split}
  \end{align}
  with the same meaning for $\preccurlyeq_{\mathit{st}+w}$, $\preccurlyeq_{\mathit{st}'+w}$ as before.
  
  
  \noindent \emph{\textbf{Examples.}}
  In the same way as in the Monotonic Writes session guarantee, we also need to resort to the set-add and set-read specification, since the ordering of writes as seen by $st'$ can always be preserved by placing reads in $\preccurlyeq_{\mathit{st'}+w}$ right after each corresponding write.
  
  Thus, we consider the following global session trace to exemplify a violation of WFR:
  
  
  $\mathit{st}_5$: $\texttt{read}(x){\{1\}},\texttt{add}(x,2)$
  
  $\mathit{st}_5^{'}$: $\texttt{read}(x){\{2\}},\texttt{read'}(x){\{1,2\}}$.
  
  $\mathit{st}_5^{''}$: $\texttt{add}(x,1)$.
  
  In this case, the only order $\preccurlyeq_{\mathit{st'}+w}^1$ that is compatible with the outputs observed by $\mathit{st}_5^{'}$ is the following:
  
  \noindent $\preccurlyeq_{\mathit{st'}+w}^1$ = $\texttt{add}(2) \preccurlyeq_{\mathit{st'}+w}^1 \texttt{read}
  \preccurlyeq_{\mathit{st'}+w}^1  \texttt{add}(1) \preccurlyeq_{\mathit{st'}+w}^1 \texttt{read'}$
  
  This ordering, however, does not meet the conditions set by the definition of WFR.
  
  In contrast, if we change the first read of that session to return  value 1, then it becomes compatible with the fact that the write of value 2 followed reading value 1 in session $\mathit{st}_5$, i.e., we obtain the global session trace:
  
  $\mathit{st}_5$: $\texttt{read}(x){\{1\}},\texttt{add}(x,2)$
  
  $\mathit{st}_5^{'}$: $\texttt{read}(x){\{1\}},\texttt{read'}(x){\{1,2\}}$.
  
  $\mathit{st}_5^{''}$: $\texttt{add}(x,1)$.
  
  which is compatible with the following valid order:
  
  \noindent $\preccurlyeq_{\mathit{st'}+w}^2$ = $\texttt{add}(1) \preccurlyeq_{\mathit{st'}+w}^2 \texttt{read}
  \preccurlyeq_{\mathit{st'}+w}^2  \texttt{add}(2) \preccurlyeq_{\mathit{st'}+w}^2 \texttt{read'}$
  
  \subsection{Processor Consistency}
  
  Next, we define Processor Consistency (PC), which is a widely implemented but sometimes misinterpreted shared memory consistency model; we use
  Goodman's definition of PC~\cite{Ahamad:1993:PPC:165231.165264}, instead of the definition implemented in the DASH system, which is less commonly used. A first restriction that PC  specifies is that  there must exist a valid legal serialization for  any partial execution of
  %comprising operations performed by
  all processors $p_i$ that orders operations according to the program order of $p_i$.  This condition can be expressed in terms of ConSpec as:
  $ \square \left( O_\mathit{st}^x \rightarrow \lozenge O_\mathit{st}^{y} \right)
  %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
  \rightarrow O_\mathit{st}^x \preccurlyeq_{\mathit{st}+w}
  O_\mathit{st}^{y}$.
  %$\forall \mathit{st} \in \mathcal{S}_t, \; {\mathit{Op}}(x), {\mathit{Op}}'(x) \in \mathcal{O}_{St} :  \square\;  \mathit{Op}(x) \operatorname{\it F}_\mathit{st} {\mathit{Op}}'(x) \Rightarrow  {\mathit{Op}}(x) \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}'(x) $ %, where $\preccurlyeq_{\mathit{st}+w}$ denotes a partial order formed out of a session trace $\mathit{st}$ for a given client plus all writes,
  %for the following reason: [THE FOLLOWING IS VERY REPETITIVE] a valid legal serialization $S_p$ is a sequence of operations that satisfies the following properties: (1) it is a linear sequence that comprises all operations from a given client $\mathit{Cl}_i$ plus writes from all other clients, and (2) each read in the sequence $S_p$ returns the result of the preceding write  in $S_p$.
  %By definition (refer to definition of $\preccurlyeq_{\mathit{st}+w}$ in the ConSpec expression for  RYW), $\preccurlyeq_{\mathit{st}+w}$ is a partial order  comprising all operations in a session trace $\mathit{st}$ plus writes from other operations; thus $\preccurlyeq_{\mathit{st}+w}$ satisfies Property (1) of a valid $S_p$.
  %Also, following directly from the definition of $\preccurlyeq_{\mathit{st}+w}$, the output of each operation in $\preccurlyeq_{\mathit{st}+w}$ is equivalent to that obtained by executing a linear sequence of the operations preceding that operation; thus $\preccurlyeq_{\mathit{st}+w}$ satisfies Property (2) of a valid $S_p$.  Thus condition 1 in PC can be expressed as:
  %$\forall \mathit{st} \in \mathit{S_t}:   W_\mathit{st}^x \preccurlyeq_{\mathit{st}+w} W'^{x}_\mathit{st}$.
  \par Additionally, PC specifies that  valid legal serializations for all session traces comprised in a given global session trace $\mathcal{S}_t$ must order write operations on data objects according to an identical precedence order, i.e., all legal serializations must either order writes on object $x$ before writes on object $y$, or they must all order writes on $y$ before writes on $x$.
  %However as explained while defining WFR and MW, writes alone have no significance; hence we also have to consider the precedence order of read operations that read the results of these writes.
  This condition can be given as the following, if $W$ and $W'$ happen in a given order in $st$, then for any other $st'$ they must obey the same relative order, i.e.:
  $ \square \left( W_\mathit{st}^{x} \rightarrow \lozenge {W'}_\mathit{st}^{y} \right)
  %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
  \rightarrow W_\mathit{st}^x \preccurlyeq_{\mathit{st'}+w}
  {W'}_\mathit{st}^{y}$.
  %$\forall \mathit{st} \in \mathcal{S}_t, \; W(x), W'(y), R(x), R'(y) \in \mathcal{O}_{St} :   \square\; W(x) \operatorname{\it F}_\mathit{st} W'(y) \wedge  \square\;  R(x) \operatorname{\it F}_\mathit{st} R'(y) \Rightarrow  W(x) \preccurlyeq W'(y) \wedge R(x) \preccurlyeq R'(y)$,
  % where  $W(x)$ and $W'(y)$ is used to denote write operations on objects $x$ and $y$, %,  $R(x)$ and $R'(y)$ denotes read operations on the same objects, and $\preccurlyeq$ denotes a partial order (refer to definition of $\preccurlyeq$ in Definition \ref{def:form0}) comprising the operations in the session trace $\mathit{st}$.
  Combining these, the ConSpec expression for PC is given as follows.  % In other words, the order in which any pair of  writes, invoked from a particular client, are observed in session traces of all other clients must always respect the invocation order of the above operations. %Reads against  write operations should
  % view the results of the writes
  % according to the invocation order of these writes in a client application. % Let $\mathit{processors}$ be an  integer term that denotes the
  % total number of processors. We can express the condition the propositional logic variable $A$ must hold for any store
  % $\mathit{store}_n$ with the expression  $\bigcap_{\mathit{processor}_n}^{\mathit{processors}} A$.
  %  Thus, PC  can be expressed as
  %%  $E^S_C = \forall x, y, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \not\exists {\mathit{o}}(x), {\mathit{o}^{'}}(y) \in {\mathcal{O}_{St}}
  %% \left( {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (y) \in \mathit{st} \right) \Rightarrow \left( {\mathit{Op}}^{''}(y) F {\mathit{Op}}^{'} (x) \in \mathit{st}^{'} \right)$,
  %% which can be rewritten as follows.
  %% \begin{align}\label{eqn:PC}
  %%\begin{split}
  %%E^S_C = C =   \forall \mathit{st} \in \mathcal{S}_t \not\exists \big( \left(  {W^i}^{'}, {W^j}^{'} \in \mathit{st}  \right)
  %%\wedge \left( {R^k}^{'}, {R^l}^{'} \in \mathcal{S}_t \right) \big) \\
  %%\big( \left( {W^i}^{'} F {W^j}^{'} \in \mathit{st} \right) \wedge
  %%   \left( {R^k}^{'} F {R^l}^{'} \in \mathcal{S}_t \right) \wedge
  %%  \left( v_k^{''} = v_j^{'} \right)  \wedge \\
  %%  \left( v_l^{'} = v_i^{'} \right) \big) \wedge
  %%  \not\exists \left( {W^i}^{'}, {R^j}^{'}, {R^k}^{'}, {W^l}^{'}  \in \mathit{st}  \right)
  %%  \big( \left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \\ \wedge
  %%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) \wedge
  %% \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
  %%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge
  %% \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)
  %%E^S_C = \left( {\mathcal{O}_{St}}, \preccurlyeq \right),
  %$\forall x, y, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t  \big( \left( W^{'}(x) F W^{''} (y) \in \mathit{st} \right) \Rightarrow  \left(  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right) \wedge  \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right) \right) \big)$,
  %%\end{split}
  %%  \end{align}
  %%  \forall x, y, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t  \left( {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (y) \in \mathit{st} \right) \Rightarrow  \left( {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (y)  \in \left( {\mathcal{O}_{St}}, \preccurlyeq_{st} \right) \wedge {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (y)  \in \left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}} \right)  \right),
  %%\end{split}
  %%  \end{align}
  %   where $ \preccurlyeq_{\mathit{st}+w}$ and $ \preccurlyeq_{{st}^{'}+w}$ are partial orders restricted to operations performed by clients $\mathit{Cl}$ and $\mathit{Cl}^{'}$ and writes from all other clients, respectively, observed in the respective local session traces $\mathit{st}$ and $\mathit{st}^{'}$.  The partial order relations $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right)$ and $ \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right)$ can be expressed in terms of the corresponding partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. By that logic, the condition $ \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right) \wedge  \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right) $ can be expressed in terms of an intersection $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right)$ of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$, where the partial order $ \preccurlyeq^{'} $ represents the relation among elements of the new partial order set formed out of the intersection of $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
  % Thus, PC can be expressed as follows. %$E^S_C =  \forall x, y, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t  \big( \left( W^{'}(x) F_\mathit{st}  W^{''} (y) \right) \Rightarrow  \left(  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right) \wedge  \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right) \right) \big)$, where $x$ and $y$ are data objects in the system, and $ \preccurlyeq_{\mathit{st}+w}$ and $ \preccurlyeq_{{st}^{'}+w}$ are partial orders restricted to operations observed in the session traces $\mathit{st}$ and $\mathit{st}^{'}$, respectively.  Replacing the partial order relations $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right)$ and  $ \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right)$ with the corresponding partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$,  the RHS condition of the $ \Rightarrow$ operator in the above equation can be expressed as $W^{'}(x), W^{''} (y) \in \left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right) \wedge W^{'}(x), W^{''} (y) \in \left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. Further, the RHS can be expressed as $W^{'}(x), W^{''} (y) \in \left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right),$  where the partial order set $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right)$ is given as $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right) \equiv \left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right) \cap \left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. %an intersection of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
  %Since  $W^{'}(x), W^{''} (y) \in \left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right) \equiv W^{'}(x) \preccurlyeq^{'} W^{''} (y)$,  %  where $ \preccurlyeq^{'} $ denotes the partial order relation  among elements of the new partial order set formed out of the intersection of $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
  %PC can be finally expressed as follows. %$\forall x, y, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t  \big( \left( W^{'}(x) F _ \mathit{st} W^{''} (y) \right) \Rightarrow  \left(  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right) \wedge  \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right) \right) \big)$.
  % The partial order relations $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right)$ and $ \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right)$ can be expressed in terms of the corresponding partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. By that reasoning, the condition $ \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right) \wedge  \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right) $ can be expressed in terms of an intersection $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right)$ of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$, where $ \preccurlyeq^{'} $ denotes the partial order relation  among elements of the new partial order set formed out of the intersection of $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
  %Following the approach as in Causal+, we rewrite PC specification as %n terms of a partial order $ \preccurlyeq^{'} $ as follows.
  \begin{align}\label{eqn:PC}
  \begin{split}
  E^S_C =  \forall x,y \in \mathcal{X}, \mathit{st},\mathit{st}' \in \mathcal{S}_t, O_\mathit{st}^x, O_\mathit{st}^{y} \in \mathit{st}:  \\
  \big( \big( \square \left( O_\mathit{st}^x \rightarrow \lozenge O_\mathit{st}^{y} \right)
  %\forall \mathit{st} \in \mathcal{S}_t,\;  {R}'(x), {R}''(x) \in \mathit{st} : \\
  %\square\; {R}'(x) \operatorname{\it F}_\mathit{st} {R}''(x)
  \rightarrow O_\mathit{st}^x \preccurlyeq_{\mathit{st}+w} O_\mathit{st}^{y} \big) \wedge \\
  \left( \exists W^x, W'^{y} \in \mathcal{S}_t: W^x \preccurlyeq_{\mathit{st}+w} W'^{y} \rightarrow W^x \preccurlyeq_{\mathit{st'}+w} W'^{y} \right) \big).
  %\; \forall \mathit{st} \in \mathcal{S}_t, \\ {\mathit{Op}}(x), {\mathit{Op}}'(x), W(x), W'(y), R(x), R'(y) \in \mathcal{O}_{St} : \\
  %\square\;  \mathit{Op}(x) \operatorname{\it F}_\mathit{st} {\mathit{Op}}'(x) \Rightarrow  {\mathit{Op}}(x) \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}'(x)  \wedge \\  \square\; W(x) \operatorname{\it F}_\mathit{st} W'(y) \wedge  \square\;  W(x) \operatorname{\it F}_\mathit{st} R(x) \wedge  \square\;  R(x) \operatorname{\it F}_\mathit{st} R'(y) \\\Rightarrow  W(x) \preccurlyeq W'(y) \wedge R(x) \preccurlyeq R'(y).
  \end{split}
  \end{align}
  %    \begin{align}\label{eqn:PC}
  %\begin{split}
  %E^S_C = \; \forall \mathit{st} \in \mathcal{S}_t, \; R'(x), R''(y), W'(x), W''(y) \in \mathit{st}: \\
  % W'(x) \operatorname{\it F}_\mathit{st} W''(y)  \Rightarrow  W'(x) \preccurlyeq W''(y)  \wedge \\ R'(x) \operatorname{\it F}_\mathit{st} R''(y)  \Rightarrow  R'(x) \preccurlyeq R''(y).
  %\end{split}
  %  \end{align}   %\forall \big( %\left( \mathit{st} \in \mathcal{S}_t \right) \wedge
  % \left( {W^i}(x)^{'} F {W^j}(z)^{'} F {R^k}(y)^{'} \in \mathit{st} \right) \wedge \\
  %  \left( {W^l}(y)^{'} F {W^m}(z)^{'} F {R^n}(x)^{'} \in \mathit{st} \right) \big) \\
  %   \big( \not\exists \big( %\left( \mathit{st}^{'}, \mathit{st}^{''} \in \mathcal{S}_t  \right) \wedge \\
  %  \left( {W^p}(x)^{''} F {W^i}(x)^{''} \in \mathcal{S}_t  \right) \wedge \left( {W^q}(y)^{'''} F {W^l}(y)^{'''} \in \mathcal{S}_t  \right) \big) \\
  %  \left( \left( v_i^{''} = v_k^{''} \right) \wedge \left( v_j^{'''} = v_m^{'''} \right) \right) \big) \wedge \\
  %   \forall \big( %\left( \mathit{st} \in \mathcal{S}_t \right) \wedge
  %   \left( {W^i}(x)^{'} F {W^j}(y)^{'} \in \mathit{st} \right) \wedge \\ \left( {W^k}(y)^{'} F {W^l}(x)^{'} \in \mathit{st} \right) \big)
  %   \big( \not\exists \big( %\left( \mathit{st}^{'}, \mathit{st}^{''} \in \mathcal{S}_t \right) \wedge
  %   \\ \left( {W^i}(x)^{''} F {R^m}(x)^{''} \in \mathcal{S}_t  \right) \wedge
  %   \left( {W^k}(y)^{'''} F {R^n}(y)^{'''} \in \mathcal{S}_t  \right) \big) \\ \left( \left( v_m^{''} = v_i^{''} \right) \wedge \left( v_n^{'''} = v_j^{'''} \right) \right)
  %\forall i, j, o, \mathit{st} \;  \big( \mathit{Op}^i F \mathit{Op}^j \in \mathit{st}
  %\Rightarrow  \exists S_p \left( \mathit{Op}^i F \mathit{Op}^j \in S_p \right) \\
  %\wedge \forall \mathit{st} \not\exists R^k, R^l \left( \mathit{Op}^i X^o R^k F \mathit{Op}^j X^o R^l \in \mathit{st} \right) \\ \wedge \left( v^k \not= v^i  \right) \wedge \left( v^l = v^j \right) \big)
  %\end{split}
  %  \end{align},
  %where $\preccurlyeq$ is a partial order over the global session trace $\mathcal{S}_t$. % composition   $\preccurlyeq =  \preccurlyeq^{'} \circ  ... \circ^{'} \preccurlyeq^{''}$and $\circ, ... \circ^{''}$ are again composition operators, like $\cap$ or $\cup$, over partial order sets (posets) $\preccurlyeq^{'}, ...  \preccurlyeq^{''}$ comprising partial orders defined over all data objects.
  %  \par Owens et al. \cite{Owens:2009:BXM:1616077.1616107} specifies Total Store Order (TSO) as: a read operation performed by a given client on a given data object can not return the result of a write on the same object by a different client unless the former write has been observed by all clients in the system. For instance, consider write-read sequences  $w(x,v)$, $r^{'}(x)$ and  $r^{''}(x)$, $w^{'''}(x,v^{'''})$ in session traces $\mathit{st}$  and $\mathit{st}^{'}$, respectively. The read $r^{'}(x)$ in $\mathit{st}$  can not return result of the later write $w^{'''}(x,v^{'''})$ from $\mathit{st}^{'}$ unless the preceding write $w(x,v)$ in  $\mathit{st}$ have been observed by  $r^{''}(x)$ from $\mathit{st}^{'}$.  %Consider an execution sequence  comprising a write operation $w(x,v)$ performed by a given client application (observed in a local session trace $\mathit{st}$ corresponding to that client) on an object $x$, followed by a read $r^{'}(x)$ on $x$. Another client invokes a read operation $r^{''}(x)$ on the same object $x$  followed by a write $w^{'''}(x,v^{'''})$ on $x$, observed in the session trace $\mathit{st}^{'}$.
  %   Variables  $v$, $v^{'}$,  $v^{''}$, and $v^{'''}$ denote the values returned by the operations $w(x,v)$, $r^{'}(x)$, $r^{''}(x)$, $w^{'''}(x,v^{'''})$, which are denoted by shorthand notations $W^{'}(x)$,  $R^{''} (x)$, $ {R}^{'''}(x)$, and $W^{''''}(x)$,  respectively. Thus, TSO can be expressed as follows. %According to TSO, the read $r^{'}(x,v^{'})$ can not observe the result of $w^{'''}(x,v^{'''})$ before the read $r^{''}(x)$ observes the result of $w(x,v)$. In other words, a valid legal serialization corresponding to partial executions of each client in the system must order  the writes to a given object in an identical precedence order. In terms of the generalised syntax in Definition \ref{def:form0}, the above condition can be restated as:  there must exist valid partial orders $\preccurlyeq_{{st}^{'}}$ and $\preccurlyeq_{{st}}$ over the operations in the session traces $\mathit{st}$ and $\mathit{st}^{'}$, respectively, which preserves the above order among writes to each data object $x$.  %This operation can not succeeded by another operation on the same  object   can not be observed  by any given client (i.e., can not occur in a  given session trace) return a subsequent (or newer) value unless the result of a given write is observed by all client applications, i.e., observed in all  session traces.
  % % A session trace for a client application can not view results of a sequence of write operations in an
  %  %order which differs from the invocation order. \mathit{o}(x), \mathit{o}^{'}(x), \mathit{o}^{''}(x), \mathit{o}^{'''}(x)  %Let $\mathit{stores}$ be an integer term that denotes the total number of stores.
  % %  $\bigcap$ is equivalent to the logical operator union; an expression $\bigcap_{\mathit{store}_n}^{\mathit{stores}} A$
  % %  denotes that condition represented by the propositional logic variable $A$ must hold for any store $\mathit{store}_n$.
  %  % In the specification of TSO, we do not have a notion for the expressions $A$  and $B$.
  %   %Following Definition
  %    %\ref{def:form0}, %$E^S_C$ is specified in term
  %   %of $C$ only. Thus,
  %   %Using the notion of a valid  partial order following the PC definition, TSO is expressed as follows.
  %  %\begin{align}\label{eqn:TSO}
  % %\begin{split}
  % %\forall i \left( \star (w(o,v)X^{o}r(o))\;F^{co}\; (w^{'}(o,v^{'})X^{o}r^{'}(o)) \star \right)_{o}^\mathit{po} \\ \Rightarrow  \left( \bigcap_{\mathit{store}_j} (\star w(o,v)X^{o}r(o) \star) F^{o}\; w^{'}(o,v^{'})X^{o}r^{'}(o) \right)^\mathit{st}_{o}.
  % %\end{split}
  % %  \end{align}
  % %  \begin{align}\label{eqn:TSO}
  % %\begin{split}
  % % E^S_C = C = \forall  \mathit{st} \in \mathcal{S}_t \not\exists  \big( \left({W^i}(x)^{'} \in \mathit{st} \right) \wedge \\
  % % \left({R^j}(x)^{''}, {R^k}(x)^{'} \in \mathcal{S}_t \right) \big)
  % %  \big( \left( {W^i}^{'}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right) \wedge \\
  % %    \left( {v_j}^{''} \not= {v_i}^{'} \right)  \wedge
  % %  \left( {R^k}^{''}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right)
  % %     \wedge \left( {v_k}^{''} \not= {v_i}^{'} \right) \big) \\
  % %     \wedge
  % %  \not\exists {W^l}^{'} \in \mathcal{S}_t \big( \left(   {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right)  \wedge
  % %\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) \wedge \\
  % % \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge
  % %\big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee
  % %\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)  \wedge \\
  % % \not\exists  {W^m}^{'} \left( {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)
  % % \\ $E^S_C = \forall x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \not\exists {\mathit{o}}(x), {\mathit{o}^{'}}(x), {\mathit{o}^{''}}(x), {\mathit{o}^{'''}}(x) \in {\mathcal{O}_{St}} \big( \left( {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (x) \in \mathit{st} \right)  \vee \big(  \left( {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{'''} (x) \in \mathit{st} \right)  \wedge \\ \left( {\mathit{Op}}^{''}(x) F {\mathit{Op}}^{''''} (x) \in \mathit{st}^{'} \right)  \wedge \left( {v}^{''} = {v} \right) \wedge \left( {v}^{'} = {v}^{'''} \right)  \big) \big)  \Rightarrow
  % % \left(  {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (x) \in \mathit{Si} \right)$,
  %  %E^r = C = \\
  % % \forall \mathit{st}, \mathcal{S}_t \; \big( \left( {W^i}(x)^{'} F {W^k}^{'}(y) \in \mathit{st} \right) \wedge \left( {W^l}(y)^{'} F {W^j}^{'}(x) \in \mathit{st} \right) \wedge \\
  % % \not\exists \left( %\mathit{st}^{'} \in \mathcal{S}_t \; \wedge \;
  % %  {R^m}^{''}(y), {R^n}^{''}(x) \in \mathcal{S}_t \right) \left( \left( {v_m}^{''} = {v_k}^{'} \right) \wedge \left( {v_n}^{''} = {v_l}^{'} \right)   \right) \wedge \\
  % % \forall \left( {W^i}(x)^{'} F {W^j}^{'}(y) \in \mathit{st} \; \wedge \; {R^k}(x)^{'} F {R^l}^{'}(y) \in \mathit{st} \right) \\
  % % \left( \not\exists \left( %\mathit{st}^{'} \in \mathcal{S}_t \; \wedge \;
  % %  {W^m}(x)^{''} F {W^i}^{'}(y) F {R^k}^{'}(y) \in  \mathcal{S}_t  \right)
  % % \left( {v_k}^{'} = {v_m}^{''}   \right) \right) \wedge \\
  % %  \forall \big( \left( {W^i}(x)^{'} F {W^j}^{'}(y) F {R^k}^{'}(z) \in \mathit{st} \right) \wedge \\
  % % \left( {R^l}^{'}(x) F {W^m}^{'}(v) F {W^p}^{'}(z) \in  \mathit{st} \right) \big) \\ \big( \not\exists \big( %\left( \mathit{st}^{''} \in \mathcal{S}_t \right) \wedge
  % % \left( {W^m}(x)^{'''} F {R^l}^{'''}(x) \in \mathcal{S}_t \right)    \wedge %\left( \mathit{st}^{''} \in \mathcal{S}_t \right) \wedge
  % % \left( {W^t}(z)^{'''} F {W^p}^{'''}(z) \in \mathcal{S}_t  \right) \big) \\
  % % \left( \left( {v_k}^{'''} = {v_t}^{'''}  \right) \wedge  \left(  {v_l}^{'''} = {v_q}^{'''}   \right) \right) \big) \big)
  %   %\forall i, j, o, \mathit{st}_x, \mathit{st}_y \big( W^i F W^j \in \mathit{st}_x, \mathit{st}_y
  % %\\ \Rightarrow  \exists S \left( W^i F W^j \in S \right) \wedge
  % %\\ \not\exists R^m  \left( W^i F W^j F R^m \in \mathit{st}_x, \mathit{st}_y \right) \\
  % %\wedge \big( \left( \left( v^m = v^i \in \mathit{st}_x  \right) \wedge \left( v^m = v^j \in \mathit{st}_y \right) \right) \\
  % % \vee \left( \left( v^m = v^j \in \mathit{st}_x  \right) \wedge \left( v^m = v^i \in \mathit{st}_y \right) \right) \big) \big)
  % %\end{split}
  % %  \end{align}
  %   %which can be rewritten as follows.
  %  %$E^S_C = \forall x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, w(x,v), r^{'}(x,v^{'}), r^{''}(x), w^{'''}(x,v^{'''}) \in {\mathcal{O}_{St}}  \big( \left( W^{'}(x) F _ \mathit{st} R^{''} (x) \right)  \wedge  \left( \mathit{R}^{'''}(x) F _ \mathit{st}^{'} W^{''''} (x) \right)  \wedge \left( v^{''} = v \right) \wedge \left( v^{'''} = v^{'} \right)  \big) \Rightarrow   \big( \left( W^{'}(x) \preccurlyeq_{st} W^{'''} (x) \right) \wedge \left( W^{'}(x) \preccurlyeq_{{st}^{'}} W^{'''} (x) \right)  \big) \big).$
  %   %$E^S_C = \forall x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, w(x,v), r^{'}(x,v^{'}), r^{''}(x), w^{'''}(x,v^{'''}) \in {\mathcal{O}_{St}}  \big( \left( W^{'}(x) F_\mathit{st}  R^{''} (x) \right)  \wedge  \left( \mathit{R}^{'''}(x) F_\mathit{st}^{'} W^{''''} (x) \right)  \wedge \left( v^{''} = v \right) \wedge \left( v^{'''} = v^{'} \right)  \big) \Rightarrow   \big( \left( W^{'}(x) \preccurlyeq_{st} W^{'''} (x) \right) \wedge \left( W^{'}(x) \preccurlyeq_{{st}^{'}} W^{'''} (x) \right)  \big) \big).$
  %   %Following the same approach as in PC, TSO can be expressed in terms of a new partial order set $\preccurlyeq^{'}$, which is an intersection of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{st} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}} \right)$. %, where $\preccurlyeq^{'}$  denotes a partial order among elements  of the intersection-set. %comprising an intersection of the partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{st} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}} \right)$.
  %  %Thus, the expression for TSO is as follow.
  %   \begin{align}\label{eqn:TSO}
  % \begin{split}
  % E^S_C = \forall x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, w(x,v), r^{'}(x,v^{'}), r^{''}(x), w^{'''}(x,v^{'''}) \in {\mathcal{O}_{St}}  \big( \left( W^{'}(x) F_ \mathit{st} R^{''} (x) \right)  \wedge  \left( \mathit{R}^{'''}(x) F_\mathit{st}^{'} W^{''''} (x) \right)  \wedge \\
  % \left( v^{''} = v \right) \wedge \left( v^{'''} = v^{'} \right)  \big) \Rightarrow    \left( W^{'}(x) \preccurlyeq W^{'''} (x) \right) \big)
  % \end{split}
  %   \end{align}, where $ \preccurlyeq$ is a partial order  over  all operations on a given object $x$ comprised in $\mathcal{S}_t$. %and $ \mathit{Si}$ is an equivalent legal serialization of a global execution defined in Equation \ref{def:ser}.
  %   %$\preccurlyeq$ is given as a composition $\preccurlyeq =  \preccurlyeq^{'}(x) \circ  ... \circ^{'} \preccurlyeq^{''}(x)$,  and $\circ, ... \circ^{''}$ are composition operators, like $\cap$ or $\cup$, over partial order sets (posets) $\preccurlyeq^{'}(x), ... \preccurlyeq^{''}(x)$ comprising partial orders defined over a given object $x$.
  
  
  \noindent \emph{\textbf{Examples.}}
  As an example of a violation of PC, we consider the  following global session trace originally discussed by Ahamad et al. \cite{Ahamad:1993:PPC:165231.165264} when they formalized Goodman's definition of PC:
  
  $\mathit{st}_6$: $w(x,0), w(y,0)$,
  
  $\mathit{st}_6^{'}$:  $ r(y){0}, w(x, 1)$, and
  
  $\mathit{st}_6^{'}$:  $ r'(x){1}, r''(x){0}$.
  
  In this case, the partial orderings that need to be used by the second and third session trace necessarily have to use a different order for the two writes. As such, the condition in the last line of Equation \ref{eqn:PC} is not met, and the global session trace does not obey Processor Consistency.
  
  For an example that meets PC, consider a global session trace as follows.
  
  $\mathit{st}_7$: $w(x,1), w'(x,3)$,
  
  $\mathit{st}_7^{'}$:  $ r(x){1}, r'(x){3}$,    %$\mathit{st}_7^{'}$: $r^1(x){1}$,
  
  
  $\mathit{st}_7^{''}$:
  $w(y){1}, w'(y){2}$, and
  
  $\mathit{st}_7^{'''}$:
  $r(y){1}, r(y){2}$. %  To satisfy the PC consistency, any sequence of write operations $w^i$ and $w^j$ invoked by a client must satisfy
  %  the condition $\big(\not\exists \left( {W^i}^{'} F {W^j}^{'} \right) \wedge
  %  \left( \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
  %  \left( {R^k}^{'} F {R^l}^{'} \in \mathit{st}^{'} \right) \big)
  % \big( \left( v_k^{''} = v_j^{'} \right) \wedge \left( v_l^{'} = v_i^{'} \right)\big)$. Thus, there must not exists a sequence of
  % reads $r^k$ and $r^l$ such that the condition  $\left( v_k^{''} = v_j^{'} \right) \wedge \left( v_l^{'} = v_i^{'} \right)$
  % holds.
  
  
  The above global session trace satisfies PC %the write operations  are %executed according to the precedence order
  % $w(x,1)$ followed by $ w'(y,1)$. %, hence we assign $w^1(x,1)$ and $ w^2(y,1)$ as $w^{'}(x)$ and $w^{'}(y)$. Also, let us assign
  %the sequence of read operations $r(x){1}$  and $r^2(y){1}$ as $r^k(x)$ and $r^l(x)$, respectively.
  since the results of the write operations are observed by corresponding read operations in an identical order in all processors, and that order is compatible with the program order. In particular, a valid global partial order that satisfies Equation \ref{eqn:PC} for the given global session trace is given as follows: 
  $W^x_{\mathit{st}}  \preccurlyeq_{\mathit{st}+w} R^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W^y_{\mathit{st}} \preccurlyeq_{\mathit{st}+w}   R^y_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} W'^y_{\mathit{st}}   \preccurlyeq_{\mathit{st}+w} R'^x_{\mathit{st}} \preccurlyeq_{\mathit{st}+w} R'^y_{\mathit{st}} .$ 
  
  \section{Sliding Window Approach}\label{sec:additionalYCSBexp}
 \added[id=1]{ The approximately linear scalability shown in the previous experiment can be a source of concern for very long traces, e.g., the traces collected from long-running systems. To address these scenarios, we modify the tool to work with only a portion of the global session trace, in a time window of recent events. In particular, we divide the session trace into smaller \emph{trace segments} enclosed within a sliding window, and execute  the tool on  each successive trace segment sequentially.   Figure \ref{fig:exampleIter} depicts the results from a run of the ConSpec tool in this mode of execution, where the size of the input global session traces is plotted along the x axis, and the time taken to verify a session trace containing a sliding window of 5 operations is plotted along the y axis. We increase the size of the session trace to $250,000$ operations, and observe that the tool performs within very reasonable time bounds in the sliding window mode. In particular, the execution time remains below %190 milliseconds and
  10 millisecond, and varies by up to a factor of approximately 3 times between the fastest and the slowest window to be verified.   Thus, we can conclude that this mode of execution can be a practical approach for handling long-lived systems where the size of the session trace can be very large.}
\begin{figure}%[t]
	%\begin{center}
	\includegraphics[width=3.2in,height=2in]
	{conspecExecutionTimes.eps} %\vspace{-5em}
	%\end{center}
	\caption{Execution Time of ConSpec Tool Against YCSB Trace With Sliding Window size 5.}
	\label{fig:exampleIter}
\end{figure}
 %\subsection{Deriving ConSpec Specifications From Original Definitions}\label{sec:derive}
 %Here we show how the ConSpec specifications can be directly derived from state-of-the-art specifications of
 %consistency \cite{Chockler2000, Terry:1994:SGW:645792.668302}.
 %As already discussed,
 %state-of-the-art consistency specifications  \cite{Chockler2000, Terry:1994:SGW:645792.668302} define axiomatic rules for consistency models using first order
 %ogic expressions.
   %In this section, % and in Section \ref{sec:restderive},
%  we illustrate that %equivalence between of each  consistency model \cite{Chockler2000, Ahamad:1993:PPC:165231.165264, Owens:2009:BXM:1616077.1616107} and the corresponding
 % the ConSpec specifications of  consistency models  and original definitions \cite{Chockler2000, Ahamad:1993:PPC:165231.165264, Owens:2009:BXM:1616077.1616107} are equivalent.  RYW, MR, WFR, MW, Causal and Sequential consistency have been defined by Chockler et al. \cite{Chockler2000}, whereas PC have been defined in \cite{Ahamad:1993:PPC:165231.165264, Owens:2009:BXM:1616077.1616107}.
   %We show that it is possible to formally derive ConSpec specifications from the original  definitions.
 %  We begin by describing the  notations used in the original consistency definitions given by Chockler et al., and how they can be translated to %map to
%  the syntax of ConSpec.  According to Chockler et al., a system comprises a group of processes that communicate with each other by invoking read or write operations on a group of objects.
  % an operation is an  instance of an execution of a read or write instruction performed by a process  on a storage system.
%  Chockler et al. denote   a pair of  read or write operations on an object $x$, invoked from %a session $\mathit{st}$ of
% the $i^{th}$  process $ p_i$ in the system, as $\mathit{o}^1(x)$ and
% $\mathit{o}^2(x)$, respectively. % , such that $\mathit{o}^1$ is a write operation that updates
 %an object $o$ in the system, and $\mathit{o}^2$ is a read operation that reads $o$.
 %In this paper, we refer to a process as a client, %
%We use the notation $\mathit{Cl}_i$ for the $i^{th}$ client in the system. The process $ p_i$ is an execution thread instantiated by the client $\mathit{Cl}_i$. %(similar to Chockler et al.),
% without any loss of information.
  %The
%  notation $\sigma_i$ is used by Chockler et al. to denote a local execution composed of a sequence of read and write operations  performed by  a client $\mathit{Cl}_i$. %(or a process $p_i$ as per Chockler et al.\textquotesingle s terminology),
 %Each operation is comprised of an invocation event and a response event, such that % there is a correspondence among the invocations and responses for each operation, i.e.,
  %the response for each operation follows its corresponding invocation. The notation $\sigma$ denotes a global execution comprising all such local executions performed by all clients in the system. Chockler et al. use the symbol $\rightarrow$ to denote a   \emph{precedence} relationship \cite{Bailis:2013:BCC:2463676.2465279} between two operations, such that an expression $\mathit{o}^1(x) \rightarrow \mathit{o}^2(x)$ implies that an invocation of an operation $\mathit{o}^1(x)$ precedes an invocation of $\mathit{o}^2(x)$ in a given execution.  $\xrightarrow{\sigma_i}$ is a specialised form of the precedence operator, where the superscript $\sigma_i$ is used to restrict the precedence relationship $\rightarrow$ to operations comprised in the  particular execution  $\sigma_i$.  According to the above system model, %each operation comprises an invocation event and a response event, and
  %an invocation event of an operation can not occur unless the response event of a preceding operation comprised in the same session (i.e., invoked by the same client) has occurred in an execution. Hence, the expression $\mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x)$
  %implies that both the invocation and response for operation $\mathit{o}^1(x)$ precede (i.e., happen before) the invocation and response of operation $\mathit{o}^2(x)$ in an execution sequence $\sigma_i$.  %The consistency definitions by
%  Chockler et al. specify the allowed order of operations with respect to a \emph{serialization}, which is
%   a linear sequence of operations formed with the operations  in a given execution sequence.
  %By definition of the system model, unless both the invocation and response for an operation finishes the following operation can not execute.
   %We define a session trace $\mathit{st}$ as a sequence of operations performed by  a client $\mathit{Cl}_i$, ordered according to    invocation time of operations.
    %For means and
   %purposes of this paper, an execution sequence $\sigma_i$ of Chockler et al.  is
   %equivalent to a session trace $\mathit{st}$ in ConSpec.
   %Hence, without any loss of information,  we replace each reference to $\sigma_i$ in the  the definitions of Chockler et al.  with the notation  $\mathit{st}$.  %, replacing the precedence  operator $\Rightarrow$ with the
% equivalent special-purpose LTL operator $F_\mathit{st}$ that denotes ``eventually" relations among with respect to the session $\mathit{st}$ (defined in Section \ref{sec:definitions}), i.e.,  it is equivalent to $\mathit{o}^1 F_\mathit{st} \mathit{o}^2 \in \mathit{st}$.
%An execution sequence $\sigma_i$ of Chockler et al.  is
   %equivalent to a session trace $\mathit{st}$ in ConSpec.
    %Additionally, Chockler et al. extend the notation $\sigma_i$ to define a special-purpose notation $\sigma |i + w$ denoting a partial
    %execution, where $i + w$ implies the restriction of a global execution $\sigma$ to an execution comprising all operations performed by a given client $\mathit{Cl}_i$ (or process $p_i$) plus all writes invoked by
     %other clients.  Chockler et al. also use the notation $S_p$ to denote an equivalent \emph{legal serialization} for a partial execution $\sigma |i + w$;  a legal serialization is a linear sequence of invocation of operations such that each read operation in the sequence returns the result of the last preceding write. %$S_p$ denotes an equivalent \emph{legal serialization} for a partial execution $\sigma |i + w$.
      %A special-purpose operator $\xrightarrow{S_p}$ is used to denote the precedence relation %operator $\rightarrow$ to
   %among operations comprised in the legal serialization $S_p$.
  %where we assign the notation $S$ to a serialization ${S_p}$, and replace the precedence
  %operator with the equivalent LTL operator $F$ that denotes ``eventually".
%  Also, Chockler et al.
%  bases their definitions on a serialization of an execution sequence comprising all operations performed
%  by a client application (or a process), along with writes by all other clients. In ConSpec,
%  we denote such a serialization as $S_p$.
 %We can express the precedence relation for such a
 % serialization in terms of LTL  as $ \mathit{o}^1 F \mathit{o}^2 \in S_p$.
 %\par
 %Let $w^i$ and $r^j$ be signatures of read and write operations $\mathit{o}^1$ and
% $\mathit{o}^2$, respectively.
  %\par Using the above notations, Chockler et al. state the RYW consistency model as
  %\begin{align}
 % \begin{split}\label{chockler}
 % \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) \Rightarrow \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x),
 % \end{split}
 % \end{align} %%RYW is given in the form
%    \begin{align}\label{eqn:formdef}
%\begin{split}
% Condition 1 \Rightarrow Condition 2,
%  \end{split}
%  \end{align}
% where $\Rightarrow$ is the implies operator; Condition 1  and Condition 2 are given as follows.   Condition 1 is given in the form
%The precondition for the RYW condition is given by Chockler et al. as $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$, where $\mathit{o}^1$ and $\mathit{o}^2$ are  read and write operations  comprised in a given execution $\sigma_i$ of a process $p_i$.  The postcondition is given as $\mathit{o}^1 \xrightarrow{S_p} \mathit{o}^2$,
% where ${S_p}$ is an equivalent legal serialization  for a partial execution  $\sigma |i + w$ comprising
 %  operations invoked by $p_i$ plus writes invoked by other clients. %The
   %precedence relationships among operations $\mathit{o}^1$ and $\mathit{o}^2$ in
   %Condition 1 can be directly
 % expressed in terms of LTL as follows.
% Let $\mathit{inv}_1$ and  $\mathit{inv}_2$ denote the invocations, and $\mathit{resp}_1$ and  $\mathit{resp}_2$ denote the responses  of  $\mathit{o}^1$ a $\mathit{o}^2$, respectively.  Since the clients are well-formed (as we defined in Section  \ref{sec:definitions}),
 %the precedence relation  $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ %among $\mathit{o}^1$ and $\mathit{o}^2$ with respect to  $\sigma_i$ given
   %in   Equation \ref{chockler}  implies that
   %$ \mathit{inv}^1(x) \xrightarrow{\sigma_i} \mathit{resp}^1(x) $ and $ \mathit{resp}^1(x) \xrightarrow{\sigma_i} \mathit{inv}^2(x) $.
%    both the  invocation $\mathit{inv}_1$ and response $\mathit{resp}_1$   for $\mathit{o}^1(x)$ occur before the invocation $\mathit{inv}_2$ and response $\mathit{resp}_2$ for $\mathit{o}^2(x)$ can occur.  Hence, the precedence relation $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ among $\mathit{o}^1(x)$ and
% $\mathit{o}^2(x)$  can be rewritten in terms of the invocation and responses comprising  $\mathit{o}^1$ and
% $\mathit{o}^2$, i.e.,  $ \mathit{inv}_1 \xrightarrow{\sigma_i} \mathit{inv}_2 $ and $ \mathit{resp}_1 \xrightarrow{\sigma_i} \mathit{resp}_2 $, respectively.
% %Thus, $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ implies $\mathit{inv}^1 \xrightarrow{\sigma_i} \mathit{inv}^2$.
%  %Condition 1  denotes precedence among  $\mathit{o}^1$ and $\mathit{o}^2$ with respect to
%  % a given execution order $\sigma_i$.
%  By definition,  the session trace $\mathit{st}$ is a sequence comprised of results of operations observed in an execution $\sigma_i$ of the client $\mathit{Cl}_i$. Since operations comprised in $\mathit{st}$ for an execution $\sigma_i$ are ordered by the invocation times of  operations,  the precedence  relation $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ %, among operations in $\sigma_i$,
%  implies that the invocation of $\mathit{o}^1(x)$ occurred before the invocation of $\mathit{o}^2(x)$ in the temporal ordering of invocation times in  $\mathit{st}$. %can be expressed as a temporal relation   among the events of invocation of $\mathit{o}^1$ and $\mathit{o}^2$ in $\mathit{st}$.
  %Thus, we can express the precedence  operator $\xrightarrow{\sigma_i}$ using the
%  special-purpose LTL operator $F_\mathit{st}$ (defined in Section \ref{sec:definitions}), where  $F_\mathit{st}$ denotes an %``eventually" relationship  among invocation  of operations performed by the client $\mathit{Cl}_i$ with respect to $\mathit{st}$.  %Since $\mathit{st}$ orders the operations in terms of invocation times,  Condition 1 can be expressed in terms of an LTL expression that specifies the precedence among events in $\mathit{st}$ as follows.
  %Since the session trace  $\mathit{st}$ for the local execution $\sigma_i$ orders the operations according to invocation times,
   %Any precedence relation defined on an execution sequence $\sigma_i$  is
  % equivalent to the exact same precedence relation defined on the session trace $\mathit{st}$ in ConSpec.
   % Thus, replacing references to $\sigma_i$  with the notation  $\mathit{st}$, the expression $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ can be rewritten as  $ \square\; \mathit{inv}^1 \rightarrow \lozenge \mathit{inv}^2$. % F_\mathit{st} \mathit{inv}^2$. %, where $F_\mathit{st}$  is a  the special-purpose LTL operator (defined in Section \ref{sec:definitions}).
  %   Further, since clients in ConSpec are well-formed, the invocation and response for a given operation precedes the invocation and response of the next operation in $\mathit{st}$.  %An execution order $\sigma$ (invocation order) in
%   \cite{Chockler2000}of Chockler et al.  is equivalent to the program order $\mathit{po}$ in ConSpec.
  %Thus,  $ \square\; \mathit{inv}^1 \rightarrow \lozenge \mathit{inv}^2$ % F_\mathit{st} \mathit{inv}^2$
  % implies $  \square\; \mathit{resp}_1 \rightarrow \lozenge  \mathit{resp}_2 $, % F_\mathit{st}  \mathit{resp}_2 $,
   % which, in turn, implies $ \square\; \mathit{o}^1(x) \rightarrow \lozenge \mathit{o}^2(x)$. %F_\mathit{st} \mathit{o}^2(x)$.
 %Hence, we can rewrite a precedence relation $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ found in Chockler et al.\textquotesingle s definitions as $ \square\; \mathit{o}^1(x) \rightarrow \lozenge \mathit{o}^2(x)$.  % F_\mathit{st} \mathit{o}^2(x)$. %,  where we replace $\sigma_i$ with $\mathit{st}$ without loss of information (see above).
 %Let $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$  be propositional logic
%  variables that indicate whether invocations and responses of operations $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$  have
  %executed (if $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$ is TRUE) or not.  Then, the precondition reduces to
    %the ConSpec form $ \square\; \mathit{Op}^1(x) \rightarrow \lozenge  \mathit{Op}^2(x) $. % F_\mathit{st} \mathit{Op}^2(x) $.
%    \footnote{The above LTL expression implies: if the propositional variable
%    $\mathit{Op}^1$ (denoting the event of execution of operation $\mathit{o}^1$) is true at one point in the given session trace, $\mathit{Op}^2$ (denoting the event of execution of $\mathit{o}^2$)  is eventually true in some later point in a session trace $\mathit{st}$, i.e.,  the operation $\mathit{o}^2$ eventually follows the operation $\mathit{o}^1$ in the
%     given session trace $\mathit{st}$. }.  % Thus, the expressions $\left(\mathit{o}^1 \Rightarrow \mathit{o}^2\right)^\sigma$ can be rewritten as LTL formula
%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
% \par In the postcondition for RYW, Chockler et al.  specify a precedence relation $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$ , which  restricts a precedence relation among $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ in the equivalent legal serialization ${S_p}$ for the given $\sigma |i + w$.   By definition of $S_p$ in Section \ref{sec:definitions}, both the invocation and response for  an operation $\mathit{o}^2(x)$ in $S_p$ must appear after the invocation and response of a preceding operation $\mathit{o}^1(x)$ in $S_p$, i.e., $ \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x) $ implies $ \mathit{inv}^1 \xrightarrow{S_p} \mathit{inv}^2 $ and $ \mathit{resp}^1 \xrightarrow{S_p} \mathit{resp}^2 $.
    %Hence, all components of operation $\mathit{o}^2(x)$ follow all components of $\mathit{o}^1(x)$ in $S_p$.
%    Thus, we can rewrite the above precedence relation
%  $ \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x) $, in terms of Linear Temporal Logic, %(i.e., LTL),
%    as
%  %$\mathit{o}^1 F \mathit{o}^2 \in S_p$. Further, the above expression
%  %can be rewritten as
%  $ \square\;  \mathit{Op}^1(x) F_{S_p} \mathit{Op}^2(x)$. %, which is syntactically equivalent to $\mathit{Op}^1 F \mathit{Op}^2 \in S_p$. %,  where
%  $S_p$ is equivalent to $S_p$, i.e., both notations represent a legal serialization comprising all
  % operations performed from a given client application along with writes from all other clients.
%  Since RYW considers only those execution sequences where a write operation is followed by a read, $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$ can be  replaced  by new propositional variables
%   $W^{'}(x)$ and $R^{''}(x)$, without any loss of information. Thus, the above precondition and postcondition can be expressed as  $ \square\; W^{'}(x) F_\mathit{st} R^{''}(x)$ and $ \square\; W^{'}(x) F_{S_p}  R^{''}(x) $, respectively. %Further,
 %Thus, the above postcondition can be expressed as  $ \square\; \mathit{Op}^1(x) S_p \mathit{Op}^2(x)$.
  %By the  definition of a valid partial order in Definition \ref{def:form0}, we can replace $S_p$ in the postcondition with the notation  $\preccurlyeq_{\mathit{st}+w}$ (defined in Definition \ref{def:form0} and Equation \ref{eqn:RYW}) because of the following reason.  Thus, we can rewrite the above precedence relation  $ \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x) $ as $\mathit{Op}^1(x) \preccurlyeq_{\mathit{st}+w} \mathit{Op}^2(x)$. Since RYW considers only those execution sequences where a write operation is followed by a read, $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$ can be  replaced  by new propositional variables
   %$W^{'}(x)$ and $R^{''}(x)$, without any loss of information. Thus, the above precondition and postcondition can be expressed as  $ \square\; W^{'}(x) \rightarrow \lozenge R^{''}(x)$ and $ \square\; W^{'}(x) \preccurlyeq_{\mathit{st}+w}  R^{''}(x) $, respectively.
    %According to Chockler et al., a legal serialization $S_p$ is a sequence of operations that satisfies the following properties: Property 1) it is a linear sequence that comprises all operations from a given client $\mathit{Cl}_i$ plus writes from all other clients, and Property 2) each read in the sequence $S_p$ returns the result of the preceding write in $S_p$.  First, by definition (refer to definition of $\preccurlyeq$ in the RYW expression, $\preccurlyeq_{\mathit{st}+w}$ is a partial order  comprising all operations in a session trace $\mathit{st}$ plus writes from other operations, thus $\preccurlyeq_{\mathit{st}+w}$ satisfies Property 1 for $S_p$. Second, following directly from precondition of RYW, the output of each operation in $\preccurlyeq_{\mathit{st}+w}$ is equivalent to that obtained by executing a linear sequence of the operations preceding that operation, thus $\preccurlyeq_{\mathit{st}+w}$ satisfies Property 2 for $S_p$. Hence, we can express the postcondition
    %$ \square\; W^{'}(x) \preccurlyeq_{\mathit{st}+w} R^{''}(x) $ as  $W^{'}(x) \preccurlyeq_{\mathit{st}+w} R^{''}(x)$. Combining the above conditions, Chockler's definition of RYW reduces into the ConSpec specification in Equation \ref{eqn:RYW}.   %Derivations of remaining consistency models  are given in the appendix in Section \ref{sec:restderive}.
%   Further, the anomaly condition $C$ for RYW can be derived as follows. Let us consider that there exists
%   a write operation $w^l$ precedes $w^i$, i.e., ${W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t$, and a read operation
%    $r^k$ precedes $r^j$, i.e., ${R^k}^{'} F {R^j}^{'} \in \mathit{st}$. According to the
%    definition of RYW in \cite{Terry:1994:SGW:645792.668302, Burckhardt:2014:PEC:2693641.2693642},
%   either of the following conditions must be satisfied: 1) $r^j$ must not observe a value that was written by $w^l$ if the result of the later write
%   $w^j$ was already read by read $r^k$, i.e., $\left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right)$, or
%   2) the read $r^j$ is directly followed by the write $w^l$, i.e.,  the condition
%   $\left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)$
%   must hold.
%  % Let $w^k(o,v_k)$ be signature of the write operation $\mathit{o}^k$, which overwrites the value written by
%%   $\mathit{o}^1$; let $W^k$ be a propositional variable that indicates whether the operation
%%   $\mathit{o}^k$ returns the result.
%%  Replacing variables $\mathit{Op}^1$, $\mathit{Op}^2$, and $\mathit{Op}^k$  with variables $W^j(v_l)$, $R^k{v_m}$, and
%%  $W^p(v_q)$, respectively, the above condition can be expressed as
%%  $\not\exists W^k \in \mathit{st} \left( W^k F W^i F R^j \in \mathit{st} \right)$.
%  From the above reasoning, we can directly derive the ConSpec expression $C$ = $\not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge \\
%%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) %\big) \\
%\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)$
% (refer to Equation \ref{eqn:RYW}.
 %\begin{align}
%  \begin{split}
%\forall i, j, o, \mathit{st} \big( \left( W^i F R^j \in \mathit{st} \right) \;
% \Rightarrow \; \exists S_p \left(  W^i F R^j \in S_p \right)
%\\ \wedge  \not\exists W^k \in \mathit{st} \left( W^k F W^i F R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
% \wedge \left( v^j = v^k \right) \big).
%  \end{split}
%  \end{align}
% In the above expression, the condition \\ $\left( W^j(v_l) F W^p(v_q) F R^k{v_m} \right) \oplus \left( W^j(v_l)X^{o}R^k{v_m} \right)$ in a session trace $\mathit{st}$ implies that either 1) the read operation $R^k{v_m}$ returns the value written by the write operation $w^j(o,v_l)$, or 2) a value that is written by a write operation $w^p(o,v_q)$, that follows $w^j(o,v_l)$ and overwrites $o$. The condition 1 in the above statement, in turn, implies that $v_m = v_l$. Plugging in the above expression in Equation \ref{eqn:RYWder}, the above expression can be reduced to the ConSpec expression for RYW, given as
%  \begin{align}\label{eqn:RYWFin}
%\begin{split}\forall i, j, k, l, m \left(\star W^j(v_l)X^{o}R^k{v_m} \star \right)_{o}^\mathit{po} \\ \Rightarrow \left(G\;  \left( W^j(v_l) F W^p(v_q) F R^k{v_m} \right) \oplus \left( v_m = v_l \right) \right)_{o}^\mathit{st}
%\end{split}
%\end{align}.

%%\par The ConSpec specifications for the isolation levels are derived from the definitions by Adya et al.
%%\cite{DBLP:conf/icde/AdyaLO00}.  Here, we show that the isolation specifications in ConSpec, given in
%%Equations \ref{eqn:PL1}, \ref{eqn:PL2}, \ref{eqn:PL3}, and \ref{eqn:PL299}, follow directly from the
%%definitions of isolation levels PL-1, PL-2, PL-3, and PL-2.99 \cite{DBLP:conf/icde/AdyaLO00}. We analyze the
%%ConSpec Equations, and demonstrate their equivalence to the definitions of  \cite{DBLP:conf/icde/AdyaLO00}, as
%%follows.
%%\par  The PL-1 specification states that the anomaly G0 must be proscribed in any session trace collected
%%for the execution of a client application. G0 specifies that there can not be any directed cycle in the
%%dependency graph corresponding to an execution of a pair of transactions, comprising entirely of write dependency edges.
%%%The
%%% condition can be avoided if the write dependencies are preserved in any execution of a given client
%%% application, i.e., if any pair of write operations are executed in order. The LHS of
%%%  Equation \ref{eqn:PL1}, i.e., the expression $W^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st}$
%%%  denotes the above precondition with respect to a given session trace $\mathit{st}$ comprising any two
%%%  write operations $w^i_{tx}$ and $w^j_{tx}$. PL-1 specifies that any session trace must
%%%  comprise the above write operations in the same order. This, in turn, implies that the write operation
%%%  $w^j_{tx}$ in the session trace $\mathit{st}$ must overwrite the value written by the write operation $w^i_{tx}$, i.e.,
%%%  $r^k_{tx}$ that follows the write operation $w^j_{tx}$ must not return the value $v_i$ written by an earlier
%%%   write. The above condition can be expressed as $\not\exists R^k_\mathit{tx} \in \mathit{st} \left( W^i_\mathit{tx} F W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^k = v^i \right)$.
%%%  Thus, the above condition can be reduced to the RHS of Equation \ref{eqn:PL1} using ConSpec operators.
%% Let us consider a pair of transactions $\mathit{tx}$ and $\mathit{ty}$. Let us consider that write operations
%% $w(x)_\mathit{tx}$ and $w^{'}(y)_\mathit{tx}$ write to objects $x$ and $y$ from transaction $\mathit{tx}$, and
%% $w^{''}(x)_\mathit{ty}$ and $w^{'''}(y)_\mathit{ty}$ write to objects $x$ and $y$ from transaction $\mathit{ty}$.
%% According to PL-1 there can not exist a pair of read operations $r^{''''}(x)_\mathit{tx}$ and $r^{'''''}(y)_\mathit{ty}$
%% invoked from transactions  $\mathit{tx}$ and $\mathit{ty}$  such that the following conditions are simultaneously
%% satisfied: 1) $r^{''''}(x)_\mathit{tx}$ reads the result of the
%% write operation $w(x)_\mathit{tx}$ causing a $ww$ dependency from  $\mathit{tx}$ to $\mathit{ty}$, i.e.,
%% $v^{''''}= v$ must not hold, and 2)
%%  $r^{'''''}(y)_\mathit{ty}$ reads the result of the
%% write operation $w^{'''}(y)_\mathit{ty}$ causing a $ww$ dependency between  $\mathit{ty}$ to $\mathit{tx}$, i.e.,
%% $v^{'''''} = v^{'''} $ must not hold. Simultaneous
%% satisfaction of conditions 1 and 2 results in a cycle comprising $ww$ dependencies between $\mathit{tx}$ and $\mathit{ty}$.
%% Thus, we can express the specification of PL-1 as
%%$C = \forall \mathcal{S}_t, \mathit{st}, \mathit{tx}, \mathit{ty}, x, y,
%%  {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty} \in  \mathcal{S}_t \\
%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%  \left( \not\exists {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \right)
%%  % \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%\big( \left( \left( v^{'''''} = v^{''''} \right) \wedge \left( v^{''''} = v \right) \right) \vee \\
%%\left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big)$
%% which is identical to Equation \ref{eqn:PL1}. %It can be trivially observed that the above expression for PL-1 proscribes the anomaly G0, and thus satisfies PL-1 specifications.
%%\par The isolation level PL-2 proscribes the anomalies G1-a, G1-b, and G1-c \cite{DBLP:conf/icde/AdyaLO00}. We show that
%%the ConSpec specification for PL-2, given in Equation \ref{eqn:PL2}, disallows the above anomalies as follows.
%%\textbf{G1-a}: According to G1-a, a transaction can not observe a value written by an aborted transaction.
%% In other words, if either transaction  $\mathit{tx}$ or transaction $\mathit{ty}$ aborts, i.e., either of the conditions $a_\mathit{tx} \in \mathit{st}$ or $a_\mathit{ty} \in \mathit{st}$ hold,
%% then there can not exist a read operation that reads the value written by an aborted transaction, i.e., the conditions
%% ${W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st}$ or $ {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}$
%% can not hold.
%%Thus, the G1-a condition ca be directly translated to the expression $\not\exists a_\mathit{tx} \in \mathit{st} \;
%% \left( {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%  \not\exists a_\mathit{ty} \in \mathit{st} \;
%% \left( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st} \right)$ in Equation \ref{eqn:PL2}.
%%  \textbf{G1-b}: According to G1-b, a transaction must always read the final committed version of an object.
%%  Let us consider consecutive write operations  $w(x)_\mathit{tx}$ and  $w^{'}(x)_\mathit{tx}$ invoked from transaction $\mathit{tx}$
%%   followed by the commit statement $c_\mathit{tx}$, and a read operation $r^k(x)_\mathit{ty}$ invoked from transaction $\mathit{ty}$, i.e.,
%%   $ {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} F {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}$.
%% According to G1-b, $\mathit{ty}$ can never read a value written by an operation in $\mathit{tx}$ that was not finally committed by $tx$.
%% Thus, $r^{''}(x)_\mathit{ty}$ cannot return the result of $w(x)_\mathit{tx}$ since it was overwritten by another write
%%  $w^{'}(x)_\mathit{tx}$ before the commit $c_\mathit{tx}$.
%% The above condition can be expressed as $\not\exists \big( \big(
%% {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} F {R}(x)^{'''}_\mathit{ty} \in  \mathit{st} \big)
%%   \wedge \left( v^{''} = v \right)  \big) \wedge
%%   \not\exists \big( \big(
%% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} F {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \big)
%%   \wedge \left( v^{''} = v \right)  \big)$.
%% \textbf{G1-c}: %PL-2 orders all operations according to their w-r dependency, i.e., if their is a write
%%% followed by a read in an execution sequence, all executions must contain the above write and read in the same order.
%%  G1-c specifies that there can be no direct cycle comprising dependency edges, i.e., $wr$ and $ww$ dependencies, between
%%  transactions in a given execution. The condition \\
%%  $\not\exists \big(
%% {W}(x)^{'}_\mathit{tx}, {R}(y)^{''}_\mathit{tx}, {W}(y)^{'''}_\mathit{ty}, {R}(x)^{''''}_\mathit{ty} \in  \mathcal{S}_t \big)
%%   \big( \left( v^{'''} = v \right) \\
%%   \wedge \left( v^{''} = v^{'} \right) \big)$ proscribes $wr$ dependency cycles. The expression
%%   \\ $\big( \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \\ \in \mathcal{S}_t \big)
%%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%\big( \left( \left( v^{'''''} = v^{''''} \right) \wedge \left( v^{''''} = v \right) \right) \vee  \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big)$
%%proscribes $ww$ cycles. % In
%%%  the LHS of Equation \ref{eqn:PL2}, the expressions
%%%  $ \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \\
%%%\wedge \left( W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)
%%%$ denotes the condition that there are write operations followed by read operations in the execution order of
%%% transactions $tx$ and $ty$, respectively. Similarly, the RHS of Equation \ref{eqn:PL2} indicates the
%%% following. Let us consider that the above condition holds for a given session trace. Then, read operations
%%%   that follow the operations $w^i_{tx}$ and $r^j_{tx}$, or $w^k_{ty}$ and $r^l_{ty}$, respectively, in the respective transactions
%%% $tx$ and $ty$, must not observe results of write operations that occurred earlier than $w^i_{tx}$ or $w^k_{ty}$
%%% according in the session trace $\mathit{st}$.   This, in turn, implies that \\
%%%  $\not\exists W^m_\mathit{tx} \in \mathit{st} \left( W^m_\mathit{tx} F W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^m_\mathit{tx} F W^i_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^j = v^m \right) \\
%%%\wedge \not\exists W^n_\mathit{ty} \in \mathit{st} \left( W^n_\mathit{ty} F W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right) \wedge \left( W^n_\mathit{ty} F W^k_\mathit{ty} \in \mathit{st} \right) \\ \wedge \left( v^l = v^n \right)$,
%%%   thus Equation \ref{eqn:PL2} proscribes G1-c.
%%%     Further, in the RHS, all operations in $tx$ occur before the commit
%%%   operation $c_{tx}$ is executed in the session trace $\mathit{st}$. The above condition is true for operations in
%%%   transaction $ty$ as well, thus proscribing G1-a. Further, we can observe that in the RHS, $tx F ty$, i.e., an
%%%   operation in $ty$ can only occur after all operations in $tx$ have finished, proscribing G1-b.
%% Thus, the ConSpec
%%   specification of PL-2 in  Equation \ref{eqn:PL2} proscribes G1-a, G1-b, and G1-c; thus, Equation \ref{eqn:PL2} is
%%   equivalent to PL-2 specifications by Adya et al.
%%% \begin{align}\label{eqn:PL2}
%%%\begin{split}
%%%\forall i, j, k, l, m, n, q, s, t, u, tx, ty \big( tx F ty \; \wedge \left( w^j_{tx}(o,v_l)X^{o} r^k_{tx}(o){v_m} \right) \\ \wedge \left( w^n_{ty}(o,v_q)X^{o} r^s_{tx}(o){v_u} \right)  \big)^\mathit{po}_{\mathit{o}_i} \\ \Rightarrow \big(\left( v_l \gets (\left( w^j_{tx}(o,v_l) \; X^{o} \; r^k_{tx}(o){v_m} \right) \right) F \;  c_{tx} \\ F \; \left( v_q \gets \left( w^n_{ty}(o,v_q) \; X^{o} \; r^s_{ty}(o){v_u} \right) \right) \; F \; c_{ty} \star \big)^\mathit{st}_{\mathit{o}_i},
%%%\end{split}
%%%  \end{align}
%% \par  The isolation level PL-3 proscribes the anomaly G-2 \cite{DBLP:conf/icde/AdyaLO00}. According to the
%% ConSpec specification for PL-3 (refer to Equation \ref{eqn:PL3}), apart from proscribing G1 anomalies, G2 anomalies are
%%  also disallowed. According to G2, their can be
%% effectively no cycle comprising anti-dependency edges between transactions. The expression \\
%% $\big( \not\exists  \left({R}(x)^{'}_\mathit{tx} F {W}(x)^{''}_\mathit{ty} F {R}(x)^{'''}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%  \big( {R}(x)^{''''}_\mathit{ty} F {W}(x)^{'''''}_\mathit{tx} F {R}(x)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \big) \big(  \left( v^{''} = v^{'} \right) \wedge \\
%% \left( v^{'''''} = v^{''''} \right) \big) \big)$ proscribes anti-dependency cycles. Thus, the
%% ConSpec expression disallows G2, and effectively follows PL-3. Following the same line of reasoning, we can
%%  prove that the ConSpec expression in Equation \ref{eqn:PL299} effectively  specifies PL-2.99.
%

% \subsection{Specification of Isolation Levels}
%  For specifying isolation levels, we consider only the isolation levels defined by Adya et al. \cite{DBLP:conf/icde/AdyaLO00}. We show the equivalence between the graphical representation of the dependency relations used by Adya et al. and the LTL specifications of ConSpec in Section \ref{sec:equiv}.
% The isolation level PL-1 mandates that write operations in  a transaction must be executed such that write-write
% dependency cycles among transactions are proscribed. %before any write from a different transaction executes.
% Following Definition \ref{def:form0}, PL-1 is specified %in the \textbf{form-2} format, given in Equation \ref{form-2},
% as follow.
% % \begin{align}\label{eqn:PL1}
%%\begin{split}
%%\forall i,j,k,l,m, tx, ty \left( tx F ty \; \wedge \; \star w^i_{tx} F w^j_{tx} \star \; \wedge \; \star w^k_{ty} F w^l_{ty} \star \right)^\mathit{po}_{o_m} \\
%%\Rightarrow \left(\star w^i_{tx} F w^j_{tx} \star \; \wedge \; \star w^k_{ty} F w^l_{ty} \star  \right)^\mathit{st}_{o_m},
%%\end{split}
%%  \end{align}
% %\begin{align}\label{eqn:PL1}
%%\begin{split}
%%\forall i,j, m, tx \left( \star w^i_{tx} F^{o} w^j_{tx} \star \right)^\mathit{po}_{o_m}
%%\Rightarrow \left(\star w^i_{tx} F^{o} w^j_{tx} \star  \right)^\mathit{st}_{o_m},
%%\end{split}
%%  \end{align}
%  \begin{align}\label{eqn:PL1}
%\begin{split}
%%\forall i, j, k, l, m, n, p, q, u, z, tx \\ \big( \star W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} R^p_{tx}{v_n} \star \big)^\mathit{po}_{o} \\
%%\Rightarrow \big(G \star \left( v_n = v_q \right) \oplus \\ \left( W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} W^u_{tx}(v_z)  X^{o} R^p_{tx}{v_n}  \right) \star  \big)^\mathit{st}_{o},
%%\forall i, j, tx \\ \big( \star W^i_{tx} F^{o} W^j_{tx}(v_q) X^{o} R^p_{tx}{v_n} \star \big)^\mathit{po}_{o} \\
%%\Rightarrow \big(G \star \left( v_n = v_q \right) \oplus \\ \left( W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} W^u_{tx}(v_z)  X^{o} R^p_{tx}{v_n}  \right) \star  \big)^\mathit{st}_{o},
%%\forall i, j, o, \mathit{st}, \mathit{tx} \big( \left( W^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st} \right) \; \Rightarrow \; \exists S_p \left(  W^i_\mathit{tx} F W^j_\mathit{tx} \in S_p \right)
%%\\ \wedge  \not\exists R^k_\mathit{tx} \in \mathit{st} \left( W^i_\mathit{tx} F W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^k = v^i \right) \big),
% E^S_C = \forall  \mathit{st} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in \mathcal{S}_t, x, y,\\
%  {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty} \in  \mathcal{S}_t \\
% %\mathit{tx} F \mathit{ty} \Rightarrow
%  \big( \left( \not\exists {R^{'''''}}(x)_\mathit{tx}, {R^{''''''}}(y)_\mathit{ty} \in \mathcal{S}_t \right) \\
%  % \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%\big( \left( \left( v^{'''''}= v^{'''} \right) \wedge \left( v^{''''} = v \right) \right) \vee \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''}  \right) \right)  \big) \big)
%\end{split}
%  \end{align} where $\mathit{tx}$ and $\mathit{ty}$  are consecutive transactions.
%
%The isolation level PL-2 states that operations from a transaction can not read a value that was not the final value that was
%committed by a transaction. Further, a transaction cannot read values written by aborted transactions. Additionally,
%operations in a transaction must be executed in an order
%that proscribes write-write and write-read dependency cycles \cite{DBLP:conf/icde/AdyaLO00} among transactions. PL-2 is given as
% % \begin{align}\label{eqn:PL2}
%%\begin{split}
%%\forall i, j, tx, ty \left( tx F ty \right)^\mathit{po}_{\mathit{o}_j} \Rightarrow \left(\star c_{tx} F \mathit{o}^i_{ty} F c_{ty} \star \right)^\mathit{st}_{\mathit{o}_j},
%%\end{split}
%%  \end{align}
%%\begin{align}\label{eqn:PL2}
%%\begin{split}
%%\forall i, j, m, tx, ty \left( tx F^{o} ty \; \wedge w^i_{ty} F^{o} r^j_{ty} \right)^\mathit{po}_{\mathit{o}_m} \Rightarrow \\ \left(\star c_{tx} F^{o} w^i_{ty} F^{o} r^j_{ty} F^{o} c_{ty} \star \right)^\mathit{st}_{\mathit{o}_m},
%%\end{split}
%%  \end{align}
%  \begin{align}\label{eqn:PL2}
%\begin{split}
%%\forall i, j, k, l, m, n, p, q, u, a, b, c, tx, ty \big( \left( tx F ty \right) \\ \wedge \left( \star W^j_{tx}(v_l)X^{o} R^k_{tx}{v_m} \star \right) \wedge \left( \star W^n_{ty}(v_q)X^{o} R^s_{ty}{v_u} \star \right) \big)^\mathit{po}_{\mathit{o}_i} \\
%%\Rightarrow \big( G \; \left( \left( v_m = v_l \right) \oplus \left( W^j_{tx}(v_l) F^{o} W^p_{tx}(v_a) X^{o} R^k_{tx}{v_m} \right) \right) F \;  c_{tx} \\ F \; \left( \left( v_u = v_q \right) \oplus \left( W^n_{ty}(v_q) F^{o} W^b_{ty}(v_c) X^{o} R^s_{ty}{v_u} \right) \right) \; F \; c_{ty} \star \big)^\mathit{st}_{\mathit{o}_i},
%%\forall i, j, k, l, o, \mathit{st}, \mathit{tx}, \mathit{ty} \big( \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \\
%%\wedge \left( W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)
%%\; \Rightarrow \; \exists S \left( W^i_\mathit{tx} F R^j_\mathit{tx} F c_\mathit{tx} \in S \right) \\
%%\wedge \left(  c_\mathit{tx} F W^k_\mathit{ty} F R^l_\mathit{ty} F c_\mathit{ty} \in S_p \right)
%%\\ \wedge  \not\exists W^m_\mathit{tx} \in \mathit{st} \left( W^m_\mathit{tx} F W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \wedge \left( v^j = v^m \right) \\
%%\wedge \not\exists W^n_\mathit{ty} \in \mathit{st} \left( W^n_\mathit{ty} F W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)  \wedge \left( v^l = v^n \right) \big)
%E^{r} = \forall  \mathit{st}, \mathit{st}^{'} \in  \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in  \mathcal{S}_t \\ \big(
% % \mathit{tx} F \mathit{ty} \Rightarrow
% \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
% \big(  {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \big) \\
%  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
% \big( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
% \big( \not\exists  {W}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{tx}, \\ {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}  \big)
% \big( \left( {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
%   \wedge \left( v^{''} = v \right)  \big)  \wedge
%   \not\exists \left( {W}(x)^{'}_\mathit{ty}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \right) \\
%    \big( \left(
% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
%   \wedge \left( v^{''} = v \right)  \big) \wedge
% %\mathit{tx} F \mathit{ty} \Rightarrow
%  \big( \\ \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \\ \big)
%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%\big( \left( \left( v^{''''} = v^{'''} \right) \wedge \left( v^{'''''} = v \right) \right) \vee \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big) \big) %\wedge \\
%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%% \big( \not\exists  \left({R^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%  \left({R^l}(y)^{'}_\mathit{ty} F {W^m}(y)^{'}_\mathit{tx} F {R^n}(y)^{'}_\mathit{tx} \in \mathcal{S}_t \right)  \big) \big(  \left( v_k^{'} = v_j^{'} \right) \wedge \\
%% \left( v_n^{'} = v_m^{'} \right) \big)
% %\big)
%  %\left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right)  \big) \big)
% %\left( c_{ty} F {\mathit{Op}^i}^{'}_\mathit{tx} \in \mathit{st} \right) \big) \wedge \\
%% \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx}, {W^j}(y)^{'}_\mathit{tx}, {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty} \in  \mathcal{S}_t \right) \wedge  \\
%%  \left( {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{st} \right) \big)
%%  \big( \left( v_m^{'} = v_j^{'} \right) \wedge \left( v_n^{'} = v_k^{'} \right) \big)  \wedge \\
%%  \forall \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{tx} \in \mathit{st} \right) \left( {v_i}^{'} = {v_j}^{'} \right) \big)
%\end{split}
%  \end{align} where $c_{tx}$ and $c_{ty}$ are the commit statements for the transactions $\mathit{tx}$ and $\mathit{ty}$, respectively. F is the traditional LTL next operator.
%
% The isolation level  PL-3 specifies that, on top of PL-2,  read-write dependency cycles \cite{DBLP:conf/icde/AdyaLO00}
%  must also be proscribed among transactions. PL-3 is given as
% %\begin{align}\label{eqn:PL3}
%%\begin{split}
%%\forall i,j,k,l,m, tx, ty \left( tx F^{o} ty \; \wedge \; \star \mathit{o}^i_{tx} F^{o} \mathit{o}^j_{tx} \star \; \wedge \; \star \mathit{o}^k_{ty} F^{o} \mathit{o}^l_{ty} \star \right)^\mathit{po}_{o_m} \\
%%\Rightarrow \left(\star \mathit{o}^i_{tx} F^{o} \mathit{o}^j_{tx} F^{o} c_{tx} F^{o} \mathit{o}^k_{ty} F^{o} \mathit{o}^l_{ty} F^{o} c_{ty}  \right)^\mathit{st}_{o_m}.
%%\end{split}
%%  \end{align}
%  \begin{align}\label{eqn:PL3}
%\begin{split}
%%\forall i, j, k, l, m, n, q, s, t, u, w, x, z, a, b, c, d, e, f, g, h, tx, ty \\
%%\big( \left( tx F ty \right) \wedge \left( \mathit{Op}^j =  \left(W^j_{tx}(v_l) \oplus R^k_{tx}{v_m} \right) \right) \wedge \\
%%\left( \mathit{Op}^n = \left( W^n_{tx}(v_q) \oplus R^s_{tx}{v_t} \right) \right)  \wedge \left( \star  \mathit{Op}^j X^{o} \mathit{Op}^n \star \right) \wedge \\
%%\left( \mathit{Op}^u = \left(W^u_{ty}(v_w) \oplus R^x_{ty}{v_z} \right) \right) \wedge \left( \mathit{Op}^a = \left( W^a_{ty}(v_b) \oplus R^c_{ty}{v_d} \right) \right) \\
%%\left( \star \mathit{Op}^u X^{o} \mathit{Op}^a   \star \right) \big)^\mathit{po}_{o} \\
%%\Rightarrow \big(G \; \left( v_f = v_q \right)  \oplus \left( v_t = v_l \right) \oplus \left( v_t = v_m \right) \big)  \\
%%  F c_{tx} F \big( \left( v_h = v_b \right) \oplus \left( v_d = v_b \right) \oplus \left( v_d = v_z \right) \big) F c_{ty}  \big)^\mathit{st}_{o}.
%%E^{r} = C = \big( \not\exists \left( a_\mathit{tx} \oplus a_\mathit{ty} \in \mathit{st} \right)
%% \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st} \right)  \wedge
%%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%% \not\exists \big( \big( \\
%% {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \big)
%%   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge \\
%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%  \left( \not\exists {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
%%  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty}, {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \\
%%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big) \wedge \\
%%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%% \left( \not\exists {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^p}(x)^{'}_\mathit{tx}, {R^q}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \big(  \left( v_p^{'} = v_j^{'} \right) \wedge \\
%% \left( v_q^{'} = v_i^{'} \right) \big)
%%   \big) \big) \wedge
%%%\forall  \mathcal{S}_t, \mathit{st}, \mathit{st}^{'}, \mathit{tx}, \mathit{ty} \big(
%%%  \mathit{tx} F \mathit{ty} \Rightarrow \\
%%% \big( \not\exists \left( \left( a_\mathit{tx} \in \mathit{st} \right) \wedge \left( a_\mathit{ty} \in \mathit{st} \right) \right) \wedge \\
%%% %\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \right)  \wedge \left( v_k^{'} = v_i^{'} \right)  \right) \wedge \\
%%%  \left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \\
%%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%%% \left( \not\exists {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^p}(x)^{'}_\mathit{tx}, {R^q}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \big(  \left( v_p^{'} = v_j^{'} \right) \wedge \\
%%% \left( v_q^{'} = v_j^{'} \right) \big) \wedge
%%%   \big) \big)
%%%E^S_C =  \forall  \mathcal{S}_t, \mathit{st} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \big(
%%%  \mathit{tx} F \mathit{ty} \Rightarrow \\
%%% \big( \not\exists \left( a_\mathit{ty} F a_\mathit{tx} \in \mathit{st} \right) \wedge \not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%%%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%%%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%%%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right) \wedge \\
%%   \not\exists \big( \left( {R^i}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right) \big) \\
%%  \big( \left( \left( v_k^{'} = v_j^{'} \right)  \wedge \left( v_p^{'} = v_m^{'} \right) \right)  \big) \big) \big) \big)
%E^{r} = C = \forall \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in \mathcal{S}_t \\ \big(
% % \mathit{tx} F \mathit{ty} \Rightarrow
% \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
% \big(  {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \big) \\
%  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
% \big( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
% \big( \not\exists  {W}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{tx}, \\ {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}  \big)
% \big( \left( {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
%   \wedge \left( v^{''} = v \right)  \big)  \wedge
%   \not\exists \left( {W}(x)^{'}_\mathit{ty}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \right) \\
%    \big( \left(
% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
%   \wedge \left( v^{''} = v \right)  \big) \wedge
% %\mathit{tx} F \mathit{ty} \Rightarrow
%  \big( \\ \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \\ \big)
%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%\big( \left( \left( v^{''''} = v^{'''} \right) \wedge \left( v^{''''} = v \right) \right) \vee \\ \left( \left( v^{''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big) \wedge \\
%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%    \big( \not\exists {R}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{ty}, {R}(y)^{''''}_\mathit{ty}, {W}(y)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \\
%     \big( \big( {R}(x)^{'}_\mathit{tx} F {W}(x)^{''}_\mathit{ty} F {R}(x)^{'''}_\mathit{ty} \in \mathcal{S}_t \big) \wedge \\
%  \big(  {R}(y)^{''''}_\mathit{ty} F {W}(y)^{'''''}_\mathit{tx} F {R}(y)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \big)  \\
%  \big(  \left( v^{''} = v^{'} \right) \wedge
% \left( v^{'''''} = v^{''''} \right) \big) \big) \big)
%%\left( \mathit{Op}^i_\mathit{tx} X^o \mathit{Op}^j_\mathit{tx} \in \mathit{st} \right) \wedge
%% \left( \mathit{Op}^k_\mathit{ty} X^o \mathit{Op}^l_\mathit{ty} \in \mathit{st} \right)
%%\\ \Rightarrow \exists S \left( \mathit{Op}^i_\mathit{tx} X^o \mathit{Op}^j_\mathit{tx} F c_\mathit{tx} F \mathit{Op}^k_\mathit{ty} X^o \mathit{Op}^l_\mathit{ty} F c_\mathit{ty}  \in S \right)  \wedge \\
%% \forall \mathit{st}  \left( \mathit{Op}^j_\mathit{tx} X^o R^m_\mathit{tx} \in \mathit{st} \right) \wedge \left( v^m = v^j  \right) \wedge \\
%% \forall \mathit{st}  \left( \mathit{Op}^k_\mathit{ty} X^o R^n_\mathit{ty} \in \mathit{st} \right) \wedge \left( v^n = v^k  \right) \big) \big)
%\end{split}
%  \end{align}
%  The isolation level  PL-2.99 specifies that, on top of PL-2, read-write item-dependency cycles must be proscribed among transactions. PL-2.99 is given as
%  \begin{align}\label{eqn:PL299}
%\begin{split}
%%\forall i, j, k, l, m, n, p, q, s, t, u, a, b, c, d, e, f, tx, ty \\ \big( \left( tx F ty \right) \wedge \left( \left( \star R^j_{tx}{v_l} F^{o} W^k_{tx}(v_m) X^{o} R^p_{tx}{v_t} \star \right) \right) \\ \wedge \left( \left( \star R^n_{ty}{v_s} F^{o} W^q_{ty}(v_u) X^{o} R^a_{ty}{v_b} \star \right) \right) \big)^\mathit{po}_{o_m} \\
%%\Rightarrow \big( G \left( v_t = v_m \right) \oplus \left( R^j_{tx}{v_l} F^{o} W^c_{tx}(v_d) F^{o} W^k_{tx}(v_m) X^{o} R^p_{tx}{v_t} \right) \\ F \;  c_{tx} \; F \; \\  \left( v_b = v_u \right) \oplus \left( R^n_{ty}{v_s} F^{o} W^q_{ty}(v_u) F^{o} W^e_{ty}(v_f) X^{o} R^a_{ty}{v_b} \right) \\ F \;  c_{ty} \big)^\mathit{st}_{o_m}.
%%E^S_C =  \forall  \mathcal{S}_t, \mathit{st} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \big(
%%  \mathit{tx} F \mathit{ty} \Rightarrow \\
%% \big( \not\exists \left( a_\mathit{ty} F a_\mathit{tx} \in \mathit{st} \right) \wedge \not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right) \wedge \\
%E^{r} = C = \forall \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in \mathcal{S}_t \\ \big(
% % \mathit{tx} F \mathit{ty} \Rightarrow
% \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
% \big(  {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \big) \\
%  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
% \big( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
% \big( \not\exists  {W}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{tx}, \\ {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}  \big)
% \big( \left( {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
%   \wedge \left( v^{''} = v \right)  \big)  \wedge
%   \not\exists \left( {W}(x)^{'}_\mathit{ty}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \right) \\
%    \big( \left(
% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
%   \wedge \left( v^{''} = v \right)  \big) \wedge
% %\mathit{tx} F \mathit{ty} \Rightarrow
%  \big( \\ \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \\ \big)
%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%\big( \left( \left( v^{'''''} = v^{''''} \right) \wedge \left( v^{'''''} = v \right) \right) \vee \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big) \wedge \\
%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%    \big( \not\exists {R}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{ty}, {R}(x)^{''''}_\mathit{ty}, {W}(x)^{'''''}_\mathit{tx}, {R}(x)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \\
%     \big( \big( {R}(x)^{'}_\mathit{tx} F {W}(x)^{''}_\mathit{ty} F {R}(x)^{'''}_\mathit{ty} \in \mathcal{S}_t \big) \wedge \\
%  \big(  {R}(x)^{''''}_\mathit{ty} F {W}(x)^{'''''}_\mathit{tx} F {R}(x)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \big)  \\
%  \big(  \left( v^{''} = v^{'} \right) \wedge
% \left( v^{'''''} = v^{''''} \right) \big) \big) \big)
%%E = C = \forall i, j, k, l, o, \mathit{st}, \mathit{tx}, \mathit{ty} \big( \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( R^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st} \right) \\
%%\wedge \left( R^k_\mathit{ty} F W^l_\mathit{ty} \in \mathit{st} \right)
%%\\ \Rightarrow \; \exists S \left( R^i_\mathit{tx} F W^j_\mathit{tx} F c_\mathit{tx}  F R^k_\mathit{ty} F W^l_\mathit{ty} F c_\mathit{ty}\in S \right) \\
%%\\ \wedge  \not\exists R^m_\mathit{tx} \in \mathit{st} \left( R^i_\mathit{tx} F W^j_\mathit{tx} F R^m_\mathit{tx} \in \mathit{st} \right)  \wedge \left( v^i = v^m \right) \\
%%\wedge  \not\exists R^n_\mathit{ty} \in \mathit{st} \left( R^k_\mathit{ty} F W^l_\mathit{ty} F R^n_\mathit{ty} \in \mathit{st} \right) \wedge \left( v^k = v^n \right) \big)
%\end{split}
%  \end{align}
%\subsection{Derivations of Rest of the ConSpec Specifications}\label{sec:restderive}
  %Session Monotonic or Monotonic Read (also referred to as Session Causality or MR) consistency model is
 %another popular consistency model \cite{Chockler2000, Terry:1994:SGW:645792.668302}.
 %\par  According to Chockler et al.,
 %MR is expressed in terns of a correctness condition \begin{equation}\label{eqn:formdef}
%\begin{split}$
%Condition 1 \Rightarrow Condition 2, \end{equation} %in Equation \ref{eqn:formdef}, %as: if the condition  (Condition 1) $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ holds for a given execution sequence $\sigma_i$,
% where both $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ are read operations.
   %Equation \ref{eqn:formdef} is given as %$\begin{align}\label{eqn:formdef}
%\begin{split}
 %$Condition 1 \Rightarrow Condition 2$,
 % \end{split}
 % \end{align}
% and $\Rightarrow$ is the implies operator. %,
  %there must exist a serialization ${S_p}$, comprising the
   %operations $\mathit{o}^1$ and $\mathit{o}^2$, for which the condition (Condition 2)
  %$\mathit{o}^1 \xrightarrow{S_p} \mathit{o}^2$ holds.
   %Following the same logic as that used in the derivation of RYW (refer to Section \ref{sec:list}), the precedence relationships among operations $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ in Condition 1 can be directly
  %expressed in terms of an LTL expression
   % $ \square\; R^{'}(x) \rightarrow \lozenge R^{''}(x) $.   Similarly, the expression $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$ in Condition 2
  %can be expressed in terms of a valid partial order $\preccurlyeq_{\mathit{st}+w} $  over $\mathit{st}$   %LTL as $ \square\;  R^{'}(x) F_{S_p} R^{''}(x)$.
    %Further, similar to the derivation of RYW,  we can rewrite the expression %$ R^{'}(x)  R^{''}(x) $ in Condition 2
    %as  $R^{'}(x) \preccurlyeq_{\mathit{st}+w} R^{''}(x)$, thus reducing the above specification  into Equation \ref{eqn:MR}.
%    Let us consider a sequence of consecutive read operations $R^i$ and $R^j$  in a given
%    session trace $\mathit{st}$, i.e., the condition ${R^i}^{'} F {R^j}^{'} \in \mathit{st}$ holds. Further,
%     consider that there exists two consecutive write operations $w^m$ and $w^n$ in the global session
%    history, i.e., the condition ${W^m}^{''} F {W^n}^{''}  \in \mathcal{S}_t$ holds. According to the definition of MR,
%     if the first read operation $r^i$ returns the
%    result of the later write $w^n$, then either of the following conditions must hold: 1) the read $r^j$ that follows $r^i$ can not return the result
%    written by an earlier read by the earlier write $w^m$, i.e., the condition $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right)$ holds, or 2) the read operation $r^j$ is directly followed by write
%    operation $w^m$, i.e., the condition $\left( {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)$ holds.
%    %The above condition can be expressed in terms of LTL
%%    by the expression $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right)$.
%    The above conditions can be combined together to the anomaly expression for MR, i.e.,
%     $C = \not\exists \big( \left( {R^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge %\left( {\mathit{st}}^{'} \in \mathcal{S}_t \right) \wedge
% \left( {W^m}^{''} F {W^n}^{''}  \in \mathcal{S}_t \right) \\ \big( %\left( {W^m}^{''} F {W^n}^{''} F {R^i}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\
% \left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\ \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)$.
 %Thus, the ConSpec specification for MR is directly derived from the definition by Chockler et al.
   %\begin{align}%\label{eqn:PL299}
%\begin{split}
%\big(\star \left( W^j(v_l)X^{o}R^k{v_m} \right) \\ \wedge \left( W^n(v_q) X^{o}R^s{v_t} \wedge ( R^k{v_m}F^{o}R^s{v_t} \right) \star \big)^\mathit{po}_{o}
%\\ \Rightarrow \big(G\; \star \left( W^n(v_q) X^{o}R^s{v_t} \right)\oplus \\ \left(W^n(v_q) F^{o} W^u(v_x) X^{o} R^s{v_t} \right) \star \big)_{o}^\mathit{st}
%\end{split}
%\end{align}.  $W^n(v_q) X^{o}R^s{v_t}$ implies that the read operation $r^s(o){v_t}$ must return the value $v_x$ written by the write operation $w^n(, ov_q)$. This, in turn, implies $v_t = v_x$.
  %Thus, the above expression can be again rewritten as \begin{align}%\label{eqn:PL299}
%\begin{split}
%\big(\star \left( w^j(v_l)X^{o}r^k{v_m} \right) \wedge \left( w^n(v_q)X^{o}r^s{v_t} \right) \star \big)^\mathit{po}_{o} \\
%\Rightarrow \big(G\; \star \left( v_q \gets \left( R^k{v_m}F^{o}R^s{v_t} \right) \right)\oplus \\ \left( v_x \gets \left( W^n(v_q) F^{o} W^u(v_x) X^{o} R^s v_t \right) \right) \star \big)_{o}^\mathit{st}
%\end{split}
%\end{align}.
% Additionally, we also consider a read operation $r^s(o){v_t}$ that reads values written by $w^n(o,v_q)$, i.e., \\ $w^n(o,v_q) X^{o} r^s(o){v_t}$. Then, without violating the above conditions, the above expression can be reduced to the ConSpec expression for MR, given as
% Hence, the above equation can be directly reduced to the equivalent ConSpec expression for MR, which is
% \begin{align}%\label{eqn:PL299}
%\begin{split}
%\forall i, j, k, l, m, n, q, r, s, t \big(\star ( W^j(v_l)X^{o}R^k{v_m} ) \\ \wedge ( W^n(v_q)X^{o}R^s{v_t} ) \wedge ( R^k{v_m}F^{o}R^s{v_t} ) \star \big)^\mathit{po}_{o} \\
%\Rightarrow \big(G\; \star %\left( v_t = v_q \right) \wedge
%  (v_t = v_q ) \oplus ( W^n(v_q) F^{o} W^u(v_x) X^{o} R^s{v_t} ) \star \big)_{o}^\mathit{st}.
%\end{split}
%\end{align}.
%$\forall i, j, o, \mathit{st} \; \big( \mathit{Op}^i X \mathit{Op}^j \in \mathit{st}
%\Rightarrow \exists S \left( \mathit{Op}^i X \mathit{Op}^j \in S \right) \\ \wedge
%\forall \mathit{st}  \left( \mathit{Op}^j X^o R_k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right) \big)$
%\par  Chockler et al. expresses WFR consistency as Equation \ref{eqn:formdef},  %as: if the condition (Condition 1)
%  %$\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ holds for a given execution sequence $\sigma_i$
%  where of a read operation
%   $\mathit{o}^1(x)$ is followed by a write operation  $\mathit{o}^2(x)$ in an execution $\sigma_i$. %, there must exist a serialization ${S_p}$, comprising the
%   %operations $\mathit{o}^1$ and $\mathit{o}^2$, for which the condition (Condition 2)
%  %$\mathit{o}^1 \xrightarrow{S_p} \mathit{o}^2$ must hold.
%   As in the case of of our derivations for sRYW and MR, the expressions $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$,
%  and $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$ for Conditions 1 and 2  can be rewritten as LTL expressions. However, since write operations have no meaning unless we have a read operation on the same object succeeding it in the session trace; this translates into the LTL expression
%   $R^{'}(x) F_\mathit{st} W^{''}(x) F_\mathit{st} R^{'}(x)$ and $R^{'}(x) F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$, respectively.  %, where a session trace $\mathit{st}$ is equivalent to $\sigma$ for the
%    %means and purposes of this paper.
% % Thus, the expressions $\left(\mathit{o}^1 \Rightarrow \mathit{o}^2\right)^\sigma$ can be rewritten as LTL formula
%%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
%   %Similarly, the expression $\mathit{o}^1 \xrightarrow{S} \mathit{o}^2$ in Condition 2
%  %can be expressed in terms of LTL as $R^{'} F W^{''} \in S_p$$.
%  Following from the reasoning of or derivations of  RYW and MR, the expression $R^{'}(x)  F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$ for Condition 2 can be rewritten in terms of ConSpec as  $R^{'}(x)  \preccurlyeq_{\mathit{st}+w} W^{''}(x) \preccurlyeq_{\mathit{st}+w} R^{'}(x)$,  thus reducing the WFR definition to Equation \ref{eqn:WFR}.
  % Further,
%   since WFR talks about a sequence comprising a read and a write operation, the propositional variable
%   $\mathit{Op}^1$ and   $\mathit{Op}^2$ in both Condition 1 and Condition 2 can safely be  replaced  by new
%   propositional variables  $R^i$ and $W^j$.
%   Further, let us consider consecutive read operations $r^k$ and $r^j$ in a  given session trace, and a write operation $w^i$
%   preceded by a write operation $w^l$.  According to WFR, under the above condition, if the earlier read $r^k$ returns the result of the later write
%   $w^i$, then  one of the following conditions must
%   hold: 1) a later read $r^j$ can not return the result of an earlier write $w^l$, i.e., $ {v^j}^{'} = {v^l}^{'}$, or
%   2) the read $r^j$ must directly succeed the write $w^l$ in the global session history, i.e., $\left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)$.
%   Further, let us consider a session trace comprising a sequence of reads $r^i$ and $r^k$ that follows a write operation $w^j$, and a write
%   operation $w^m$ precedes read $r^k$ in the global session history. If $r^i$ reads from $w^j$, $r^k$ reads from $w^m$, and
%    a read operation $r^l$ reads from $w^j$, then one of the following conditions must hold: 1) $r^l$ reads from $w^m$, i.e.,
%     ${v^l}^{''} = {v^j}^{''}$,  or 2) $w^m$ is directly succeeded by $r^l$, i.e., $ \left( {W^m}^{''} F { R^l}^{''} \in \mathcal{S}_t \right) \wedge
%   \left(  \not\exists {W^m}^{''} F {W^n}^{''} F { R^l}^{''} \in \mathcal{S}_t  \right)$. %can be also expressed as: a read operation $r^n$ must not observe
%%    a value that is written by  an earlier read $r^i$ instead of a later write operation $w^j$ in the
%%    execution sequence. %The above condition can be expressed in terms of the LTL expression
%    %$\not\exists  \mathit{st} \left( R^i F W^j F R^n \in \mathit{st} \right) \wedge \left( W^j F R^n \in \mathit{st} \right) \wedge \left( v^n = v^i \right)$.
%     Combining the above
%  conditions, we can derive the ConSpec expression for WFR $ C = \not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge \\
%%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) %\big) \\
%\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big) \wedge \\
% \not\exists \big(  \left(  {W^j}^{''}  F  {R^i}^{''} F {R^k}^{''} \in \mathcal{S}_t \right) \wedge \left(  {W^m}^{''}  F  {R^k}^{''} \in \mathcal{S}_t \right) \wedge \\
% \left( {v^j}^{''} = {v^i}^{''} \right) \wedge \left( {v^m}^{''} = {v^k}^{''} \right)  \wedge \left( {v^l}^{''} = {v^j}^{''} \right)  \big) \big( \left( {v^m}^{''} = {v^l}^{''} \right) \\
%  \vee \big( \left( {W^m}^{''} F { R^l}^{''} \in \mathcal{S}_t \right) \wedge
%   \left(  \not\exists {W^m}^{''} F {W^n}^{''} F { R^l}^{''} \in \mathcal{S}_t  \right)  \big)  \big)$
%   (refer to Equation \ref{eqn:WFR}).
%  \par Chockler et al. expresses the MW consistency model as Equation \ref{eqn:formdef}, where %: if the condition (Condition 1)   $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ holds for a given execution sequence $\sigma_i$ of
% $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ are   write operations in an execution $\sigma_i$. %, there must exist a serialization ${S_p}$, comprising the
%   %operations $\mathit{o}^1$ and $\mathit{o}^2$, for which the condition (Condition 2)
%  %$\mathit{o}^1 \xrightarrow{S} \mathit{o}^2$ must hold.
%  Following the same line of reasoning as that of our derivations for RYW, MR, and WFR, the expressions $\mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x)$,
%  and $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$  can be rewritten as LTL expressions. However, since write operations have no meaning unless we have a read operation on the same object succeeding it in the session trace; this translates into the LTL expression
%   $W^{'}(x) F_\mathit{st}  W^{''}(x) F_\mathit{st}  R^{'}(x)$ and $W^{'}(x) F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$, respectively.
%  The above precedence relationships among operations $\mathit{o}^1$ and $\mathit{o}^2$ in Condition 1 can be directly
%  expressed in terms of an LTL expression
%    $\mathit{Op}^1 F \mathit{Op}^2 \in \mathit{st}$, where a session trace $\mathit{st}$ is equivalent to $\sigma$ for the
%    means and purposes of this paper.
 % Thus, the expressions $\left(\mathit{o}^1 \Rightarrow \mathit{o}^2\right)^\sigma$ can be rewritten as LTL formula
%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
%   The expression $\mathit{o}^1 \xrightarrow{Si} \mathit{o}^2$ in Condition 2
%  can be expressed in terms of LTL as $\mathit{Op}^1 F \mathit{Op}^2 \in S_p$,  where
%  $S_p$ is equivalent to $S_p$.  Further,
%   since MW talks about a sequence of write operations, the propositional variable
%   $\mathit{Op}^1$ and   $\mathit{Op}^2$ in both Condition 1 and Condition 2 can safely be  replaced  by new
%   propositional variables  $W^{'}$ and $W^{''}$.
 %Exactly like our previous derivation, Chockler's expression for WFR and MW consistency models
 %$W^{'}(x)  F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$ for Condition 2  can be rewritten as  $W^{'}(x)  \preccurlyeq_{\mathit{st}+w} W^{''}(x) \preccurlyeq_{\mathit{st}+w} R^{'}(x)$,  thus
% can be reduced to Equations \ref{eqn:WFR} and  \ref{eqn:MW}.
%%Further, the definition of MW can be also expressed as: a read operation $r^n$ must not observe
%    a value that is written by  an earlier write $w^i$ instead of a later write operation $w^j$ in the
%    execution sequence. The above condition can be expressed in terms of the LTL expression
%    $\not\exists  \mathit{st} \left( W^i F W^j F R^n \in \mathit{st} \right) \wedge \left( v^n = v^i\right)$.
% Let us consider that there exists two consecutive write operations $w^i$ and $w^j$ in a given session
%    trace, i.e., the condition ${W^i}^{''} F {W^j}^{''}  \in \mathit{st}$ holds. A read operation $r^m$
%    cannot read the result of the earlier write operation $w^i$.
% Further, let us consider a sequence of consecutive read operations $r^k$ and $r^l$  in a given
%   global session history $\mathcal{S}_t$, i.e., the condition ${R^k}^{'} F {R^l}^{'} \in \mathcal{S}_t$ holds. According to
%   the definition of MR, if the first read operation $r^k$ returns the
%    result of the later write $w^j$, then the later read $r^l$ that follows $r^k$ can not return the result
%    written by the earlier write $w^i$, i.e., the condition $\left( {v_k}^{''} = {v_j}^{'} \right) \wedge \left( {v_l}^{''} = {v_i}^{'} \right) $
%    must hold. Further, let us consider the read operation $r^k$  reads the result of a preceding write $w^m$, and the read $r^n$ reads the
%    result of a write $w^i$, the write $w^i(x)$ precedes $w^j(y)$ in the given session trace. Then, one of the following
%    conditions must hold: 1) $r^n$ read the result of the write $w^m$, i.e., ${v_m}^{''} = {v_n}^{''}$ or 2) $r^n$ directly follows $w^m$ in the given
%    session trace, i.e., $\left( {W^m}^{'} F {R^n}^{'} \in \mathcal{S}_t \right) \wedge \\
%      \not\exists \left( {W^m}^{'} F {W^p}^{'} F {R^n}^{'} \in \mathcal{S}_t \right)$. Combining the above
%  conditions, we can derive the anomaly expression for MW $C = \not\exists {W^j}^{'} F  {R^m}^{'} \in \mathit{st} \left( {v_m}^{'} = {v_i}^{'} \right)  \wedge \left( \not\exists  {R^k}^{''} F  {R^l}^{''} \in \mathcal{S}_t \right) \\
%   \left( \left( {v_k}^{''} = {v_j}^{'} \right) \wedge \left( {v_l}^{''} = {v_i}^{'} \right) \right) \wedge \not\exists \big( \left( {W^m}(x)^{'} F {R^k}(x)^{'} \in \mathcal{S}_t  \right) \wedge \\
%     \left( {v_m}^{''} = {v_k}^{'} \right) \wedge \left(  {W^i}(x)^{'} F {R^n}(x)^{'} \in \mathcal{S}_t \right) \wedge \left( {v_i}^{'} = {v_n}^{'} \right) \wedge \\
%     \left( {W^i}(x)^{'} F  {W^j}(y)^{'} \in \mathit{st} \right) \wedge \left( {R^l}(y)^{'} F  {R^k}(x)^{'} \in \mathcal{S}_t \right) \big) \\
% \big(  \left( {v_m}^{''} = {v_n}^{''} \right) \vee
% \big( \left( {W^m}^{'} F {R^n}^{'} \in \mathcal{S}_t \right) \wedge \\
%      \not\exists \left( {W^m}^{'} F {W^p}^{'} F {R^n}^{'} \in \mathcal{S}_t \right)  \big)$
%      (refer to Equation \ref{eqn:MW}).
 %The postcondition of Chockler et al. implies that in any serialization order, a read operation $\mathit{o}^j$
% must return the values written by the latest write operations that directly precedes it, namely $\mathit{o}^i$.
% This, in turn, implies $v_l = v_m$ and
% $v_l = v_m$, respectively.
% However, subsequent write operations $\mathit{o}^p$ may alternatively overwrite the
%  values  observed/written by operation $\mathit{o}^k$ . The above conditions may be specified by the
% expressions $\mathit{Op}^j F^{o} \mathit{Op}^p X^{o} \mathit{Op}^k$. Thus, the expression for causal
% consistency can be rewritten as
%  \begin{align}
%  \begin{split}
%\forall i, j, k, l, m, n, p, q \big( \big( \left( \mathit{Op}^j = \left( W^j(v_l) \oplus R^j{v_l} \right) \right) \\
%\wedge \left(   \mathit{Op}^k = \left( W^k(v_m) \oplus R^k{v_m} \right) \right) \wedge \left( \mathit{Op}^p = W^p(v_q)  \right) \big)
% \\ \wedge \big( \left( \left( \mathit{Op}^j F^{o} \mathit{Op}^k \right) \oplus \left( \mathit{Op}^j X^{o} \mathit{Op}^k \right) \right)  \\
% \vee \big( \left( \left( \mathit{Op}^j F^{o} \mathit{Op}^n \right) \oplus \left( \mathit{Op}^j X^{o} \mathit{Op}^n \right) \right)  \\
%\wedge \left( \left( \mathit{Op}^n F^{o} \mathit{Op}^k \right) \oplus \left( \mathit{Op}^n X^{o} \mathit{Op}^j \right) \right) \big) \big) \big)_{o}^\mathit{po} \\
%\Rightarrow \big(G\;  \left( v_l = v_m \right) \oplus \left( \mathit{Op}^j F^{o} \mathit{Op}^p X^{o} \mathit{Op}^k \right) \big)_{o}^\mathit{st}.
%\end{split}
% \end{align}
%$\forall i, j, k, l, o, \mathit{st}_x, \mathit{st}_y \big( W^i F W^j \in \mathit{st}_x, \mathit{st}_y
%\\ \Rightarrow  \exists S \left( W^i F W^j \in S \right) \wedge
%\\ \wedge \not\exists R^m  \left( W^i F W^j F R^m \in \mathit{st}_x, \mathit{st}_y \right) \\
%\wedge \big( \left( \left( v^m = v^i \in \mathit{st}_x  \right) \wedge \left( v^m = v^j \in \mathit{st}_y
%\right) \right) \\
% \vee \left( \left( v^m = v^j \in \mathit{st}_x  \right) \wedge \left( v^m = v^i \in \mathit{st}_y \right)
% \right) \big) \big)
%$
%\par In their definition of Causal consistency, Chockler uses the notion of a
%\emph{direct precedence relation} between operations $\mathit{o}(x)$
% and $\mathit{o}^{'}(x) $ in an execution order $\sigma_i$, denoted as $\xRightarrow{\sigma_i}$. The expression $\mathit{o}(x) \xRightarrow{\sigma_i} \mathit{o}^{'}(x) $
 % implies that either of the following properties must hold: Property 1) $\mathit{o}^{'}(x) $ is a read operation which returns the values written by a write operation $\mathit{o}(x)$, or Property 2)  %a precedence relationship
%exists between $\mathit{o}$  and $\mathit{o}^{'} $  in the execution order $\sigma_i$ , i.e.,
% the precedence relation
%$\mathit{o}(x) \xrightarrow{\sigma_i} \mathit{o}^{'}(x) $  holds for a given execution $\sigma_i$. Causal consistency is expressed as Equation \ref{eqn:formdef}. Condition 1 specifies that a transitive closure  $\xRightarrow{\star}$ exists
 % over a direct precedence relation $\mathit{o}(x) \xRightarrow{\sigma_i} \mathit{o}^{'}(x)$ among a given pair of operations $\mathit{o}(x)$  and $\mathit{o}^{'}(x) $ in $\sigma_i$. %, i.e.,  must exist the precondition holds (i.e., if either Condition 1 or Condition 2 holds) for a given pair of operations $\mathit{o}$  and $\mathit{o}^{'} $ in every client in the system (i.e., for every process $p_i$),
  %then $\mathit{o}$  and $\mathit{o}^{'} $ must satisfy the precedence relation $\mathit{o} \rightarrow \mathit{o}^{'}$ in an equivalent legal serialzation $S_p$ of a partial execution $\sigma |i + w$ comprising $\mathit{o}$  and $\mathit{o}^{'} $, i.e., the condition $\mathit{o} \xrightarrow{S_p}\mathit{o}^{'} $ must hold. % for each client in the system.
 %Condition 2 in Equation \ref{eqn:formdef} can be expressed in terms of LTL as  $\forall \mathit{st}.  \left(  \square\;  \mathit{Op}^{'}(x) \ \mathit{Op}^{''}(x) \right)$.  %The condition ${\mathit{Op}}^{'}  F_{S_p} {\mathit{Op}}^{''} $ denotes a partial order among ${\mathit{Op}}^{'} $ and ${\mathit{Op}}^{''} $ with respect to each client. Hence,
 % Following the same line of reasoning as that  used in our derivation for RYW, Condition 2 can be restated as: there must exist a partial order $\preccurlyeq$ which respects the order specified among the operations performed by each client, i.e., with respect to each observed session trace $\mathit{st}$, hence, with respect to the global session trace $\mathcal{S}_t$. Thus, Condition 2 reduces to the form ${\mathit{O}}^{'}(x)  \preccurlyeq {\mathit{O}}^{''}(x)  $, where $\preccurlyeq$ is a partial order with respect to operations in the global session trace.
%  As in previous cases, the expression $\mathit{o}(x) \xRightarrow{\sigma_i} \mathit{o}^{'}(x)$ in Condition 1 %by further Inspection, Condition 1 in the precondition
 % can be expressed in the
 %form $ \square\;  {\mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x)$. %, since the special-purpose operator $F_\mathit{st}$ can be used to express the temporal relation among operations  quantified by the precedence operator $\xrightarrow{\sigma_i}$.
% However, Condition 2 implies that read operation $\mathit{o}(x){v}^{'}$, corresponding to the propositional variable ${\mathit{O}}(x)^{'} $, reads the value
% written by the write $\mathit{o}(x,v)^{''}$, corresponding to the propositional variable  ${\mathit{O}}^{''}(x)$. Thus, the precondition, comprising a logical disjunction over Condition 1 and 2, can be expressed as %$ \left( {\mathit{Op}}^{'} = {W}^{'} \right) \wedge \left( {\mathit{Op}}^{''} = {R}^{''} \right) \wedge
  % \left( v = v^{'} \right)$.
  %$  \square\;  {\mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x) \vee
% \left( \left( {\mathit{O}}^{'}(x) = {W}^{'}(x) \right) \wedge \left( {\mathit{O}}^{''}(x) = {R}^{''}(x) \right) \wedge
%   \left( v_i = v_j \right) \right)$, where $ {R}^{''}(x)$ and $ {W}^{'}(x)$ are shortcut notations for   $\mathit{o}(x){v}^{'}$ and $\mathit{o}(x,v)^{''}$, respectively. For a given $\mathcal{S}_t$ to satisfy causal consistency,  a transitive closure
%must exist over the above condition. %, i.e.,
%the condition $ {\mathit{Op}}^{'} F {\mathit{Op}}^{''} \vee
% \left( \left( {\mathit{Op}}^{'} = {W}^{'} \right) \wedge \left( {\mathit{Op}}^{''} = {R}^{''} \right) \wedge
 %  \left( v_i = v_j \right) \right)$ must hold.
 % However, it directly follows from the Condition 1 in Definition \ref{def:form0} that if Condition 2 holds, i.e., if a valid $\preccurlyeq$ comprising $\mathit{o}(x)$  and $\mathit{o}^{'}(x) $ exists,  every operation in $ \preccurlyeq$ must reflect a result which is equivalent to that of executing the prior operations in $ \preccurlyeq$ according to a linear sequence. Hence, ${ \square\;  \mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x)$ implies that the transitivity condition holds over the expression $ \square\;  {\mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x)$  in Condition 1. Hence, the precondition for Causality can simply be expressed as $ \square\;  {\mathit{O}}^{'}(x)  \rightarrow \lozenge  {\mathit{O}}^{''}(x)$. %, without any additional condition for imposing the transitivity constraint. % The precondition specifies that operations $\mathit{o}^j$  and $\mathit{o}^k$ are comprised in the execution
%order $\sigma$.  The second precondition which claims
% closure under transitivity of direct precedence relations, we can specify that if $\mathit{o}^i$ directly precedes
% $\mathit{o}^k$, and $\mathit{o}^k$ directly precedes $\mathit{o}^j$, $\mathit{o}^i$ directly precedes
% $\mathit{o}^j$.
%Assuming the transitive closure property specified by the second precondition, the direct precedence
% relation among operations $\mathit{o}^i$ and $\mathit{Op}^j$ can be expressed in terms of LTL as : $\big(\big(  \mathit{Op}^i F \mathit{Op}^j \vee \\
% \exists \mathit{Op}^k \in  \mathit{st} \left( \mathit{Op}^i F \mathit{Op}^k  \wedge
%\mathit{Op}^k F \mathit{Op}^j \right) \big) \\ \vee \big( \left( \mathit{Op}^i = W^i \right) \wedge
%\left( \mathit{Op}^j = R^j \right) \wedge \\ \left( \left( v_i = v_j \right) \vee \exists \mathit{Op}^k \in  \mathit{st}
%\left( \left( v_i = v_k \right)
% \wedge \left( v_k = v_j \right) \right) \big) \right) \big)$.
% The above expression matches the LHS of Equation \ref{eqn:Causal}.
% Thus, Chockler's definition of Causal Consistency reduces into the specification given in Equation \ref{eqn:Causal}.
% Additionally, the definition of  Causal consistency requires that the operation $\mathit{o}^j$ must not
% read the result of an earlier write operations $w^m$  instead of $\mathit{o}^i$ such that either of the following
%  conditions are satisfied. The first condition specifies that $r^j$ returns the result of $w^m$, i.e., the condition
%   ${v^j}^{'} = {v^m}^{''}$ holds. The second condition specifies that $r^j$ follows the write $w^m$, such that
%   the condition $\left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
%\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right)$ holds. %The above condition can be expressed as
%%  $\not\exists  \mathit{st} \left( W^m F \mathit{Op}^i F \mathit{Op}^j \in \mathit{st} \right)
%%\wedge \left( v^j = v^m \right)$.
%  We can combine the above expressions to form Equation \ref{eqn:Causal}, thus reducing it to the form of the anomaly condition, i.e.,
%  $C = \not\exists \big( %\left( \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%   \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
%   \left( {W^m}^{''} \in \mathcal{S}_t \right) \\
%   \wedge \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \big)
%\big( \left( {W^m}^{''} F {\mathit{Op}^i}^{'}  \in \mathcal{S}_t \right) \wedge
%\big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \\
% \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
%\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big) \big) \big)$
%\par Causal+ consistency is defined by Lloyd et al. in prosaic form \cite{Lloyd:2011:DSE:2043556.2043593}. We formalise their definitions in terms of ConSpec  as follows. Valid partial orders $\preccurlyeq_{\mathit{st}+w}$ and  $\preccurlyeq_{\mathit{st}+w}$ comprising operations from
%sessions $\mathit{st}$ and$ \mathit{st}^{'}$ must preserve the precedence order among pairs of  writes $w(x)$ and $ ws^{'} (x)$ on a common data object $x$.  We express the above definition in terms of LTL as follow.
% $E^S_C = \forall \mathit{st}, \mathit{st}^{'}, \in \mathcal{S}_t, {\mathit{Op}}^{'}, {\mathit{Op}}^{''}, W^{'}(x),  W^{''} (x) \in \mathit{st} \big(  {\mathit{Op}}^{'} F _ \mathit{st} {\mathit{Op}}^{''}
% \Rightarrow {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{'} (x) \Rightarrow W^{'}(x) \preccurlyeq_{{st}^{'}+w} W^{''} (x)  \big),
% $ where $ \preccurlyeq_{\mathit{st}+w}$ is a partial order  restricted to  the elements of sessions $\mathit{st}$ and $\mathit{st}^{'}$ plus writes from other clients.  $ \preccurlyeq_{\mathit{st}+w}$ and $\preccurlyeq_{{st}^{'}+w}$ denote  partial orders  over operations on a given object $x$ restricted to  the elements of sessions $\mathit{st}$ and $\mathit{st}^{'}$ plus writes from other clients, respectively.
% The above equation can be rewritten as $E^S_C = \forall \mathit{st}, \mathit{st}^{'}, \in \mathcal{S}_t, {\mathit{Op}}^{'}, {\mathit{Op}}^{''}, W^{'}(x),  W^{''} (x) \in \mathit{st} \big(  {\mathit{Op}}^{'} F _ \mathit{st} {\mathit{Op}}^{''}
% \Rightarrow {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \preccurlyeq_{\mathit{st}+w}  W^{''} (x) \wedge W^{'} (x) \preccurlyeq_{{st}^{'}+w} W^{''}(x)  \big)$.  let ${\mathcal{W}_{St}}$ denotes the set comprising write operations  present in all session traces in $\mathcal{S}_t$.
% Next, the partial order relations  ${\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''} $, $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (x)   \right)$, and $ \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{'} (x)  \right)$ can be expressed in terms of the corresponding partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, $\left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, and $\left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. By that reasoning, the condition $ {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \preccurlyeq_{st+w} W^{''} (x) \wedge W^{'} (x) \preccurlyeq_{{st}^{'}+w} W^{''}(x)$ can be expressed in terms of an intersection $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'}_{st+w} \right)$ of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, $\left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$,  and $\left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$, where $ \preccurlyeq^{'}_{\mathit{st}+w} $ denotes the partial order relation  among elements of the new partial order set formed out of the intersection of $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, $\left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, and $\left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. Thus, Causal+ can be rewritten into the form of Equation \ref{eqn:CausalC}.

% Additionally, consider that a read operations $r^j$ follows a write operation $w^i$ in a given session
% trace. Consider a read operation $r_k$ follows $r^j$ in the global session history. Strict serializability
% requires that the later read $r^k$ can not read the result of the write $w^i$ if the earlier read $r^j$ did not observe it,
% i.e., the condition $\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
% \left( {R^j}^{''} F {R^k}^{''} \in \mathcal{S}_t \right) \big)
% \big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big)$ must hold.
% Further, consider that a read operation $r^l$ follows the above sequence of write and reads in the global session history,
% i.e., $ \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge
%  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right)$. In that case,
%  among the reads following $w^j$ the later read $r^l$ can not observe the result of $w^j$ if the earlier read $r^k$ did not
%   observed it, i.e., \\ $\not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \\
%  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \big)
% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$.
%  %must always observe the result
%% of the latest operation preceding $r_k$. This condition can be expressed in terms of LTL as
%% $\forall \mathit{st}  \left( \mathit{Op}^j X^o R^k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right)$
%  Combining the above
%  conditions, we can derive the anomaly expression for strict serializability, i.e., $C = \not\exists \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \\
%   \wedge \left( {R^j}^{''} F {R^k}^{''} \in \mathcal{S}_t \right) \big)
% \big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge \\
% \not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \\
%  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \big)
% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$ %\wedge
%% \not\exists \big( \left( {\mathit{Op}}^{'} F {W^j}^{'} F {R^k}^{'} \in \mathit{st} \right) \wedge \\
%% \left( {W^i}^{'} F {W^j}^{'} F {R^k}^{''} F {R^l}^{l'} \in \mathcal{S}_t \right) \big)
%% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{'} \not= {v^i}^{'} \right) \big)$
% (refer to Equation \ref{eqn:Strict}).
%
 %\par %Goodman\textquotesingle s Processor consistency (PC) specifies that result of a preceding operation invoked from a given client must be observed in all processors (they refer to a client or a session as processor) before result of a
 %succeeding operation can be observed in any processor.  In other words, the order in which any pair of  writes, invoked from a particular client, are observed in session traces of all other clients must always respect the invocation order of the above operations. Reads against  write operations should
  %view the results of the writes
  %according to the invocation order of these writes in a client application.
   %Following the same approach as before,
   %Again, the ConSpec specification for Processor consistency (PC)  can be directly derived from the definition of Goodman\textquotesingle s PC provided by Ahamad et al. \cite{Ahamad:1993:PPC:165231.165264}.
 %PC talks about preserving the order of operations executed by individual processors (or client applications).
 %According to the above definition, there must exist a valid legal serialization for a partial execution  $\sigma |i + w$ of
 %comprising operations performed by
 %a processor $p_i$;  we denote  $\sigma |i + w$  as $S_p$.  The given execution of $p_i$ satisfies PC if and only if $S_p$ satisfies Condition 1 and 2.  Consider any pair of write operations $w(x,v)$ and $w^{'}(y,v^{'})$ invoked by  processor $p_i$. The Precedence order of $w(x,v)$ and $w^{'}(y,v^{'})$  in $S_p$ must echo the invocation order of $w(x,v)$ and $w^{'}(y,v^{'})$.  Ahamad et al. expresses Condition 1 as:
% $\mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x)$ implies $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$. Condition 2 states:  valid legal serializations of any given execution must order all write operations on a given object according to an identical precedence order. %In this paper, we refer to a processor  $p_i$ as a client $\mathit{Cl}_i$, and the session trace comprising the results observed by  $\mathit{Cl}_i$ is denoted as $\mathit{st}$. Hence, in our case, Condition 1 implies that the order among $w(x,v)$ and $ w^{'}(y,v^{'})$ invoked by in any valid legal serialization $S_p$ comprising operations performed by a  client $\mathit{Cl}_i$ must match the precedence order of $w(x,v)$ and  $w^{'}(y,v^{'})$ in a session trace $\mathit{st}$ observed by $\mathit{Cl}_i$.
  %Following the same line of reasoning as in the previous derivations, we can express Condition 1 as follows.
  %Using propositional variables  $W^{'}(x) $, and $W^{''} (y) $ to denote the events of execution of write operations $w(x,v)$ and  $w^{'}(y,v^{'})$ by processor $p_i$,
%  As before, Condition 1 can be expressed as $ \square\; W^{'}(x) F_\mathit{st}  W^{''} (y) \Rightarrow  \square\;  W^{'}(x) F_\mathit{S_p}  W^{''} (y) $.
  %Further, as explained in previous derivations, we can express a valid legal serialization $S_p$ for a processor $p_i$ in terms of a partial order $\preccurlyeq_{\mathit{st}+w}$. Thus, the above expression reduces to $ \square\; W^{'}(x) F_\mathit{st}  W^{''} (y) \Rightarrow W^{'}(x) \preccurlyeq_{\mathit{st}+w}  W^{''} (y) $.  % comprising all operations in a session trace $\mathit{st}$ for $p_i$ (referred to as a client $\mathit{Cl}_i$ in this paper) plus writes from all other processors (resp. clients).
  %Imposing the restrictions of Condition 2 on a the above expression,  precedence relation $F_\mathit{st}$ among $w(x,v)$ and $w^{'}(y,v^{'})$ must be preserved in equivalent legal serializations for all processors in the system.
  %Since $ \preccurlyeq$ %and $ \preccurlyeq_{{st}^{'}+w}$
  %denotes a partial order over all operations in a global session trace $\mathcal{S}_t$, % observed for  a global execution comprising all processors executing in the system.  Then,
  %Condition 2 can be restated as: there must exists a partial order $\preccurlyeq$ for a given $\mathcal{S}_t$, such that $W^{'}(x) \preccurlyeq  W^{''} (y)$ holds for all pairs of writes performed by any clients. Applying Condition 2, the expression for Condition 1 can be reduced to the form $ \forall \mathit{st} \in \mathit{S_t}: W_\mathit{st}^x \preccurlyeq_{\mathit{st}+w} W'^{x}_\mathit{st}  $.
%  Further, Condition 2 implies that the effect of successive writes must be observed in an identical precedence order in valid legal serializations for all processors in the system. This, in turn, implies that the precedence order among successive reads by a process $p_i$ must be preserved in valid legal serializations for all processors. In other words, a partial order $\preccurlyeq$  for a given $\mathcal{S}_t$ must apply a pair of read operations $r(x){v}$ and $r(x){v}^{'}$ according to their mutual precedence order in the session trace $\mathit{st}$, i.e.,   $ \square\;  R'(x) \operatorname{\it F}_\mathit{st} R''(y)  \Rightarrow  R'(x) \preccurlyeq R''(y)$.
  %The above expressions can be combined into the ConSpec specification given by Equation \ref{eqn:PC}. %It follows trivially from the definition of a session that the precedence order among $w(x,v)$ and  $w^{'}(y,v^{'})$ in a session trace $\mathit{st}$ observed by a client $\mathit{Cl}_i$ is equivalent to the invocation order of  $w(x,v)$ and  $w^{'}(y,v^{'})$ in $\mathit{Cl}_i$. In that light, the invocation order of a pair of writes  $w(x,v)$ and  $w^{'}(y,v^{'})$ invoked from a client $\mathit{Cl}_i$ can be expressed, in terms of LTL, as $W^{'}(x) F_\mathit{st}  W^{''} (y) $.
% We denote $ \preccurlyeq$ %and $ \preccurlyeq_{{st}^{'}+w}$
 % as a partial order comprising all operations in a global session trace $\mathcal{S}_t$. % performed by clients $\mathit{Cl}_i$ and $\mathit{Cl}^{'}_i$ and writes from all other clients, respectively.
  %Then, according to  Condition 1 and Condition 2, the precedence order among $w(x,v)$ and  $w^{'}(y,v^{'})$ in the partial order  $\preccurlyeq$ %and $ \preccurlyeq_{{st}^{'}+w}$
  %must match the precedence order  $W^{'}(x) F_\mathit{st}  W^{''} (y) $.  %\\
%E^S_C = C =   \forall \mathit{st} \in \mathcal{S}_t \not\exists \big( \left(  {W^i}^{'}, {W^j}^{'} \in \mathit{st}  \right)
%\wedge \left( {R^k}^{'}, {R^l}^{'} \in \mathcal{S}_t \right) \big) \\
%\big( \left( {W^i}^{'} F {W^j}^{'} \in \mathit{st} \right) \wedge
%   \left( {R^k}^{'} F {R^l}^{'} \in \mathcal{S}_t \right) \wedge
%  \left( v_k^{''} = v_j^{'} \right)  \wedge \\
%  \left( v_l^{'} = v_i^{'} \right) \big) \wedge
%  \not\exists \left( {W^i}^{'}, {R^j}^{'}, {R^k}^{'}, {W^l}^{'}  \in \mathit{st}  \right)
%  \big( \left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \\ \wedge
%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) \wedge
% \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge
% \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)
%E^S_C = \left( {\mathcal{O}_{St}}, \preccurlyeq \right),
%$\forall x, y, \mathit{st} \in \mathcal{S}_t  \left( {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (y) \in \mathit{st} \right)  \Rightarrow \left( {\mathit{Op}}^{'}(x) \preccurlyeq {\mathit{Op}}^{''} (y) \right),$  where $ \preccurlyeq$ is a partial order over operations across all data objects with respect to a given global session trace $ \mathcal{S}_t$.
%Thus, PC can be expressed as $ \forall \mathit{st} \in \mathcal{S}_t, \; R'(x), R''(y), W'(x), W''(y) \in \mathit{st}:  W'(x) \operatorname{\it F}_\mathit{st} W''(y)  \Rightarrow  W'(x) \preccurlyeq W''(y)  \wedge R'(x) \operatorname{\it F}_\mathit{st} R''(y)  \Rightarrow  R'(x) \preccurlyeq R''(y))$.
%%The partial order relations $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right)$ and $ \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right)$ can be expressed in terms of the corresponding partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. By that reasoning, the condition $ \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right) \wedge  \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right) $ can be expressed in terms of an intersection $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right)$ of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$, where $ \preccurlyeq^{'} $ denotes the partial order relation  among elements of the new partial order set formed out of the intersection of $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
%  Thus, the definitions of Ahmad et al. directly reduces to the expression given in Equation \ref{eqn:PC}.
 %  \par Chockler et al. states Sequential Consistency as: the precedence order among operations  in a valid legal serialization for a given global execution must match the precedence order of the operations in the local execution of each process, i.e.,  $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2 \Rightarrow \mathit{o}^1 \xrightarrow{S} \mathit{o}^2$, where $S$ in an equivalent legal serialization for the global session execution $\sigma$.  Following the same approach as in previous derivation, %the order  of execution among operations in an execution sequence $\sigma$,
 %can be given  in terms of a series of LTL expression that express the precedence of successive operations in the sequence.
 % the precedence relation $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ in the LHS of the above expression can be restated as
 %  $ \square\;  \mathit{O}^{'} \rightarrow \lozenge  \mathit{O}^{''}$.  %Thus, the above condition can be expressed as: any two operations in an execution
  % sequence must execute in an order that matches the precedence relation among these operations in a legal
  % serialization of the above execution sequence. In other words, any two operations must occur in a session trace in an
   %order that matches the precedence relation of these operations in a legal serialization of those operations.  Hence, this condition can be expressed in terms of LTL as
  % $\mathit{Op}^{'} F \mathit{Op}^{''} \in \mathit{st}
  %SC requires that an equivalent legal serialization must exist comprising operations performed by all clients in the system which matches the precedence among the operations $\mathit{o}$ and $\mathit{o}^{'}$.  We denote such a legal serialization as $S_c$, the subscript $c$ denotes that the serialization corresponds to a global execution restricted to operations from a given client. %(refer to the definition of $S_c$ in Equation \ref{def:clientser}).
  % Similarly, the RHS can be expressed as $ \exists S \left(  \square\;  \mathit{Op}^{'}(x) F_{S} \mathit{Op}^{''}(x) \right)$. %, where $S_c$ denotes an equivalent legal serialization of a global execution restricted to operations from the given client (refer to the definition of $S_c$ in Equation \ref{def:clientser}).
  %As in our previous derivations, the above RHS can be rewritten as ${\mathit{O}}^{'}(x)  \preccurlyeq {\mathit{O}}^{''}(x)$, where $ \preccurlyeq$ is a partial order comprising all operations in $\mathcal{S}_t$. Thus, $ \preccurlyeq$ comprises all operations in the global execution $\sigma$.
  %Hence, the condition % $ \square\;  {\mathit{Op}}^{'}(x)  F_{S} {\mathit{Op}}^{''}(x) $
%   in the RHS implies a total order $\prec$ among each pair of operations $\mathit{o}^1 $ and $\mathit{o}^2$ comprised in $\mathcal{S}_t$. Thus, we can replace the partial order symbol $\preccurlyeq$ with $\prec$. This does not cause any loss of information since a total order is a special case of a partial order, i.e., ${\mathit{O}}^{'}(x)  \prec {\mathit{O}}^{''}(x)$  implies $\left( {\mathit{O}}^{'}(x) \preccurlyeq {\mathit{O}}^{''}(x) \right) \vee \left( {\mathit{O}}^{''}(x)  \preccurlyeq {\mathit{O}}^{'}(x)\right)$. Hence, we can rewrite the above RHS as  ${\mathit{O}}^{'}(x)  \prec {\mathit{O}}^{''}(x) $.
  %Thus, Chockler's definition of SC reduces into the specification given in Equation \ref{eqn:SC}.
% >   Thus, Chockler's definition of SC reduces into the specification given in Equation \ref{eqn:SC}.
%
% ^.
%\par Total Store Order (TSO) originally specified by Owens et al. \cite{Owens:2009:BXM:1616077.1616107}, where it was intended to serve as  a memory model for the existing x86 multiprocessor architecture. The axiomatic form of the TSO definition by Owens et al. is based on notations and mechanisms that are very specific to the internal protocol of the x86 architecture. Hence, instead of deriving our definitions directly from the axiomatic model, we first extract the substance of the model and interpret it in terms of a prose, using generalised notations, as follows. A read operation performed by a given client on a given data object can not return the result of write on the same object by a different client unless the former write has been observed by all clients.
%The above condition implies that partial orders for any session trace $\mathit{st}$ and $\mathit{st}^{'}$ must preserve the precedence among writes $ w(x,v)$  and $w^{'''}(x,v^{'''}$ to a  common data object $x$ with resect to succeeding reads.
%Consider an execution sequence comprising $w(x,v)$ followed by a read $r^{'}(x,v^{'})$, observed in a local session trace $\mathit{st}^{'}$. In another session trace $\mathit{st}^{'}$), a read operation $r^{''}(x)$  is  followed by a write $w^{'''}(x,v^{'''})$.
%According to TSO, in a valid global session trace $\mathcal{S}_t$, the read $r^{'}(x,v^{'})$ can not return the value written by $w^{'''}(x,v^{'''})$ before $r^{''}(x)$ returns the result of $w(x,v)$.  For such an $\mathcal{S}_t$  there must exist a valid legal serialization, comprising operations from each client,  where $w(x,v)$ occurs before $w^{'''}(x,v^{'''})$., i.e., there must exist a valid legal serializations for each session trace that orders $w(x,v)$ occurs before $w^{'''}(x,v^{'''})$.  In other words, a valid legal seriallizaton for partial execution of each client (i.e., for each session trace corresponding to the respective clients) must apply writes to each data object in the same precedence order.  Using the same approach that used in the prior derivations, the above condition of a valid legal serialization can be restated in terms of valid partial orders, i.e.,  there must exist valid partial orders $\preccurlyeq_{{st}^{'}}$ and $\preccurlyeq_{{st}}$ over operations comprised in the session traces $\mathit{st}$ and $\mathit{st}^{'}$ that order writes to each data object according to an identical  precedence order.
%  Thus, TSO is expressed as follows.
% $E^S_C = \forall x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, w(x,v), r^{'}(x,v^{'}), r^{''}(x), w^{'''}(x,v^{'''}) \in {\mathcal{O}_{St}}  \big( \left( W^{'}(x) F_\mathit{st}  R^{''} (x) \right)  \wedge  \left( \mathit{R}^{'''}(x) F_\mathit{st}^{'} W^{''''} (x) \right)  \wedge \left( v^{''} = v \right) \wedge \left( v^{'''} = v^{'} \right)  \big) \Rightarrow   \big( \left( W^{'}(x) \preccurlyeq_{st} W^{'''} (x) \right) \wedge \left( W^{'}(x) \preccurlyeq_{{st}^{'}} W^{'''} (x) \right)  \big) \big).$
%  TSO can be expressed in terms of an intersection of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{st} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}} \right)$, where $\preccurlyeq^{'}$  denotes a partial order among elements  of the intersection-set comprising an intersection of the partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{st} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}} \right)$. %In any two executions of a sequence of operations by two processors (or client applications), a pair of writes on a common system object $x$ must be executed in the same precedence order.  %serializations ${S_p}_i$ and ${S_p}_j$, the write operations on common storage system objects in ${S_p}_i$ and
%% ${S_p}_j$ must be executed in the same order, i.e., ${S_p}_i|w$ = ${S_p}_j|w$.
% Thus,  the above expression for TSO can be reduced to the ConSpec form $E^S_C = \forall x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, w(x,v), r^{'}(x,v^{'}), r^{''}(x), w^{'''}(x,v^{'''}) \in {\mathcal{O}_{St}}  \big( \left( W^{'}(x) F\mathit{st} R^{''} (x) \right)  \wedge  \left( \mathit{R}^{'''}(x) F_\mathit{st}^{'} W^{''''} (x)  \right)  \wedge \left( v^{''} = v \right) \wedge \left( v^{'''} = v^{'} \right)  \big) \Rightarrow   \big( \left( W^{'}(x) \preccurlyeq_{st} W^{'''} (x) \right) \wedge \left( W^{'}(x) \preccurlyeq_{{st}^{'}} W^{'''} (x) \right)  \big).
%$.
%
%%, i.e., there must exist a common serialization comprising all operations executed from the
%% client applications which contains the above writes executed in a particular order. This condition can be expressed in terms of LTL as
%% $W^i F W^j \in \mathit{st}_x, \mathit{st}_y \Rightarrow  \exists S \left( W^i F W^j \in S \right)$.
%% Let us consider a given sequence of operations $w^i$ and $r^j$ in any given session trace, whee $r^j$ does not return
%%  the result of $w^i$. Further, consider a read operation $r^k$ that executes between  $w^i$ and $r^j$ in the
%%  global session history. If the read $r^k$ also does not return the result of $w^i$, there can not exceed a write operation
%%  $w^l$ that precedes the write $w^i$, such that one of the following conditions hold: 1) $r^i$ returns the result of $w^l$,
%%  i.e., ${v^j}^{'} = {v^l}^{'}$, or 2) $r^i$ directly follows $w^l$, i.e., $\left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge
%% \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)$.
%% that must not observe the sequence
%% of writes executing in  a different order in  two different session traces $\mathit{st}_x$ and $\mathit{st}_y$.% The above
%%  condition can be expressed as
%% $\not\exists R^m  \left( W^i F W^j F R^m \in \mathit{st}_x, \mathit{st}_y \right) \\
%%\wedge \big( \left( \left( v^m = v^i \in \mathit{st}_x  \right) \wedge \left( v^m = v^j \in \mathit{st}_y
%%\right) \right) \\
%% \vee \left( \left( v^m = v^j \in \mathit{st}_x  \right) \wedge \left( v^m = v^i \in \mathit{st}_y \right)
%% \right) \big) $.
%% The above conditions can be combined to form the condition of TSO $C = \forall \mathit{st}, \mathcal{S}_t \; \big( \not\exists \big( \left({W^i}(x)^{'} \in \mathit{st} \right) \wedge
%% \left({R^j}(x)^{''} \in \mathit{st}^{'} \right) \wedge \\
%%  \left( {W^i}^{'}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right) \wedge \left( {v_j}^{''} \not= {v_i}^{'} \right) \big) \\
%%  \big( \not\exists \big( \left({R^k}(x)^{'} \in \mathit{st}^{'} \right) \wedge \left( {R^k}^{''}(x) F {R^j}^{''}(x) \in \mathcal{S}_t  \right)   \big)  \\
%%  \left( {v_k}^{''} \not= {v_i}^{'} \right) \big) \wedge
%% \not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%%\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%%%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) \\ %\big) \\
%%\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee
%%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\
%% \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)$.
%% The existential quantification over each of the LTL and first order logic expressions comprised in the above expression for $E^S_C$ can be rewritten as partial orders over the global session trace $\mathcal{S}_t$.
%%The above expression can be rewritten as follows.
%% $E^S_C = \forall \mathit{st}, \mathcal{S}_t \; \big( \not\exists \big( \left({W^i}(x)^{'} \in \mathit{st} \right) \wedge
%% \left({R^j}(x)^{''} \in \mathit{st}^{'} \right) \wedge \\
%%  \left( {W^i}^{'}(x) \preccurlyeq^{'}(x) {R^j}^{''}(x)  \right) \wedge \left( {R^j}^{''}(x) \preccurlyeq^{''}(x) {W^i}^{'}(x) \right) \big) \\
%%  \big( \not\exists \big( \left({R^k}(x)^{'} \in \mathit{st}^{'} \right) \wedge \left( {R^k}^{''}(x)  \preccurlyeq^{'''}(x) {R^j}^{''}(x) \right)   \big)  \\
%%  \left( {R^k}(x)^{'} \preccurlyeq^{''''}(x) {W^i}^{'}(x) \right) \big) \wedge
%% \not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%%\left( {R^k}^{'} \preccurlyeq^{''''}(x) {R^j}^{'} \right) \wedge \\
%%%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%%\left( {W^l}^{'} \preccurlyeq^{''''}(x) {W^i}^{'} \in \mathcal{S}_t \right)  %\big) \\
%%\big( \left(   {R^k}^{'} \preccurlyeq^{''''}(x) {W^i}^{'}  \right) \\ \wedge \big( \left( {W^i}^{'}  \preccurlyeq^{'''''}(x)  {W^l}^{'} \right) \vee
%%\big( \left( {W^l}^{'} \preccurlyeq^{'''''}(x) {R^j}^{'} \right) \wedge \\
%% \left( \not\exists {W^l}^{'} \preccurlyeq^{'''''}(x) {W^m}^{'} \preccurlyeq^{''''''}(x) {R^j}^{'} \right) \big) \big) \big),$
%% where each of the temporal and first order logic operators in the above expression are replaced by equivalent partial orders $\preccurlyeq^{'}(x), \preccurlyeq^{''}(x)...$  over $\mathcal{S}_t$, defined with respect to a given object $x$. The above expression can be further rewritten as $E^S_C = \left( \mathcal{S}_t, \preccurlyeq^{'}(x) \right) R ... R^{'} \left( \mathcal{S}_t, \preccurlyeq^{''}(x)\right), $ where $R, R^{'}, ... $ are binary relations, like $\vee,
%% \wedge, $ etc., composing the above partial order orders.  This expression can again be rewritten as
%%where $ \mathit{Si} $ is an equivalent legal serialization for a global execution comprising all clients executing in the system, defined in Equation \ref{def:ser}. The above expression can be trivially rewritten as Equation \ref{eqn:TSO}. % further rewritten in terms of a partial order $ \preccurlyeq$ over a given object $x$ as $E^S_C = \forall x, \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \not\exists \mathit{o}(x), \mathit{o}^{'}(x), \mathit{o}^{''}(x), \mathit{o}^{'''}(x) \in {\mathcal{O}_{St}}  \big( \left( \mathit{Op}^{'}(x) F \mathit{Op}^{''} (x) \in \mathit{st} \right)  \vee \big(  \left( \mathit{Op}^{'}(x) F \mathit{Op}^{'''} (x) \in \mathit{st} \right)  \wedge \\
%% \left( \mathit{Op}^{''}(x) F \mathit{Op}^{''''} (x) \in \mathit{st}^{'} \right)  \wedge \left( v^{''} = v \right) \wedge \left( v^{'} = v^{'''} \right)  \big) \big) \Rightarrow   \left( \mathit{Op}^{'}(x) \preccurlyeq \mathit{Op}^{''} (x) \right),$
%  % where $ \preccurlyeq$ is a partial order over a given object $x$ with respect to a given global session trace $ \mathcal{S}_t$.
%  %Thus, the ConSpec expression for TSO is derived as follows.
%%   Any
%%  two write operations with read operations following them must occur in the same order for all executions,
%%  irrespective of the store where they are executed. Consider that there exists two write operations
%%  $w^j(o,v_l)$ and $w^n(o,v_q)$, with two corresponding read operations $r^k(o){v_m}$ and $r^s(o){v_t}$, such
%%  that  conditions $w^j(o,v_l)X^{o}r^k(o){v_m}$ and $w^n(o,v_q)X^{o}r^s(o){v_t}$ hold.
%% Following the same line of reasoning as that used in the case of Causal consistency, the following condition
%%  must hold:
%%  \\ $\forall i, j, o, \mathit{st}, S \; \big( \mathit{Op}^i X W^j \in \mathit{st}
%%\Rightarrow \\ \forall S \left( \mathit{Op}^i X W^j \in S \right)
%%\wedge \not\exists R^k  \left( \mathit{Op}^i X^o W^j X^o R^k \in \mathit{st} \right) \\ \wedge \left( v^k = v^i  \right) \big)
%%$.
% %Also, the ConSpec expression for strict
%% serializability follows directly from its definition.
%%It states that  any serialization of a sequence of operations
%%  executed by a processor must observe an identical order of execution among operations. This, in turn, is expressed using Equation
% %\ref{eqn:Strict}.
%  %The specification for Write Follows Read consistency (see Equation \ref{eqn:WFR}) is also derived using similar line of reasoning.
%\subsection{Serialization Definitions}\label{sec:ser}
% A \emph{serialization} is a linear sequence comprising all operations comprising a global  execution on a
%   storage system. Here, we demonstrate how various flavours of serialization used in the original definitions of Chockler et al.  \cite{Chockler2000} can be expressed in terms of the ConSpec language.
%A serialization is said to be \emph{legal} if every read operation returns the value written by the latest write
%    operation preceding it in the serialization.  Following Chockler et al., ConSpec defines
%  consistency levels in terms of valid legal serialization orders equivalent to a given execution. Similar to Chockler et al., ConSpec defines different consistency models in terms of different specialized forms of legal serialization, which have been defined below. ConSpec defines those consistency models, which can not be expressed in terms of legal serialization, in terms of constraints on the global execution order,  represented by the global session trace $\mathcal{S}_t$.
%    Let the propositional variable ${\mathit{Op}^i}^{'}$ denote an execution of the
%    i\textquotesingle th operation comprised in the set $mathcal{O}$ of operations executed from a given client application in a session trace.
%    \begin{definition}(Legal Serialization)
%    We represent a global execution, comprising concurrent operations executed from multiple clients on a system, with a global session trace $\mathcal{S}_t$, which is a set of operations from all clients. A legal serialization $\mathit{Ser}$ of a given global execution is represented by a sequence of propositional variables ${\mathit{Op}^i}^{'}$, each variable ${\mathit{Op}^i}$ denoting an execution of an
%  operation ${\mathit{o}}^i$, comprised in the set of operations ${\mathcal{O}_{St}}$ executed by a given client, observed a global session trace $\mathcal{S}_t$, as follows.
%    $\mathit{Ser}$ = $\Set{ {\mathit{Op}^i}^{'} } {{\mathit{Op}^i}^{'} \in \mathit{st}}, $ such that
%    $\forall {\mathit{o}^i}^{'}, {\mathit{o}^j}^{'} \in {\mathcal{O}_{St}} \\ \big( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'}  \wedge \exists \mathit{st} \in \mathcal{S}_t  \; \big( \big( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st}  \; \wedge \\
%   \not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \in \mathcal{S}_t  \right) \big)
%   \Rightarrow \left( {v_j}^{'} = {v_i}^{'} \right) \big) \big)$.
%    \end{definition}\label{def:ser}
% \begin{definition}(Serialization of a Client)
%    We  represent a local execution of a given client observed at a client machine, with a local session trace $\mathit{st} $, comprising results observed for operations executed by a given client application, comprised in the set of operations ${\mathcal{O}_{St}}$.  We formally define \emph{serialization of a client}, $S_c$, as the restriction of a legal serialization of a global execution
%    to  the operations invoked by a particular client application, which in turn,
%    corresponds to operations observed in a particular session trace $\mathit{st}$.
%     $S_c$ = $ \Set{ {\mathit{o}^i}^{'}, {\mathit{o}^j}^{'} \in {\mathcal{O}_{St}} \wedge {\mathit{Op}^i}^{'} } {{\mathit{Op}^i}^{'} \in \mathit{Ser} \wedge {\mathit{Op}^i}^{'} \in \mathit{st} } $.
%    \end{definition}\label{def:clientser}
%   \begin{definition}(Serialization of a Partial Execution)
%   The notation $S_p$ is used to denote a legal serialization of a partial execution comprising all    operations from the set of operations ${\mathcal{O}_{St}}$
%    performed by a given client application, represented by a local session trace $\mathit{st}$, and all write
%  operations  executed from all other concurrent client applications, comprised in the global session trace $\mathcal{S}_t$. The above partial execution is denoted as $\sigma |i + w$ by Chockler et al. Thus, we formally denote $S_p$ as
%    \\ $S_p$ = $\Set{ {\mathit{Op}^i}^{'} } { \left( {\mathit{Op}^i}^{'} \in \mathit{st} \right) \vee \left(
%   {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^i}^{'} \not\in \mathit{st} \right)}, $ such that
%   $\forall {\mathit{o}^i}^{'}, {\mathit{o}^j}^{'} \in {\mathcal{O}_{St}} \big( {\mathit{Op}^i}^{'} = {W^i}^{'} \wedge {\mathit{Op}^j}^{'} = {R^j}^{'}  \wedge \\ \exists \mathit{st} \in \mathcal{S}_t  \; \big( \big( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st}  \; \wedge \not\exists {\mathit{Op}^k}^{'} = {W^k}^{'} \\ \left( {\mathit{Op}^i}^{'}  F {\mathit{Op}^k}^{'} F {\mathit{Op}^j}^{'} \in \mathcal{S}_t  \right) \big)
%   \Rightarrow \left( {v_j}^{'} = {v_i}^{'} \right) \big) \big)$.
%   \end{definition}\label{def:parser}
%   The above legal serialization does not comprise read operations from other clients, hence its a  serialization of a partial execution.
%
%    \subsection{Equivalence between Dependency Relations and LTL Relations of ConSpec} \label{sec:equiv}
% State-of-the-art definitions specify consistency levels in terms of dependency relations, namely
%  $w \xrightarrow{wr} r$,  $w \xrightarrow{ww} w^{'}$, and  $w \xrightarrow{wr} r$ dependency, respectively
%  \cite{Hennessy:2011:CAF:1999263}.  The $w \xrightarrow{wr} r$ dependency can be translated to the form
%  $\exists \big( %\left(  \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%  \left( W^{'} \in \mathit{st} \right)
%  \wedge \left(  R^{''} \in \mathcal{S}_t \right) \big)  \left( v  = {v}^{'} \right)$, where we represent the write and read operations $w$ and $r$
%  involved in the  dependency relation with the propositional variable $W^{'}$ and $R^{''}$, respectively. Denoting
%  $w$, and $w^{'}$ with propositional variables $W^{'}$ and $W^{''}$, the
%  dependency relation $w \xrightarrow{ww} w^{'}$ is translated into ConSpec form as follows.
%  \begin{align}\label{eqn:ww}
%\begin{split}
%   \exists \big( %\left( \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%   \left( {W}^{'} \in \mathit{st} \right)
%   \wedge \left( {W}^{''}  \in  \mathcal{S}_t \right)  \big)
%   \big( %\wedge
% % \left( {W^i}^{'} \in \mathit{st} \right)
%  \exists %\big(  %\left( \mathit{st}^{''} \in \mathcal{S}_t \right) \wedge
%  \left( { R}^{''''} \in \mathcal{S}_t \right) %\big)
%  %\exists \left( \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \right)  %{W^i}^{'}  F { R^k}^{''} \in \mathit{st}^{''}  \wedge \\
%  %\wedge {R^l}^{'''} F { R^k}^{'''} \in \mathit{st}^{''} \wedge
%   \left( {v}^{'''} = {v}^{'} \right)
%   \wedge \big( \left(  {v}^{'''} = v \right) \vee
%  \big( \left( {W^i}^{''} F { R^l}^{''} \in \mathcal{S}_t \right) \wedge \\
%   \left(  \not\exists {W}^{'} F {W}^{'''''} F { R}^{''''} \in \mathcal{S}_t \right)  \big) \big) \big) %\left( \not\exists {W^j}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{st}^{'} \; \wedge \; {v_l}^{'} = {v_j}^{'}
%%  \right) \\
%%  \vee \left( \exists {W^j}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{st}^{'} \right) \left({v_l}^{'} = {v_m}^{'}  \right) \big) % \\
%  %\not\exists {W^i}^{'} F {W^n}^{'} F { R^l}^{'} \in \mathit{st}  \big)
%   %\big( \left( {v_k}^{'} = {v_j}^{'}  \right) \vee \\
%   %\exists \left( \mathit{st}^{'''} \in \mathcal{S}_t \wedge {W^j}^{''''} F {W^m}^{''''} F { R^k}^{''''}  \in \mathit{st}^{'''} \right)
%   %\left( {v_k}^{'} = {v_m}^{'}  \right) \big).
%   \end{split}
%   \end{align}
%   Similarly, denoting  $r$, and $w$ with propositional variables $R^{'}$ and $W^{''}$, the
%   $r \xrightarrow{rw} w$ dependency is translated into ConSpec form as follows.
%     \begin{align}\label{eqn:rw}
%\begin{split}
%\exists \big( %\left( \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''}  \in \mathcal{S}_t \right)  \wedge
%\left( {R}^{'} \in \mathit{st} \right)
%   \wedge \left( {W}^{''}  \in  \mathcal{S}_t \right) \wedge
%   \left( \exists  {W}^{'''} \in \mathit{st}  \right)
%   \left( v = {v}^{''} \right) \wedge
%  \left( \exists {R}^{''''} \in \mathcal{S}_t  \right) \left( {v}^{'''} = {v}^{'} \right)  \big)
% \big( \left( {v}^{''} = {v}^{'''} \right) \vee \\
%  \big(  \left( {W}^{'''} F { R}^{''''} \in \mathcal{S}_t \right) \wedge
%    \left(  \not\exists {W}^{'''} F {W}^{'''''} F { R}^{''''} \in \mathcal{S}_t  \right) \big) \big)
%   %\left( {W^j}^{''} F { R^l}^{''} \in \mathit{st}^{'} \right) \wedge
%% \left( \not\exists {W^m}^{'} F {R^i}^{'} \in \mathit{st}^{''} \right) \left( {v_l}^{'} = {v_m}^{'} \right) \big)
% % \big( {v_l}^{'} = {v_j}^{'}
%  %\; \vee \left( \exists {W^j}^{''} F {W^n}^{'} \in \mathit{st}^{'} \right) \\
%  %\left( {v_j}^{'} = {v_n}^{'} \right) \big).
%  \end{split}
%  \end{align}
%   \par Adya et al. define isolation  levels in terms of $w \xrightarrow{wr} r$,
%   $w \xrightarrow{ww} w^{'}$, and  $w \xrightarrow{wr} r$  dependencies among transactions
%   \cite{DBLP:conf/icde/AdyaLO00}. The $wr$ dependency relation of the dependency graph can be translated into
%   ConSpec form $\exists \big( %\left(  \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%   \left( W^{'}_\mathit{tx} \in \mathit{st} \right)
%  \wedge \left(  R^{''}_\mathit{ty} \in \mathcal{S}_t \right) \big) \left( v = {v}^{'} \right) $. The $ww$ dependency relation
%    between transactions $\mathit{tx}$ and $\mathit{ty}$ can be translated to \begin{align}\label{eqn:ww}
%\begin{split}
% \exists \big( %\left( \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
% \left( {W}^{''}_\mathit{tx} \in \mathit{st} \right)
%   \wedge \left( {W}^{''}_\mathit{tx}  \in  \mathcal{S}_t \right)  \big)
%   \big( %\wedge
% % \left( {W^i}^{'} \in \mathit{st} \right)
%  \exists %\big( % \left( \mathit{st}^{''} \in \mathcal{S}_t \right) \wedge
%  \left( { R}^{''''}\mathit{ty} \in \mathcal{S}_t \right) %\big)
%  %\exists \left( \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \right)  %{W^i}^{'}  F { R^k}^{''} \in \mathit{st}^{''}  \wedge \\
%  %\wedge {R^l}^{'''} F { R^k}^{'''} \in \mathit{st}^{''} \wedge
%    \left( {v}^{'''} = {v}^{'} \right)
%   \wedge
%   \big( \left(  {v}^{'''} = v \right) \vee
%  \big( \left( {W}^{''} F { R}^{''''}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%   \big( \left(  \not\exists {W}^{'}_\mathit{tx} F {W}^{'''''}_\mathit{tx} F { R}^{''''}_\mathit{ty} \in \mathcal{S}_t \right)
%  \wedge  \left(  \not\exists {W}^{'}_\mathit{tx} F {W}^{'''''}_\mathit{ty} F { R}^{''''}_\mathit{ty} \in \mathcal{S}_t \right) \big) \big) \big) \big)
%  %\left( \not\exists {W^j}^{''} F {W^m}^{''} F { R^l}^{''} \in \mathit{st}^{'} \; \wedge \; {v_l}^{'} = {v_j}^{'}
%  % \exists \big( \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''} \in \mathcal{S}_t \wedge
%%  {W^i}^{'}_\mathit{tx} F { R^l}^{'}_\mathit{tx} \in \mathit{st}
%%  \wedge {W^j}^{''}_\mathit{ty} F { R^k}^{''}_\mathit{ty} \in \mathit{st}^{'} \\
%%  \wedge {R^l}^{'''}_\mathit{tx} F { R^k}^{'''}_\mathit{ty} \in \mathit{st}^{''} \wedge
%%  \not\exists {W^j}^{''}_\mathit{ty} F {W^m}^{''}_\mathit{ty} F { R^k}^{''}_\mathit{ty} \in \mathit{st}^{'} \wedge \\
%%  \not\exists {W^i}^{'}_\mathit{tx} F {W^n}^{'}_\mathit{tx} F { R^l}^{'}_\mathit{tx} \in \mathit{st}  \big)
%%   \big( \left( {v_k}^{'} = {v_j}^{'}  \right) \vee \\
%%   \exists \left( \mathit{st}^{'''} \in \mathcal{S}_t \wedge {W^j}^{''''}_\mathit{ty} F {W^m}^{''''}_\mathit{ty} F { R^k}^{''''}_\mathit{tx}  \in \mathit{st}^{'''} \right)
%%   \left( {v_k}^c{'} = {v_m}^{'}  \right) \big).
%   \end{split}
%   \end{align}
% The $rw$ dependency relation between transactions $\mathit{tx}$ and $\mathit{ty}$ can be translated into ConSpec form
%  \begin{align}\label{eqn:rw}
%\begin{split}
%\exists \big( %\left( \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''}  \in \mathcal{S}_t \right)  \wedge
%\left( {R}^{'}_\mathit{tx} \in \mathit{st} \right)
%   \wedge \left( {W}^{''}_\mathit{ty}  \in  \mathcal{S}_t \right) \wedge
%   \left( \exists  {W}^{'''}_\mathit{tx} \in \mathit{st}  \right)
%   \left( v = {v}^{''} \right)  \wedge
%  \left( \exists {R}^{''''}_\mathit{ty} \in \mathcal{S}_t  \right) \left( {v}^{'''} = {v}^{'} \right)  \big)
%  \big( \left( {v}^{''} = {v}^{'''} \right)  \\
%   \vee  \big(  \left( {W}^{'''}_\mathit{tx} F { R}^{''''}_\mathit{ty} \in \mathit{st}^{''} \right)  \wedge
%    \big( \left(  \not\exists {W}^{'''}_\mathit{tx} F {W}^{'''''}_\mathit{tx} F { R}^{''''}_\mathit{ty} \in \mathcal{S}_t \right)  \wedge
%   \left(  \not\exists {W}^{'''}_\mathit{tx} F {W}^{'''''}_\mathit{ty} F { R}^{''''}_\mathit{ty} \in \mathcal{S}_t \right) \big) \big)
%%\left( \exists \mathit{st}, \mathit{st}^{'}, \mathit{st}^{''}  \in \mathcal{S}_t \right) \big(
%%  \left( {R^i}^{'}_\mathit{tx} F {W^j}^{''}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%   \left( {W^j}^{''}_\mathit{ty} F { R^l}^{''}_\mathit{ty} \in \mathit{st}^{'} \right) \wedge
%% \left( \not\exists {W^m}^{'}_\mathit{tx} F {R^i}^{'}_\mathit{tx} \in \mathit{st}^{''} \right) \left( {v_l}^{'} = {v_m}^{'} \right) \big).
%%\exists \big( \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t \wedge
%%  {W^k}^{'}_\mathit{tx} F { R^i}^{'}_\mathit{tx} \in \mathit{st} \wedge {W^j}^{''}_\mathit{ty} F { R^l}^{''}_\mathit{ty} \in \mathit{st}^{'} \wedge \\
%%  \not\exists {W^k}^{'}_\mathit{tx} F {R^l}^{'}_\mathit{ty} F { R^i}^{'}_\mathit{tx} \in \mathit{st} \big) \big( {v_l}^{'} = {v_j}^{'}
%%  \; \vee \left( \exists {W^j}^{''}_\mathit{ty} F {W^m}^{'}_\mathit{ty} \in \mathit{st}^{'} \right) \\
%%  \left( {v_j}^{'} = {v_m}^{'} \right) \big).
%  \end{split}
%  \end{align}
%
%\subsection{A Hierarchy of ConSpec Specifications }\label{sec:hierarchy}
%Definitions of consistency models are specified using ConSpec in the form of LTL properties. Hence, ConSpec specifications can be classified using the same basic principles by which LTL properties are categorised \cite{Manna:1990:HTP:93385.93442}. There are four broad categories of  LTL properties: safety, guarantee, recurrence, and persistence. Consider that $\phi$ is a given LTL property, which may be a conjunction or disjunction of multiple LTL properties. A safety property is expressed in a generic format $\forall \phi$, whereas a guarantee property is expressed as $\exists \phi$; recurrence and persistence properties are expressed as $R \phi$ and $P \phi,$ respectively.  The specification $\mathcal{E}^{s} $  for each of the consistency models RYW, MR, Causal, WFR, and MW can be expressed in the form $\forall p \Rightarrow \exists q, $ which can be rewritten as $\forall F p \Rightarrow F q.$ This form of LTL specification is called the conditional guarantee form of LTL property. The specifications for the TSO and PC consistency models can be expressed in the form  $\forall p_1 \circ  p_2 \circ^{'}  ... \circ^{''}  p_k, $  where $\circ, \circ^{'}, ... , \circ^{''}$ are conjunction or disjunction operators of first order logic over LTL constraints $p_1, p_2, .... , p_k$. The above expression can be transformed into the form $\forall p,$ which is called the safety form of LTL property.  Thus, the ConSpec specifications can be broadly classified as conditional guarantee and safety properties.
% \par Now, let us further analyze the consistency models belonging to the conditional guarantee form. The specifications $\mathcal{E}^{s} $ of RYW, MR, Causal, WFR, and MW can be expressed in the form  $\mathcal{E}^{s} = A \Rightarrow B$ (refer to Definition \ref{def:form0}), where the precondition $A$ is specified as $A$ =$ {\mathit{Op}}^{'} F {\mathit{Op}}^{''} \in \mathit{st} $ .  The precondition $A$  in the specification $\mathcal{E}^{s} $ for Causal consistency  (refer to Equation \ref{eqn:Causal}) imposes an LTL constraint  on any  pair of operations $ {\mathit{o}}$ and  ${\mathit{o}^{'}}$  comprised in a given session trace.  Since the above operations $ {\mathit{o}}$ and  ${\mathit{o}^{'}}$ can be both read and write operations, precondition $A$ for Causal consistency is more restrictive than others. Thus, in turn, the set of session traces that satisfies the precondition $A$ for Causal consistency is smaller in size than the set that satisfies RYW, MR, WFR, and MW.  However, the postcondition $B$ for RYW, MR, Causal WFR, MW uniformly defines an existential quantification on the serialization of a partial execution for a given client.  The strength (degree of the strength) of a consistency model can be quantified by the size of the set of session traces that consistency model; smaller size  implies more restrictive condition, which, in turn, implies stronger the consistency model. Hence, Causal consistency is stronger than the rest of the above consistency models, namely RYW, MR, Causal WFR, and MW.  The precondition $A$ for RYW (refer to Equation \ref{eqn:RYW}) comprises an LTL constraint ${W}^{'} F {R}^{''}$ on successive write and read operations ${w}$ and ${r}^{'}$.  On the other hand, WFR (refer to Equation \ref{eqn:WFR}) comprises an LTL constraint ${R}^{'} F {W}^{''}$ on successive read and write operations ${r}$ and ${w}^{'}$. However the writes ${w}^{'}$ have no meaning in the observed session traces, unless viewed in company of a succeeding read  ${r}^{''}$.  Thus, the precondition $A$ for WFR can be expressed as ${W}^{'} F {R}^{''} F {R}^{'''}$, making it more restrictive; thus the set of traces which satisfy WFR is smaller than that of RYW and MR. Hence, WFR is stronger than the precondition $A = {R}^{'} F {R}^{''}$ for MR, as well as the precondition $A = {W}^{'} F {R}^{''}$. Similarly, the precondition $A$ =  ${W}^{'} F {W}^{''}$  for MW can be expressed as   $A$ =  ${W}^{'} F {W}^{''} F {R}^{'''} $, making it also stronger than RYW and MR.  Strict serializability model, on the other hand, specifies the precondition $A$ as an LTL constraint on any pair of operations; particularly,  it specifies $A$ as  $A$ =  ${\mathit{Op}}^{'} X {\mathit{Op}}^{''}$. The LTL operator next $X$ implies that the set of session traces satisfies the above precondition is even smaller than the set that satisfies Causal consistency. Hence Strict Serializability is stronger than the rest of the consistency models of the conditional guarantee form.

% \subsection{Comparison of ConSpec Tool With the State-of-the-art}\label{sec:compare}
% Here, we compare our approach of analyzing session traces against ConSpec specification with the traditional approach of analyzing server traces \cite{DBLP:conf/icde/AdyaLO00, Chockler2000, Terry:1994:SGW:645792.668302, Burckhardt:2014:PEC:2693641.2693642}. %Let us start by assuming that both approaches use a single expression to represent a given consistency model or isolation level. Let us also assume that session traces used in our approach, and server traces used in traditional approaches, are equivalent in the context of complexity analysis.  Under the above assumptions, complexity of trace analysis with our approach can be potentially worse than the server trace analysis approach if anomaly exists in a given trace. This can be attributed to the fact that, with the server trace analysis approach, the analysis terminates as soon as an anomaly is found in any portion of a given execution trace.  Contrastingly, with our approach, the analysis may continue till the very end of the trace, since it checks if all portions of the trace conforms to the ConSpec specifications. Thus a trace analysis may terminate earlier with the server trace analysis approach. However, we fix the problem by modifying our approach to indirectly detect anomalies (see later part of this Section), thus enabling it to terminate early, similar to the server trace analysis approach.
%%\par On the other hand, in absence of anomalies in a given execution, i.e., in both the session trace and the server trace for the execution, the complexity of our approach matches the server trace analysis approach; since, in this case, the analysis with both approaches terminate at the very end of the trace. We further reduce the search space of session trace for session trace analysis, by considering only the session traces comprising operations performed on a concerned object.
% In the current state-of-the-art, a consistency model or isolation level is typically represented by two components: 1) axiomatic rules, given by a group of first order logic expressions, representing the allowed execution order among operations, and 2)  DSGs representing the anomalies proscribed by the given consistency model or isolation level. On the other hand, our approach uses only a single LTL-like expression to express the same consistency model or isolation level. Thus, the server trace analysis approach compares each element in an  execution trace with two components. Contrastingly, with our approach, each element in a session trace is compared with only a single ConSpec expression. Hence, the complexity of the server trace analysis approach (refer to Section \ref{sec:complex}) is roughly twice the complexity with our approach, particularly in the case of absence of anomaly in a given trace. In the presence of anomalies in a session trace, the comparison between complexities of the two approaches is more complicated; we need to consider the position of the first occurrence of an anomaly with respect to the size of the trace.
%\par Moreover, the traditional approach of server trace analysis involves analysis of execution traces collected from server nodes comprising the storage system cluster. It analyzes whether the results of operations observed at the system end, i.e., at the end of the storage system, matches the results expected as per a given consistency model or isolation level. Thus, this approach considers a system-centric view of a given consistency model or isolation level. On the other hand, we analyze whether a session trace, observed from a client application, satisfies the specification for a given consistency model or isolation level, i.e., whether the results in the session trace follow an order that is allowed by the above specification. Hence, our approach is concerned with client-centric view of a given consistency model or isolation level. Further, the traditional approach has the disadvantage of having to deal with much longer traces, comprising execution of operations performed from multiple applications or sessions on storage system servers. Extracting a session trace from a server trace is a computationally expensive task by itself, since it requires an exhaustive search on the server trace to identify portions that are relevant to a given application. Contrastingly, our approach directly analyzes session traces, collected from the client machines.
%%\subsection{Complexity of Verification: Comparison with the State-of-the-art}\label{sec:complex}
%% %A session trace is comprised of results of execution of storage operations invoked from a client application on a target storage system, observed from a client machine.
%%% Let $\mathit{o}$ be signature of an
%%%$i^\mathit{th}$ operation invoked from a given client application. $\mathit{o}$ can be a read or write operation that reads (or writes) a unique value from (or to) a storage system object $o$; signature of a read and write operation are of the form $r(o){v_m}$ and $w(o,v_l)$, respectively.
%%% Let $v_k$ be the current value observed against the operation $\mathit{o}$ on an object $o$. Let the length of the given session trace be denoted by the integer term $s_t$. A a session trace $\mathcal{S}_t$ can be expressed as a collection of tuples, where each tuple comprises: 1) the unique signature of the operation, 2) the name of the storage system object that the operation accesses, 3) the value written by the operation. Using the above notations, a session trace $\mathcal{S}_t$ is given as $\mathcal{S}_t$ = \[ \Set{\tuple{\mathit{o},o,v_k}} {1\le i \le s_t, 1\le j\le m, 1\le k\le n}{.} \]
%%%Let the ConSpec expression for a given consistency
%%% guarantee or an isolation level be given as $\mathcal{E}_c$ =\[ \Set{e_i} {1\le i\le s_c}{,} \] where
%%% $e_i$ is the $i^\mathit{th}$ character in the ConSpec expression, and the length of a given ConSpec expression is $s_c$.
%% %$\tuple{\mathit{o}_i,o_j,v_k}$
%%It can be verified whether a storage system actually supports a consistency guarantee or an isolation level by analyzing a session trace with respect to a ConSpec specification $\mathcal{E}^s$ for the above consistency guarantee or isolation level. Verifying a given session trace $\mathcal{s}_t$ against a specification $\mathcal{E}^s$  involves comparing the observed result of each operation in
%%  $\mathcal{s}_t$ against each expression in $\mathcal{E}^s$. The complexity (here we consider time complexity) of comparing each character in a session trace $\mathcal{s}_t$ against the specification $\mathcal{E}^s$ is equivalent to the length of the specification, i.e., $s_c$. For verification, the above step is repeated for all characters in the session trace (in the absence of anomalies). Thus, the total complexity  of verifying a session trace against a given ConSpec specification is $s_t \times s_c$.
%%\par  As already discussed in Section \ref{sec:compare}, state-of-the-art definitions of consistency models and isolation levels comprise a combination of axiomatic rules and anomaly DSGs. Let the total number of axiomatic rules in a state-of-the-art consistency specification  be $n_e$. Let the length of the expression for each axiomatic rule comprising a state-of-the-art specification  be $s_1$, $s_2$, ..., $s_{n_e}$, respectively. Thus, the total length of such expressions in a state-of-the-art specification
%% is given as $\mathcal{E}^s$ =\[ \Set{\mathcal{E}^{i}_s}{1\le i\le n_e}{,}{,}\] where $\mathcal{E}^{i}_s$ is the $i^\mathit{th}$
%% expression in the given specification. The process of verifying a given session trace against a specification involves comparing each expression in the given specification with each character in the session trace. The complexity (time complexity) of comparing the expression $\mathcal{E}^{i}_s$ against the session trace can be given as $s_t \times S_p$, where $S_p$ is the length of $\mathcal{E}^{i}_s$. The total complexity of verifying the given session trace against the above expressions comprising the given specification involves carrying out the above step for all expressions in the specification, which in turn, can be given as $s_t \times \left(s_1+s_2+...+s_{n_e}\right)$. Now, let us consider verifying the given session trace against the anomaly DSGs for the given specification. Let the number of anomaly DSGs for a given specification be $n_g$. Let the size of each anomaly DSG be $g_1$, $g_2$, ...., $g_{n_g}$. Verifying a given session trace against an anomaly DSG involves performing
%% a pattern search in each of the DGSs with the session trace. The complexity $\mathcal{C}$ of the above search, using any algorithm based on Depth First Search,  can be given as $\mathcal{C}$ = $V+E$, where $V$ and $E$ are the number of vertices and edges in each DSG,
%% respectively. Considering each DSG to be fully connected, the number of edges approximately equals the number of vertices
%%  -1, i.e., $E \approx V - 1$. Hence, $\mathcal{C}$ can be further rewritten as $\mathcal{C}=V+E\approx 2V -1$. Thus, the complexity of a graph search algorithm can be given $\approx 2V -1$. The total complexity
%%  of verifying he given session trace against anomaly DSGs involves performing the above pattern search for all anomaly DSGs comprising the given specification. Thus, the total complexity of verifying against anomaly DSGs can be given as
%%  $s_t \times 2 \times \left( g_1 + g_2 ... + g_{n_g} \right) - n_g$.  Combining the complexity of verifying against the expressions and the complexity of verifying against the anomaly DSGs, the total complexity of verification
%%   as per the state-of-the-art can be given as
%%   $s_t \times \left( s_1+s_2+...+s_{n_e} + 2 \times g_1 + 2 \times g_2 ... + 2 \times g_{n_g} - n_g \right).$
%
 \begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{ANU_3384}}]{Subhajit Sidhanta}
 Subhajit Sidhanta received his PhD in Computer Science from Louisiana State University, USA, in 2016. He spent one and a half year as a Postdoctoral Researcher with the Distributed Systems Research Group at INESC-ID research lab, affiliated with Instituto Superior Tecnico at University of Lisbon, Portugal, and then joined the Indian Institute of Technology Jodhpur in 2018 as an Assistant Professor in Computer Science and Engineering. His major research interest encompasses the areas of consistency in distributed systems, performance modelling of distributed storage and parallel computing systems.
 \end{IEEEbiography}

 \newcommand{\ut}[1]{\underaccent{\tilde}{#1}}
 \renewcommand{\vec}[1]{\ut{#1}}
 \begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{avatar}}]{Ricardo Dias}
 Ricardo Dias is a senior software enginner, at SUSE Linux, in the Entreprise Storage Team, where his main task is to contribute to the upstream Ceph storage system project. He is also an Associate Researcher at the NOVA LINCS laboratory. He received his doctoral degree from the Universidade Nova de Lisboa, Portugal, in 2013, under the supervision of Prof. Jo$\tilde{a}$o Louren$\vec{c}$o, on the topic of transactional memory. He spent a couple of years as a postdoc researcher, working with Prof. Rodrigo Rodrigues on the topic of geo-replicated storage systems, first at the NOVAsys group of the NOVA LINCS laboratory, and then at the GSD group of the INESC-ID laboratory.
 He has received a Distinguished Paper Award at the Euro-Par 2012 and the Best paper Award at the HVC 2012.
 \end{IEEEbiography}
 \begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{ist14022}}]{Rodrigo Rodrigues}
 Rodrigo Rodrigues is a full professor at the Instituto Superior Tecnico of the ULisboa and a researcher at INESC-ID since 2015. Previously, he was a faculty at the Nova University of Lisbon and the Max Planck Institute for Software Systems (MPI-SWS), where he led the Dependable Systems Group. He received his PhD degree from the Massachusetts Institute of Technology (MIT) in 2005, under the supervision of Prof. Barbara Liskov. He has won several fellowships and awards, including a best paper award at the Symposium on Operating Systems Principles, the flagship conference in computer systems, a special recognition award from MIT's Department of Electrical Engineering and Computer Science, and an ERC starting grant. In the last few years, he and his doctoral students have published their work in the top conferences of a broad range of areas, including OSDI, VLDB, NSDI, EuroSys, WWW, FAST, PODC, USENIX Security, and ASPLOS.
 \end{IEEEbiography}
%\section{Appendix}\label{sec:appendix}
% \subsection{Deriving ConSpec Specifications From Original Definitions}\label{sec:derive}
% %Here we show how the ConSpec specifications can be directly derived from state-of-the-art specifications of
% %consistency \cite{Chockler2000, Terry:1994:SGW:645792.668302}.
% %As already discussed,
% %state-of-the-art consistency specifications  \cite{Chockler2000, Terry:1994:SGW:645792.668302} define axiomatic rules for consistency models using first order
% %ogic expressions.
%   In this section, % and in Section \ref{sec:restderive},
%  we illustrate that %equivalence between of each  consistency model \cite{Chockler2000, Ahamad:1993:PPC:165231.165264, Owens:2009:BXM:1616077.1616107} and the corresponding
%  the ConSpec specifications of  consistency models  and original definitions \cite{Chockler2000, Ahamad:1993:PPC:165231.165264, Owens:2009:BXM:1616077.1616107} are equivalent.  RYW, MR, WFR, MW, Causal and Sequential consistency have been defined by Chockler et al. \cite{Chockler2000}, whereas PC have been defined in \cite{Ahamad:1993:PPC:165231.165264, Owens:2009:BXM:1616077.1616107}.
%   %We show that it is possible to formally derive ConSpec specifications from the original  definitions.
%   We begin by describing the  notations used in the original consistency definitions given by Chockler et al., and how they can be translated to %map to
%  the syntax of ConSpec.  According to Chockler et al., a system comprises a group of processes that communicate with each other by invoking read or write operations on a group of objects.
%  % an operation is an  instance of an execution of a read or write instruction performed by a process  on a storage system.
%  Chockler et al. denote   a pair of  read or write operations on an object $x$, invoked from %a session $\mathit{st}$ of
% the $i^{th}$  process $ p_i$ in the system, as $\mathit{o}^1(x)$ and
% $\mathit{o}^2(x)$, respectively. % , such that $\mathit{o}^1$ is a write operation that updates
% %an object $o$ in the system, and $\mathit{o}^2$ is a read operation that reads $o$.
% %In this paper, we refer to a process as a client,
%We use the notation $\mathit{Cl}_i$ for the $i^{th}$ client in the system. The process $ p_i$ is an execution thread instantiated by the client $\mathit{Cl}_i$. %(similar to Chockler et al.),
%% without any loss of information.
%  The
%  notation $\sigma_i$ is used by Chockler et al. to denote a local execution composed of a sequence of read and write operations  performed by  a client $\mathit{Cl}_i$. %(or a process $p_i$ as per Chockler et al.\textquotesingle s terminology),
% Each operation is comprised of an invocation event and a response event, such that % there is a correspondence among the invocations and responses for each operation, i.e.,
%  the response for each operation follows its corresponding invocation. The notation $\sigma$ denotes a global execution comprising all such local executions performed by all clients in the system. Chockler et al. use the symbol $\rightarrow$ to denote a   \emph{precedence} relationship \cite{Bailis:2013:BCC:2463676.2465279} between two operations, such that an expression $\mathit{o}^1(x) \rightarrow \mathit{o}^2(x)$ implies that an invocation of an operation $\mathit{o}^1(x)$ precedes an invocation of $\mathit{o}^2(x)$ in a given execution.  $\xrightarrow{\sigma_i}$ is a specialised form of the precedence operator, where the superscript $\sigma_i$ is used to restrict the precedence relationship $\rightarrow$ to operations comprised in the  particular execution  $\sigma_i$.  According to the above system model, %each operation comprises an invocation event and a response event, and
%  an invocation event of an operation can not occur unless the response event of a preceding operation comprised in the same session (i.e., invoked by the same client) has occurred in an execution. Hence, the expression $\mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x)$
%  implies that both the invocation and response for operation $\mathit{o}^1(x)$ precede (i.e., happen before) the invocation and response of operation $\mathit{o}^2(x)$ in an execution sequence $\sigma_i$.  %The consistency definitions by
%%  Chockler et al. specify the allowed order of operations with respect to a \emph{serialization}, which is
%%   a linear sequence of operations formed with the operations  in a given execution sequence.
%  %By definition of the system model, unless both the invocation and response for an operation finishes the following operation can not execute.
%   %We define a session trace $\mathit{st}$ as a sequence of operations performed by  a client $\mathit{Cl}_i$, ordered according to    invocation time of operations.
%    %For means and
%   %purposes of this paper, an execution sequence $\sigma_i$ of Chockler et al.  is
%   %equivalent to a session trace $\mathit{st}$ in ConSpec.
%   %Hence, without any loss of information,  we replace each reference to $\sigma_i$ in the  the definitions of Chockler et al.  with the notation  $\mathit{st}$.  %, replacing the precedence  operator $\Rightarrow$ with the
%% equivalent special-purpose LTL operator $F_\mathit{st}$ that denotes ``eventually" relations among with respect to the session $\mathit{st}$ (defined in Section \ref{sec:definitions}), i.e.,  it is equivalent to $\mathit{o}^1 F_\mathit{st} \mathit{o}^2 \in \mathit{st}$.
%%An execution sequence $\sigma_i$ of Chockler et al.  is
%   %equivalent to a session trace $\mathit{st}$ in ConSpec.
%    Additionally, Chockler et al. extend the notation $\sigma_i$ to define a special-purpose notation $\sigma |i + w$ denoting a partial
%    execution, where $i + w$ implies the restriction of a global execution $\sigma$ to an execution comprising all operations performed by a given client $\mathit{Cl}_i$ (or process $p_i$) plus all writes invoked by
%     other clients.  Chockler et al. also use the notation $S_p$ to denote an equivalent \emph{legal serialization} for a partial execution $\sigma |i + w$;  a legal serialization is a linear sequence of invocation of operations such that each read operation in the sequence returns the result of the last preceding write. %$S_p$ denotes an equivalent \emph{legal serialization} for a partial execution $\sigma |i + w$.
%      A special-purpose operator $\xrightarrow{S_p}$ is used to denote the precedence relation %operator $\rightarrow$ to
%   among operations comprised in the legal serialization $S_p$.
%  %where we assign the notation $S$ to a serialization ${S_p}$, and replace the precedence
%  %operator with the equivalent LTL operator $F$ that denotes ``eventually".
%%  Also, Chockler et al.
%%  bases their definitions on a serialization of an execution sequence comprising all operations performed
%%  by a client application (or a process), along with writes by all other clients. In ConSpec,
%%  we denote such a serialization as $S_p$.
% %We can express the precedence relation for such a
% % serialization in terms of LTL  as $ \mathit{o}^1 F \mathit{o}^2 \in S_p$.
% %\par
% %Let $w^i$ and $r^j$ be signatures of read and write operations $\mathit{o}^1$ and
%% $\mathit{o}^2$, respectively.
%  \par Using the above notations, Chockler et al. state the RYW consistency model as
%  \begin{align}
%  \begin{split}\label{chockler}
%  \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) \Rightarrow \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x),
%  \end{split}
%  \end{align} %RYW is given in the form
%%    \begin{align}\label{eqn:formdef}
%%\begin{split}
%% Condition 1 \Rightarrow Condition 2,
%%  \end{split}
%%  \end{align}
%% where $\Rightarrow$ is the implies operator; Condition 1  and Condition 2 are given as follows.   Condition 1 is given in the form
%%The precondition for the RYW condition is given by Chockler et al. as $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$, where $\mathit{o}^1$ and $\mathit{o}^2$ are  read and write operations  comprised in a given execution $\sigma_i$ of a process $p_i$.  The postcondition is given as $\mathit{o}^1 \xrightarrow{S_p} \mathit{o}^2$,
% where ${S_p}$ is an equivalent legal serialization  for a partial execution  $\sigma |i + w$ comprising
%   operations invoked by $p_i$ plus writes invoked by other clients. %The
%   %precedence relationships among operations $\mathit{o}^1$ and $\mathit{o}^2$ in
%   %Condition 1 can be directly
% % expressed in terms of LTL as follows.
% Let $\mathit{inv}_1$ and  $\mathit{inv}_2$ denote the invocations, and $\mathit{resp}_1$ and  $\mathit{resp}_2$ denote the responses  of  $\mathit{o}^1$ a $\mathit{o}^2$, respectively.  Since the clients are well-formed (as we defined in the definition Section in the ConSpec paper), % \ref{sec:definitions}),
% the precedence relation  $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ %among $\mathit{o}^1$ and $\mathit{o}^2$ with respect to  $\sigma_i$ given
%   in  the original RYW definition by  \cite{Chockler2000}  % Equation \ref{chockler}
%    implies that
%   $ \mathit{inv}^1(x) \xrightarrow{\sigma_i} \mathit{resp}^1(x) $ and $ \mathit{resp}^1(x) \xrightarrow{\sigma_i} \mathit{inv}^2(x) $.
%%    both the  invocation $\mathit{inv}_1$ and response $\mathit{resp}_1$   for $\mathit{o}^1(x)$ occur before the invocation $\mathit{inv}_2$ and response $\mathit{resp}_2$ for $\mathit{o}^2(x)$ can occur.  Hence, the precedence relation $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ among $\mathit{o}^1(x)$ and
%% $\mathit{o}^2(x)$  can be rewritten in terms of the invocation and responses comprising  $\mathit{o}^1$ and
%% $\mathit{o}^2$, i.e.,  $ \mathit{inv}_1 \xrightarrow{\sigma_i} \mathit{inv}_2 $ and $ \mathit{resp}_1 \xrightarrow{\sigma_i} \mathit{resp}_2 $, respectively.
%% %Thus, $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ implies $\mathit{inv}^1 \xrightarrow{\sigma_i} \mathit{inv}^2$.
%%  %Condition 1  denotes precedence among  $\mathit{o}^1$ and $\mathit{o}^2$ with respect to
%%  % a given execution order $\sigma_i$.
%%  By definition,  the session trace $\mathit{st}$ is a sequence comprised of results of operations observed in an execution $\sigma_i$ of the client $\mathit{Cl}_i$. Since operations comprised in $\mathit{st}$ for an execution $\sigma_i$ are ordered by the invocation times of  operations,  the precedence  relation $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ %, among operations in $\sigma_i$,
%%  implies that the invocation of $\mathit{o}^1(x)$ occurred before the invocation of $\mathit{o}^2(x)$ in the temporal ordering of invocation times in  $\mathit{st}$. %can be expressed as a temporal relation   among the events of invocation of $\mathit{o}^1$ and $\mathit{o}^2$ in $\mathit{st}$.
%  %Thus, we can express the precedence  operator $\xrightarrow{\sigma_i}$ using the
%%  special-purpose LTL operator $F_\mathit{st}$ (defined in Section \ref{sec:definitions}), where  $F_\mathit{st}$ denotes an %``eventually" relationship  among invocation  of operations performed by the client $\mathit{Cl}_i$ with respect to $\mathit{st}$.  %Since $\mathit{st}$ orders the operations in terms of invocation times,  Condition 1 can be expressed in terms of an LTL expression that specifies the precedence among events in $\mathit{st}$ as follows.
%  %Since the session trace  $\mathit{st}$ for the local execution $\sigma_i$ orders the operations according to invocation times,
%   Any precedence relation defined on an execution sequence $\sigma_i$  is
%   equivalent to the exact same precedence relation defined on the session trace $\mathit{st}$ in ConSpec.
%    Thus, replacing references to $\sigma_i$  with the notation  $\mathit{st}$, the expression $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ can be rewritten as  $ \square\; \mathit{inv}^1 \rightarrow \lozenge \mathit{inv}^2$. % F_\mathit{st} \mathit{inv}^2$. %, where $F_\mathit{st}$  is a  the special-purpose LTL operator (defined in Section \ref{sec:definitions}).
%     Further, since clients in ConSpec are well-formed, the invocation and response for a given operation precedes the invocation and response of the next operation in $\mathit{st}$.  %An execution order $\sigma$ (invocation order) in
%%   \cite{Chockler2000}of Chockler et al.  is equivalent to the program order $\mathit{po}$ in ConSpec.
%  Thus,  $ \square\; \mathit{inv}^1 \rightarrow \lozenge \mathit{inv}^2$ % F_\mathit{st} \mathit{inv}^2$
%   implies $  \square\; \mathit{resp}_1 \rightarrow \lozenge  \mathit{resp}_2 $, % F_\mathit{st}  \mathit{resp}_2 $,
%    which, in turn, implies $ \square\; \mathit{o}^1(x) \rightarrow \lozenge \mathit{o}^2(x)$. %F_\mathit{st} \mathit{o}^2(x)$.
% Hence, we can rewrite a precedence relation $ \mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x) $ found in Chockler et al.\textquotesingle s definitions as $ \square\; \mathit{o}^1(x) \rightarrow \lozenge \mathit{o}^2(x)$.  % F_\mathit{st} \mathit{o}^2(x)$. %,  where we replace $\sigma_i$ with $\mathit{st}$ without loss of information (see above).
% Let $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$  be propositional logic
%  variables that indicate whether invocations and responses of operations $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$  have
%  executed (if $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$ is TRUE) or not.  Then, the precondition reduces to
%    the ConSpec form $ \square\; \mathit{Op}^1(x) \rightarrow \lozenge  \mathit{Op}^2(x) $. % F_\mathit{st} \mathit{Op}^2(x) $.
%%    \footnote{The above LTL expression implies: if the propositional variable
%%    $\mathit{Op}^1$ (denoting the event of execution of operation $\mathit{o}^1$) is true at one point in the given session trace, $\mathit{Op}^2$ (denoting the event of execution of $\mathit{o}^2$)  is eventually true in some later point in a session trace $\mathit{st}$, i.e.,  the operation $\mathit{o}^2$ eventually follows the operation $\mathit{o}^1$ in the
%%     given session trace $\mathit{st}$. }.  % Thus, the expressions $\left(\mathit{o}^1 \Rightarrow \mathit{o}^2\right)^\sigma$ can be rewritten as LTL formula
%%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
% \par In the postcondition for RYW, Chockler et al.  specify a precedence relation $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$ , which  restricts a precedence relation among $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ in the equivalent legal serialization ${S_p}$ for the given $\sigma |i + w$.   By definition of $S_p$ in the Definition Section in our ConSpec, %\ref{sec:definitions},
%  both the invocation and response for  an operation $\mathit{o}^2(x)$ in $S_p$ must appear after the invocation and response of a preceding operation $\mathit{o}^1(x)$ in $S_p$, i.e., $ \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x) $ implies $ \mathit{inv}^1 \xrightarrow{S_p} \mathit{inv}^2 $ and $ \mathit{resp}^1 \xrightarrow{S_p} \mathit{resp}^2 $.
%    Hence, all components of operation $\mathit{o}^2(x)$ follow all components of $\mathit{o}^1(x)$ in $S_p$.
%%    Thus, we can rewrite the above precedence relation
%%  $ \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x) $, in terms of Linear Temporal Logic, %(i.e., LTL),
%%    as
%%  %$\mathit{o}^1 F \mathit{o}^2 \in S_p$. Further, the above expression
%%  %can be rewritten as
%%  $ \square\;  \mathit{Op}^1(x) F_{S_p} \mathit{Op}^2(x)$. %, which is syntactically equivalent to $\mathit{Op}^1 F \mathit{Op}^2 \in S_p$. %,  where
%%  $S_p$ is equivalent to $S_p$, i.e., both notations represent a legal serialization comprising all
%  % operations performed from a given client application along with writes from all other clients.
%%  Since RYW considers only those execution sequences where a write operation is followed by a read, $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$ can be  replaced  by new propositional variables
%%   $W^{'}(x)$ and $R^{''}(x)$, without any loss of information. Thus, the above precondition and postcondition can be expressed as  $ \square\; W^{'}(x) F_\mathit{st} R^{''}(x)$ and $ \square\; W^{'}(x) F_{S_p}  R^{''}(x) $, respectively. %Further,
% %Thus, the above postcondition can be expressed as  $ \square\; \mathit{Op}^1(x) S_p \mathit{Op}^2(x)$.
%  By the  definition of a valid partial order in Definition \ref{def:form0}, we can replace $S_p$ in the postcondition with the notation  $\preccurlyeq_{\mathit{st}+w}$ (defined in Definition \ref{def:form0} and the RYW Equation in ConSpec paper %\ref{eqn:RYW})
%   because of the following reason.  Thus, we can rewrite the above precedence relation  $ \mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x) $ as $\mathit{Op}^1(x) \preccurlyeq_{\mathit{st}+w} \mathit{Op}^2(x)$. Since RYW considers only those execution sequences where a write operation is followed by a read, $\mathit{Op}^1(x)$ and $\mathit{Op}^2(x)$ can be  replaced  by new propositional variables
%   $W^{'}(x)$ and $R^{''}(x)$, without any loss of information. Thus, the above precondition and postcondition can be expressed as  $ \square\; W^{'}(x) \rightarrow \lozenge R^{''}(x)$ and $ \square\; W^{'}(x) \preccurlyeq_{\mathit{st}+w}  R^{''}(x) $, respectively.
%    According to Chockler et al., a legal serialization $S_p$ is a sequence of operations that satisfies the following properties: Property 1) it is a linear sequence that comprises all operations from a given client $\mathit{Cl}_i$ plus writes from all other clients, and Property 2) each read in the sequence $S_p$ returns the result of the preceding write in $S_p$.  First, by definition (refer to definition of $\preccurlyeq$ in the RYW expression, $\preccurlyeq_{\mathit{st}+w}$ is a partial order  comprising all operations in a session trace $\mathit{st}$ plus writes from other operations, thus $\preccurlyeq_{\mathit{st}+w}$ satisfies Property 1 for $S_p$. Second, following directly from precondition of RYW, the output of each operation in $\preccurlyeq_{\mathit{st}+w}$ is equivalent to that obtained by executing a linear sequence of the operations preceding that operation, thus $\preccurlyeq_{\mathit{st}+w}$ satisfies Property 2 for $S_p$. Hence, we can express the postcondition
%    $ \square\; W^{'}(x) \preccurlyeq_{\mathit{st}+w} R^{''}(x) $ as  $W^{'}(x) \preccurlyeq_{\mathit{st}+w} R^{''}(x)$. Combining the above conditions, Chockler's definition of RYW reduces into the ConSpec specification in the RYW Equation. % \ref{eqn:RYW}.   %Derivations of remaining consistency models  are given in the appendix in Section \ref{sec:restderive}.
%%   Further, the anomaly condition $C$ for RYW can be derived as follows. Let us consider that there exists
%%   a write operation $w^l$ precedes $w^i$, i.e., ${W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t$, and a read operation
%%    $r^k$ precedes $r^j$, i.e., ${R^k}^{'} F {R^j}^{'} \in \mathit{st}$. According to the
%%    definition of RYW in \cite{Terry:1994:SGW:645792.668302, Burckhardt:2014:PEC:2693641.2693642},
%%   either of the following conditions must be satisfied: 1) $r^j$ must not observe a value that was written by $w^l$ if the result of the later write
%%   $w^j$ was already read by read $r^k$, i.e., $\left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right)$, or
%%   2) the read $r^j$ is directly followed by the write $w^l$, i.e.,  the condition
%%   $\left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)$
%%   must hold.
%%  % Let $w^k(o,v_k)$ be signature of the write operation $\mathit{o}^k$, which overwrites the value written by
%%%   $\mathit{o}^1$; let $W^k$ be a propositional variable that indicates whether the operation
%%%   $\mathit{o}^k$ returns the result.
%%%  Replacing variables $\mathit{Op}^1$, $\mathit{Op}^2$, and $\mathit{Op}^k$  with variables $W^j(v_l)$, $R^k{v_m}$, and
%%%  $W^p(v_q)$, respectively, the above condition can be expressed as
%%%  $\not\exists W^k \in \mathit{st} \left( W^k F W^i F R^j \in \mathit{st} \right)$.
%%  From the above reasoning, we can directly derive the ConSpec expression $C$ = $\not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%%\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge \\
%%%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) %\big) \\
%%\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
%%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)$
%% (refer to Equation \ref{eqn:RYW}.
% %\begin{align}
%%  \begin{split}
%%\forall i, j, o, \mathit{st} \big( \left( W^i F R^j \in \mathit{st} \right) \;
%% \Rightarrow \; \exists S_p \left(  W^i F R^j \in S_p \right)
%%\\ \wedge  \not\exists W^k \in \mathit{st} \left( W^k F W^i F R^j \in \mathit{st} \right) %\wedge \left( W^k F W^i \in \mathit{st} \right)
%% \wedge \left( v^j = v^k \right) \big).
%%  \end{split}
%%  \end{align}
%% In the above expression, the condition \\ $\left( W^j(v_l) F W^p(v_q) F R^k{v_m} \right) \oplus \left( W^j(v_l)X^{o}R^k{v_m} \right)$ in a session trace $\mathit{st}$ implies that either 1) the read operation $R^k{v_m}$ returns the value written by the write operation $w^j(o,v_l)$, or 2) a value that is written by a write operation $w^p(o,v_q)$, that follows $w^j(o,v_l)$ and overwrites $o$. The condition 1 in the above statement, in turn, implies that $v_m = v_l$. Plugging in the above expression in Equation \ref{eqn:RYWder}, the above expression can be reduced to the ConSpec expression for RYW, given as
%%  \begin{align}\label{eqn:RYWFin}
%%\begin{split}\forall i, j, k, l, m \left(\star W^j(v_l)X^{o}R^k{v_m} \star \right)_{o}^\mathit{po} \\ \Rightarrow \left(G\;  \left( W^j(v_l) F W^p(v_q) F R^k{v_m} \right) \oplus \left( v_m = v_l \right) \right)_{o}^\mathit{st}
%%\end{split}
%%\end{align}.
%
%%%\par The ConSpec specifications for the isolation levels are derived from the definitions by Adya et al.
%%%\cite{DBLP:conf/icde/AdyaLO00}.  Here, we show that the isolation specifications in ConSpec, given in
%%%Equations \ref{eqn:PL1}, \ref{eqn:PL2}, \ref{eqn:PL3}, and \ref{eqn:PL299}, follow directly from the
%%%definitions of isolation levels PL-1, PL-2, PL-3, and PL-2.99 \cite{DBLP:conf/icde/AdyaLO00}. We analyze the
%%%ConSpec Equations, and demonstrate their equivalence to the definitions of  \cite{DBLP:conf/icde/AdyaLO00}, as
%%%follows.
%%%\par  The PL-1 specification states that the anomaly G0 must be proscribed in any session trace collected
%%%for the execution of a client application. G0 specifies that there can not be any directed cycle in the
%%%dependency graph corresponding to an execution of a pair of transactions, comprising entirely of write dependency edges.
%%%%The
%%%% condition can be avoided if the write dependencies are preserved in any execution of a given client
%%%% application, i.e., if any pair of write operations are executed in order. The LHS of
%%%%  Equation \ref{eqn:PL1}, i.e., the expression $W^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st}$
%%%%  denotes the above precondition with respect to a given session trace $\mathit{st}$ comprising any two
%%%%  write operations $w^i_{tx}$ and $w^j_{tx}$. PL-1 specifies that any session trace must
%%%%  comprise the above write operations in the same order. This, in turn, implies that the write operation
%%%%  $w^j_{tx}$ in the session trace $\mathit{st}$ must overwrite the value written by the write operation $w^i_{tx}$, i.e.,
%%%%  $r^k_{tx}$ that follows the write operation $w^j_{tx}$ must not return the value $v_i$ written by an earlier
%%%%   write. The above condition can be expressed as $\not\exists R^k_\mathit{tx} \in \mathit{st} \left( W^i_\mathit{tx} F W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^k = v^i \right)$.
%%%%  Thus, the above condition can be reduced to the RHS of Equation \ref{eqn:PL1} using ConSpec operators.
%%% Let us consider a pair of transactions $\mathit{tx}$ and $\mathit{ty}$. Let us consider that write operations
%%% $w(x)_\mathit{tx}$ and $w^{'}(y)_\mathit{tx}$ write to objects $x$ and $y$ from transaction $\mathit{tx}$, and
%%% $w^{''}(x)_\mathit{ty}$ and $w^{'''}(y)_\mathit{ty}$ write to objects $x$ and $y$ from transaction $\mathit{ty}$.
%%% According to PL-1 there can not exist a pair of read operations $r^{''''}(x)_\mathit{tx}$ and $r^{'''''}(y)_\mathit{ty}$
%%% invoked from transactions  $\mathit{tx}$ and $\mathit{ty}$  such that the following conditions are simultaneously
%%% satisfied: 1) $r^{''''}(x)_\mathit{tx}$ reads the result of the
%%% write operation $w(x)_\mathit{tx}$ causing a $ww$ dependency from  $\mathit{tx}$ to $\mathit{ty}$, i.e.,
%%% $v^{''''}= v$ must not hold, and 2)
%%%  $r^{'''''}(y)_\mathit{ty}$ reads the result of the
%%% write operation $w^{'''}(y)_\mathit{ty}$ causing a $ww$ dependency between  $\mathit{ty}$ to $\mathit{tx}$, i.e.,
%%% $v^{'''''} = v^{'''} $ must not hold. Simultaneous
%%% satisfaction of conditions 1 and 2 results in a cycle comprising $ww$ dependencies between $\mathit{tx}$ and $\mathit{ty}$.
%%% Thus, we can express the specification of PL-1 as
%%%$C = \forall \mathcal{S}_t, \mathit{st}, \mathit{tx}, \mathit{ty}, x, y,
%%%  {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty} \in  \mathcal{S}_t \\
%%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%%  \left( \not\exists {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \right)
%%%  % \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%%\big( \left( \left( v^{'''''} = v^{''''} \right) \wedge \left( v^{''''} = v \right) \right) \vee \\
%%%\left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big)$
%%% which is identical to Equation \ref{eqn:PL1}. %It can be trivially observed that the above expression for PL-1 proscribes the anomaly G0, and thus satisfies PL-1 specifications.
%%%\par The isolation level PL-2 proscribes the anomalies G1-a, G1-b, and G1-c \cite{DBLP:conf/icde/AdyaLO00}. We show that
%%%the ConSpec specification for PL-2, given in Equation \ref{eqn:PL2}, disallows the above anomalies as follows.
%%%\textbf{G1-a}: According to G1-a, a transaction can not observe a value written by an aborted transaction.
%%% In other words, if either transaction  $\mathit{tx}$ or transaction $\mathit{ty}$ aborts, i.e., either of the conditions $a_\mathit{tx} \in \mathit{st}$ or $a_\mathit{ty} \in \mathit{st}$ hold,
%%% then there can not exist a read operation that reads the value written by an aborted transaction, i.e., the conditions
%%% ${W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st}$ or $ {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}$
%%% can not hold.
%%%Thus, the G1-a condition ca be directly translated to the expression $\not\exists a_\mathit{tx} \in \mathit{st} \;
%%% \left( {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%%  \not\exists a_\mathit{ty} \in \mathit{st} \;
%%% \left( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st} \right)$ in Equation \ref{eqn:PL2}.
%%%  \textbf{G1-b}: According to G1-b, a transaction must always read the final committed version of an object.
%%%  Let us consider consecutive write operations  $w(x)_\mathit{tx}$ and  $w^{'}(x)_\mathit{tx}$ invoked from transaction $\mathit{tx}$
%%%   followed by the commit statement $c_\mathit{tx}$, and a read operation $r^k(x)_\mathit{ty}$ invoked from transaction $\mathit{ty}$, i.e.,
%%%   $ {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} F {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}$.
%%% According to G1-b, $\mathit{ty}$ can never read a value written by an operation in $\mathit{tx}$ that was not finally committed by $tx$.
%%% Thus, $r^{''}(x)_\mathit{ty}$ cannot return the result of $w(x)_\mathit{tx}$ since it was overwritten by another write
%%%  $w^{'}(x)_\mathit{tx}$ before the commit $c_\mathit{tx}$.
%%% The above condition can be expressed as $\not\exists \big( \big(
%%% {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} F {R}(x)^{'''}_\mathit{ty} \in  \mathit{st} \big)
%%%   \wedge \left( v^{''} = v \right)  \big) \wedge
%%%   \not\exists \big( \big(
%%% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} F {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \big)
%%%   \wedge \left( v^{''} = v \right)  \big)$.
%%% \textbf{G1-c}: %PL-2 orders all operations according to their w-r dependency, i.e., if their is a write
%%%% followed by a read in an execution sequence, all executions must contain the above write and read in the same order.
%%%  G1-c specifies that there can be no direct cycle comprising dependency edges, i.e., $wr$ and $ww$ dependencies, between
%%%  transactions in a given execution. The condition \\
%%%  $\not\exists \big(
%%% {W}(x)^{'}_\mathit{tx}, {R}(y)^{''}_\mathit{tx}, {W}(y)^{'''}_\mathit{ty}, {R}(x)^{''''}_\mathit{ty} \in  \mathcal{S}_t \big)
%%%   \big( \left( v^{'''} = v \right) \\
%%%   \wedge \left( v^{''} = v^{'} \right) \big)$ proscribes $wr$ dependency cycles. The expression
%%%   \\ $\big( \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \\ \in \mathcal{S}_t \big)
%%%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%%\big( \left( \left( v^{'''''} = v^{''''} \right) \wedge \left( v^{''''} = v \right) \right) \vee  \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big)$
%%%proscribes $ww$ cycles. % In
%%%%  the LHS of Equation \ref{eqn:PL2}, the expressions
%%%%  $ \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \\
%%%%\wedge \left( W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)
%%%%$ denotes the condition that there are write operations followed by read operations in the execution order of
%%%% transactions $tx$ and $ty$, respectively. Similarly, the RHS of Equation \ref{eqn:PL2} indicates the
%%%% following. Let us consider that the above condition holds for a given session trace. Then, read operations
%%%%   that follow the operations $w^i_{tx}$ and $r^j_{tx}$, or $w^k_{ty}$ and $r^l_{ty}$, respectively, in the respective transactions
%%%% $tx$ and $ty$, must not observe results of write operations that occurred earlier than $w^i_{tx}$ or $w^k_{ty}$
%%%% according in the session trace $\mathit{st}$.   This, in turn, implies that \\
%%%%  $\not\exists W^m_\mathit{tx} \in \mathit{st} \left( W^m_\mathit{tx} F W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^m_\mathit{tx} F W^i_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^j = v^m \right) \\
%%%%\wedge \not\exists W^n_\mathit{ty} \in \mathit{st} \left( W^n_\mathit{ty} F W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right) \wedge \left( W^n_\mathit{ty} F W^k_\mathit{ty} \in \mathit{st} \right) \\ \wedge \left( v^l = v^n \right)$,
%%%%   thus Equation \ref{eqn:PL2} proscribes G1-c.
%%%%     Further, in the RHS, all operations in $tx$ occur before the commit
%%%%   operation $c_{tx}$ is executed in the session trace $\mathit{st}$. The above condition is true for operations in
%%%%   transaction $ty$ as well, thus proscribing G1-a. Further, we can observe that in the RHS, $tx F ty$, i.e., an
%%%%   operation in $ty$ can only occur after all operations in $tx$ have finished, proscribing G1-b.
%%% Thus, the ConSpec
%%%   specification of PL-2 in  Equation \ref{eqn:PL2} proscribes G1-a, G1-b, and G1-c; thus, Equation \ref{eqn:PL2} is
%%%   equivalent to PL-2 specifications by Adya et al.
%%%% \begin{align}\label{eqn:PL2}
%%%%\begin{split}
%%%%\forall i, j, k, l, m, n, q, s, t, u, tx, ty \big( tx F ty \; \wedge \left( w^j_{tx}(o,v_l)X^{o} r^k_{tx}(o){v_m} \right) \\ \wedge \left( w^n_{ty}(o,v_q)X^{o} r^s_{tx}(o){v_u} \right)  \big)^\mathit{po}_{\mathit{o}_i} \\ \Rightarrow \big(\left( v_l \gets (\left( w^j_{tx}(o,v_l) \; X^{o} \; r^k_{tx}(o){v_m} \right) \right) F \;  c_{tx} \\ F \; \left( v_q \gets \left( w^n_{ty}(o,v_q) \; X^{o} \; r^s_{ty}(o){v_u} \right) \right) \; F \; c_{ty} \star \big)^\mathit{st}_{\mathit{o}_i},
%%%%\end{split}
%%%%  \end{align}
%%% \par  The isolation level PL-3 proscribes the anomaly G-2 \cite{DBLP:conf/icde/AdyaLO00}. According to the
%%% ConSpec specification for PL-3 (refer to Equation \ref{eqn:PL3}), apart from proscribing G1 anomalies, G2 anomalies are
%%%  also disallowed. According to G2, their can be
%%% effectively no cycle comprising anti-dependency edges between transactions. The expression \\
%%% $\big( \not\exists  \left({R}(x)^{'}_\mathit{tx} F {W}(x)^{''}_\mathit{ty} F {R}(x)^{'''}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%%  \big( {R}(x)^{''''}_\mathit{ty} F {W}(x)^{'''''}_\mathit{tx} F {R}(x)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \big) \big(  \left( v^{''} = v^{'} \right) \wedge \\
%%% \left( v^{'''''} = v^{''''} \right) \big) \big)$ proscribes anti-dependency cycles. Thus, the
%%% ConSpec expression disallows G2, and effectively follows PL-3. Following the same line of reasoning, we can
%%%  prove that the ConSpec expression in Equation \ref{eqn:PL299} effectively  specifies PL-2.99.
%%
%
%% \subsection{Specification of Isolation Levels}
%%  For specifying isolation levels, we consider only the isolation levels defined by Adya et al. \cite{DBLP:conf/icde/AdyaLO00}. We show the equivalence between the graphical representation of the dependency relations used by Adya et al. and the LTL specifications of ConSpec in Section \ref{sec:equiv}.
%% The isolation level PL-1 mandates that write operations in  a transaction must be executed such that write-write
%% dependency cycles among transactions are proscribed. %before any write from a different transaction executes.
%% Following Definition \ref{def:form0}, PL-1 is specified %in the \textbf{form-2} format, given in Equation \ref{form-2},
%% as follow.
%% % \begin{align}\label{eqn:PL1}
%%%\begin{split}
%%%\forall i,j,k,l,m, tx, ty \left( tx F ty \; \wedge \; \star w^i_{tx} F w^j_{tx} \star \; \wedge \; \star w^k_{ty} F w^l_{ty} \star \right)^\mathit{po}_{o_m} \\
%%%\Rightarrow \left(\star w^i_{tx} F w^j_{tx} \star \; \wedge \; \star w^k_{ty} F w^l_{ty} \star  \right)^\mathit{st}_{o_m},
%%%\end{split}
%%%  \end{align}
%% %\begin{align}\label{eqn:PL1}
%%%\begin{split}
%%%\forall i,j, m, tx \left( \star w^i_{tx} F^{o} w^j_{tx} \star \right)^\mathit{po}_{o_m}
%%%\Rightarrow \left(\star w^i_{tx} F^{o} w^j_{tx} \star  \right)^\mathit{st}_{o_m},
%%%\end{split}
%%%  \end{align}
%%  \begin{align}\label{eqn:PL1}
%%\begin{split}
%%%\forall i, j, k, l, m, n, p, q, u, z, tx \\ \big( \star W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} R^p_{tx}{v_n} \star \big)^\mathit{po}_{o} \\
%%%\Rightarrow \big(G \star \left( v_n = v_q \right) \oplus \\ \left( W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} W^u_{tx}(v_z)  X^{o} R^p_{tx}{v_n}  \right) \star  \big)^\mathit{st}_{o},
%%%\forall i, j, tx \\ \big( \star W^i_{tx} F^{o} W^j_{tx}(v_q) X^{o} R^p_{tx}{v_n} \star \big)^\mathit{po}_{o} \\
%%%\Rightarrow \big(G \star \left( v_n = v_q \right) \oplus \\ \left( W^j_{tx}(v_l) F^{o} W^m_{tx}(v_q) X^{o} W^u_{tx}(v_z)  X^{o} R^p_{tx}{v_n}  \right) \star  \big)^\mathit{st}_{o},
%%%\forall i, j, o, \mathit{st}, \mathit{tx} \big( \left( W^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st} \right) \; \Rightarrow \; \exists S_p \left(  W^i_\mathit{tx} F W^j_\mathit{tx} \in S_p \right)
%%%\\ \wedge  \not\exists R^k_\mathit{tx} \in \mathit{st} \left( W^i_\mathit{tx} F W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \wedge \left( W^j_\mathit{tx} F R^k_\mathit{tx} \in \mathit{st} \right) \\ \wedge \left( v^k = v^i \right) \big),
%% E^s = \forall  \mathit{st} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in \mathcal{S}_t, x, y,\\
%%  {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty} \in  \mathcal{S}_t \\
%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%  \big( \left( \not\exists {R^{'''''}}(x)_\mathit{tx}, {R^{''''''}}(y)_\mathit{ty} \in \mathcal{S}_t \right) \\
%%  % \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%\big( \left( \left( v^{'''''}= v^{'''} \right) \wedge \left( v^{''''} = v \right) \right) \vee \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''}  \right) \right)  \big) \big)
%%\end{split}
%%  \end{align} where $\mathit{tx}$ and $\mathit{ty}$  are consecutive transactions.
%%
%%The isolation level PL-2 states that operations from a transaction can not read a value that was not the final value that was
%%committed by a transaction. Further, a transaction cannot read values written by aborted transactions. Additionally,
%%operations in a transaction must be executed in an order
%%that proscribes write-write and write-read dependency cycles \cite{DBLP:conf/icde/AdyaLO00} among transactions. PL-2 is given as
%% % \begin{align}\label{eqn:PL2}
%%%\begin{split}
%%%\forall i, j, tx, ty \left( tx F ty \right)^\mathit{po}_{\mathit{o}_j} \Rightarrow \left(\star c_{tx} F \mathit{o}^i_{ty} F c_{ty} \star \right)^\mathit{st}_{\mathit{o}_j},
%%%\end{split}
%%%  \end{align}
%%%\begin{align}\label{eqn:PL2}
%%%\begin{split}
%%%\forall i, j, m, tx, ty \left( tx F^{o} ty \; \wedge w^i_{ty} F^{o} r^j_{ty} \right)^\mathit{po}_{\mathit{o}_m} \Rightarrow \\ \left(\star c_{tx} F^{o} w^i_{ty} F^{o} r^j_{ty} F^{o} c_{ty} \star \right)^\mathit{st}_{\mathit{o}_m},
%%%\end{split}
%%%  \end{align}
%%  \begin{align}\label{eqn:PL2}
%%\begin{split}
%%%\forall i, j, k, l, m, n, p, q, u, a, b, c, tx, ty \big( \left( tx F ty \right) \\ \wedge \left( \star W^j_{tx}(v_l)X^{o} R^k_{tx}{v_m} \star \right) \wedge \left( \star W^n_{ty}(v_q)X^{o} R^s_{ty}{v_u} \star \right) \big)^\mathit{po}_{\mathit{o}_i} \\
%%%\Rightarrow \big( G \; \left( \left( v_m = v_l \right) \oplus \left( W^j_{tx}(v_l) F^{o} W^p_{tx}(v_a) X^{o} R^k_{tx}{v_m} \right) \right) F \;  c_{tx} \\ F \; \left( \left( v_u = v_q \right) \oplus \left( W^n_{ty}(v_q) F^{o} W^b_{ty}(v_c) X^{o} R^s_{ty}{v_u} \right) \right) \; F \; c_{ty} \star \big)^\mathit{st}_{\mathit{o}_i},
%%%\forall i, j, k, l, o, \mathit{st}, \mathit{tx}, \mathit{ty} \big( \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \\
%%%\wedge \left( W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)
%%%\; \Rightarrow \; \exists S \left( W^i_\mathit{tx} F R^j_\mathit{tx} F c_\mathit{tx} \in S \right) \\
%%%\wedge \left(  c_\mathit{tx} F W^k_\mathit{ty} F R^l_\mathit{ty} F c_\mathit{ty} \in S_p \right)
%%%\\ \wedge  \not\exists W^m_\mathit{tx} \in \mathit{st} \left( W^m_\mathit{tx} F W^i_\mathit{tx} F R^j_\mathit{tx} \in \mathit{st} \right) \wedge \left( v^j = v^m \right) \\
%%%\wedge \not\exists W^n_\mathit{ty} \in \mathit{st} \left( W^n_\mathit{ty} F W^k_\mathit{ty} F R^l_\mathit{ty} \in \mathit{st} \right)  \wedge \left( v^l = v^n \right) \big)
%%E^{r} = \forall  \mathit{st}, \mathit{st}^{'} \in  \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in  \mathcal{S}_t \\ \big(
%% % \mathit{tx} F \mathit{ty} \Rightarrow
%% \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
%% \big(  {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \big) \\
%%  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
%% \big( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%% \big( \not\exists  {W}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{tx}, \\ {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}  \big)
%% \big( \left( {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
%%   \wedge \left( v^{''} = v \right)  \big)  \wedge
%%   \not\exists \left( {W}(x)^{'}_\mathit{ty}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \right) \\
%%    \big( \left(
%% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
%%   \wedge \left( v^{''} = v \right)  \big) \wedge
%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%  \big( \\ \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \\ \big)
%%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%\big( \left( \left( v^{''''} = v^{'''} \right) \wedge \left( v^{'''''} = v \right) \right) \vee \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big) \big) %\wedge \\
%%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%%% \big( \not\exists  \left({R^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%%  \left({R^l}(y)^{'}_\mathit{ty} F {W^m}(y)^{'}_\mathit{tx} F {R^n}(y)^{'}_\mathit{tx} \in \mathcal{S}_t \right)  \big) \big(  \left( v_k^{'} = v_j^{'} \right) \wedge \\
%%% \left( v_n^{'} = v_m^{'} \right) \big)
%% %\big)
%%  %\left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%%%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%%%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%%%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right)  \big) \big)
%% %\left( c_{ty} F {\mathit{Op}^i}^{'}_\mathit{tx} \in \mathit{st} \right) \big) \wedge \\
%%% \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx}, {W^j}(y)^{'}_\mathit{tx}, {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty} \in  \mathcal{S}_t \right) \wedge  \\
%%%  \left( {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathit{st} \right) \big)
%%%  \big( \left( v_m^{'} = v_j^{'} \right) \wedge \left( v_n^{'} = v_k^{'} \right) \big)  \wedge \\
%%%  \forall \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{tx} \in \mathit{st} \right) \left( {v_i}^{'} = {v_j}^{'} \right) \big)
%%\end{split}
%%  \end{align} where $c_{tx}$ and $c_{ty}$ are the commit statements for the transactions $\mathit{tx}$ and $\mathit{ty}$, respectively. F is the traditional LTL next operator.
%%
%% The isolation level  PL-3 specifies that, on top of PL-2,  read-write dependency cycles \cite{DBLP:conf/icde/AdyaLO00}
%%  must also be proscribed among transactions. PL-3 is given as
%% %\begin{align}\label{eqn:PL3}
%%%\begin{split}
%%%\forall i,j,k,l,m, tx, ty \left( tx F^{o} ty \; \wedge \; \star \mathit{o}^i_{tx} F^{o} \mathit{o}^j_{tx} \star \; \wedge \; \star \mathit{o}^k_{ty} F^{o} \mathit{o}^l_{ty} \star \right)^\mathit{po}_{o_m} \\
%%%\Rightarrow \left(\star \mathit{o}^i_{tx} F^{o} \mathit{o}^j_{tx} F^{o} c_{tx} F^{o} \mathit{o}^k_{ty} F^{o} \mathit{o}^l_{ty} F^{o} c_{ty}  \right)^\mathit{st}_{o_m}.
%%%\end{split}
%%%  \end{align}
%%  \begin{align}\label{eqn:PL3}
%%\begin{split}
%%%\forall i, j, k, l, m, n, q, s, t, u, w, x, z, a, b, c, d, e, f, g, h, tx, ty \\
%%%\big( \left( tx F ty \right) \wedge \left( \mathit{Op}^j =  \left(W^j_{tx}(v_l) \oplus R^k_{tx}{v_m} \right) \right) \wedge \\
%%%\left( \mathit{Op}^n = \left( W^n_{tx}(v_q) \oplus R^s_{tx}{v_t} \right) \right)  \wedge \left( \star  \mathit{Op}^j X^{o} \mathit{Op}^n \star \right) \wedge \\
%%%\left( \mathit{Op}^u = \left(W^u_{ty}(v_w) \oplus R^x_{ty}{v_z} \right) \right) \wedge \left( \mathit{Op}^a = \left( W^a_{ty}(v_b) \oplus R^c_{ty}{v_d} \right) \right) \\
%%%\left( \star \mathit{Op}^u X^{o} \mathit{Op}^a   \star \right) \big)^\mathit{po}_{o} \\
%%%\Rightarrow \big(G \; \left( v_f = v_q \right)  \oplus \left( v_t = v_l \right) \oplus \left( v_t = v_m \right) \big)  \\
%%%  F c_{tx} F \big( \left( v_h = v_b \right) \oplus \left( v_d = v_b \right) \oplus \left( v_d = v_z \right) \big) F c_{ty}  \big)^\mathit{st}_{o}.
%%%E^{r} = C = \big( \not\exists \left( a_\mathit{tx} \oplus a_\mathit{ty} \in \mathit{st} \right)
%%% \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in \mathit{st} \right)  \wedge
%%%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%%% \not\exists \big( \big( \\
%%% {W^i}(x)^{'}_\mathit{tx}  F {W^j}(x)^{'}_\mathit{tx} F  c_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \big)
%%%   \wedge \left( v_k^{'} = v_i^{'} \right)  \big) \wedge \\
%%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%%  \left( \not\exists {W^i}(x)^{'}_\mathit{tx},  {W^j}(y)^{'}_\mathit{tx},
%%%  {W^k}(x)^{'}_\mathit{ty}, {W^l}(y)^{'}_\mathit{ty}, {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \\
%%%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%%\big( \left( \left( v_n^{'} = v_l^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right) \right) \vee \left( \left( v_n^{'} = v_j^{'} \right) \wedge \left( v_m^{'} = v_k^{'} \right) \right)  \big) \wedge \\
%%%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%%% \left( \not\exists {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^p}(x)^{'}_\mathit{tx}, {R^q}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \big(  \left( v_p^{'} = v_j^{'} \right) \wedge \\
%%% \left( v_q^{'} = v_i^{'} \right) \big)
%%%   \big) \big) \wedge
%%%%\forall  \mathcal{S}_t, \mathit{st}, \mathit{st}^{'}, \mathit{tx}, \mathit{ty} \big(
%%%%  \mathit{tx} F \mathit{ty} \Rightarrow \\
%%%% \big( \not\exists \left( \left( a_\mathit{tx} \in \mathit{st} \right) \wedge \left( a_\mathit{ty} \in \mathit{st} \right) \right) \wedge \\
%%%% %\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%%%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {W^j}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \right)  \wedge \left( v_k^{'} = v_i^{'} \right)  \right) \wedge \\
%%%%  \left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \\
%%%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%%%% \left( \not\exists {W^i}(x)^{'}_\mathit{tx}, {W^j}(x)^{'}_\mathit{ty}, {R^p}(x)^{'}_\mathit{tx}, {R^q}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \big(  \left( v_p^{'} = v_j^{'} \right) \wedge \\
%%%% \left( v_q^{'} = v_j^{'} \right) \big) \wedge
%%%%   \big) \big)
%%%%E^s =  \forall  \mathcal{S}_t, \mathit{st} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \big(
%%%%  \mathit{tx} F \mathit{ty} \Rightarrow \\
%%%% \big( \not\exists \left( a_\mathit{ty} F a_\mathit{tx} \in \mathit{st} \right) \wedge \not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%%%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%%%%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%%%%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%%%%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right) \wedge \\
%%%   \not\exists \big( \left( {R^i}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^k}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right) \big) \\
%%%  \big( \left( \left( v_k^{'} = v_j^{'} \right)  \wedge \left( v_p^{'} = v_m^{'} \right) \right)  \big) \big) \big) \big)
%%E^{r} = C = \forall \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in \mathcal{S}_t \\ \big(
%% % \mathit{tx} F \mathit{ty} \Rightarrow
%% \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
%% \big(  {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \big) \\
%%  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
%% \big( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%% \big( \not\exists  {W}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{tx}, \\ {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}  \big)
%% \big( \left( {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
%%   \wedge \left( v^{''} = v \right)  \big)  \wedge
%%   \not\exists \left( {W}(x)^{'}_\mathit{ty}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \right) \\
%%    \big( \left(
%% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
%%   \wedge \left( v^{''} = v \right)  \big) \wedge
%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%  \big( \\ \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \\ \big)
%%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%\big( \left( \left( v^{''''} = v^{'''} \right) \wedge \left( v^{''''} = v \right) \right) \vee \\ \left( \left( v^{''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big) \wedge \\
%%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%%    \big( \not\exists {R}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{ty}, {R}(y)^{''''}_\mathit{ty}, {W}(y)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \\
%%     \big( \big( {R}(x)^{'}_\mathit{tx} F {W}(x)^{''}_\mathit{ty} F {R}(x)^{'''}_\mathit{ty} \in \mathcal{S}_t \big) \wedge \\
%%  \big(  {R}(y)^{''''}_\mathit{ty} F {W}(y)^{'''''}_\mathit{tx} F {R}(y)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \big)  \\
%%  \big(  \left( v^{''} = v^{'} \right) \wedge
%% \left( v^{'''''} = v^{''''} \right) \big) \big) \big)
%%%\left( \mathit{Op}^i_\mathit{tx} X^o \mathit{Op}^j_\mathit{tx} \in \mathit{st} \right) \wedge
%%% \left( \mathit{Op}^k_\mathit{ty} X^o \mathit{Op}^l_\mathit{ty} \in \mathit{st} \right)
%%%\\ \Rightarrow \exists S \left( \mathit{Op}^i_\mathit{tx} X^o \mathit{Op}^j_\mathit{tx} F c_\mathit{tx} F \mathit{Op}^k_\mathit{ty} X^o \mathit{Op}^l_\mathit{ty} F c_\mathit{ty}  \in S \right)  \wedge \\
%%% \forall \mathit{st}  \left( \mathit{Op}^j_\mathit{tx} X^o R^m_\mathit{tx} \in \mathit{st} \right) \wedge \left( v^m = v^j  \right) \wedge \\
%%% \forall \mathit{st}  \left( \mathit{Op}^k_\mathit{ty} X^o R^n_\mathit{ty} \in \mathit{st} \right) \wedge \left( v^n = v^k  \right) \big) \big)
%%\end{split}
%%  \end{align}
%%  The isolation level  PL-2.99 specifies that, on top of PL-2, read-write item-dependency cycles must be proscribed among transactions. PL-2.99 is given as
%%  \begin{align}\label{eqn:PL299}
%%\begin{split}
%%%\forall i, j, k, l, m, n, p, q, s, t, u, a, b, c, d, e, f, tx, ty \\ \big( \left( tx F ty \right) \wedge \left( \left( \star R^j_{tx}{v_l} F^{o} W^k_{tx}(v_m) X^{o} R^p_{tx}{v_t} \star \right) \right) \\ \wedge \left( \left( \star R^n_{ty}{v_s} F^{o} W^q_{ty}(v_u) X^{o} R^a_{ty}{v_b} \star \right) \right) \big)^\mathit{po}_{o_m} \\
%%%\Rightarrow \big( G \left( v_t = v_m \right) \oplus \left( R^j_{tx}{v_l} F^{o} W^c_{tx}(v_d) F^{o} W^k_{tx}(v_m) X^{o} R^p_{tx}{v_t} \right) \\ F \;  c_{tx} \; F \; \\  \left( v_b = v_u \right) \oplus \left( R^n_{ty}{v_s} F^{o} W^q_{ty}(v_u) F^{o} W^e_{ty}(v_f) X^{o} R^a_{ty}{v_b} \right) \\ F \;  c_{ty} \big)^\mathit{st}_{o_m}.
%%%E^s =  \forall  \mathcal{S}_t, \mathit{st} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \big(
%%%  \mathit{tx} F \mathit{ty} \Rightarrow \\
%%% \big( \not\exists \left( a_\mathit{ty} F a_\mathit{tx} \in \mathit{st} \right) \wedge \not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%%% \not\exists \left( \left( {W^i}(x)^{'}_\mathit{tx} F {R^j}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \left( {W^k}(x)^{'}_\mathit{tx} \in \mathit{st}  \right) \right) \\
%%%  \left( {R^j}(x)^{'}_\mathit{ty} F {W^k}(x)^{'}_\mathit{tx} F c_\mathit{tx} \in  \mathit{st} \right) \wedge \\
%%%   \not\exists \big( \left( {W^i}(x)^{'}_\mathit{tx} F {R^k}(x)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^j}(x)^{'}_\mathit{ty} F {R^l}(x)^{'}_\mathit{ty} \in  \mathit{st} \right) \wedge \\
%%%  \left( {W^m}(y)^{'}_\mathit{tx} F {R^p}(y)^{'}_\mathit{tx} \in  \mathit{st}  \right) \wedge
%%%  \left( {W^n}(y)^{'}_\mathit{ty} F {R^q}(y)^{'}_\mathit{ty} \in  \mathit{st} \right)\big) \\
%%%  \left( \left( v_l^{'} = v_k^{'} \right) \wedge \left( v_q^{'} = v_m^{'} \right) \right) \wedge \\
%%E^{r} = C = \forall \mathit{st}, \mathit{st}^{'} \in \mathcal{S}_t, \mathit{tx}, \mathit{ty} \in \mathcal{S}_t \\ \big(
%% % \mathit{tx} F \mathit{ty} \Rightarrow
%% \big( \big( \not\exists a_\mathit{tx} \in \mathit{st}
%% \big(  {W}(x)^{'}_\mathit{tx} F {R}(x)^{''}_\mathit{ty} \in \mathit{st} \big) \\
%%  \wedge  \not\exists a_\mathit{ty} \in \mathit{st}
%% \big( {W}(y)^{'''}_\mathit{ty} F {R}(y)^{''''}_\mathit{tx} \in \mathit{st}  \big) \big) \wedge
%%%\not\exists \left( c_{ty} F c_{tx} \in \mathit{st} \right)  \wedge \\
%% \big( \not\exists  {W}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{tx}, \\ {R}(x)^{'''}_\mathit{ty} \in  \mathit{st}  \big)
%% \big( \left( {W}(x)^{'}_\mathit{tx}  F {W}(x)^{''}_\mathit{tx} F  c_\mathit{tx} \in  \mathit{st} \right) \\
%%   \wedge \left( v^{''} = v \right)  \big)  \wedge
%%   \not\exists \left( {W}(x)^{'}_\mathit{ty}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{tx} \in  \mathit{st} \right) \\
%%    \big( \left(
%% {W}(x)^{'}_\mathit{ty}  F {W}(x)^{''}_\mathit{ty} F  c_\mathit{ty} \in  \mathit{st} \right)
%%   \wedge \left( v^{''} = v \right)  \big) \wedge
%% %\mathit{tx} F \mathit{ty} \Rightarrow
%%  \big( \\ \not\exists {W}(x)^{'}_\mathit{tx},  {W}(y)^{''}_\mathit{tx},
%%  {W}(x)^{'''}_\mathit{ty}, {W}(y)^{''''}_\mathit{ty}, {R}(x)^{'''''}_\mathit{tx}, {R}(y)^{''''''}_\mathit{ty} \in \mathcal{S}_t \\ \big)
%%% \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \\
%%%\wedge \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%\big( \left( \left( v^{'''''} = v^{''''} \right) \wedge \left( v^{'''''} = v \right) \right) \vee \\ \left( \left( v^{'''''} = v^{'} \right) \wedge \left( v^{''''} = v^{''} \right) \right)  \big) \wedge \\
%%%\left( \not\exists {R^m}(x)^{'}_\mathit{tx}, {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \c\
%%%   \big( \left( {W^i}(x)^{'}_\mathit{tx} F c_\mathit{tx} F  {W^k}(x)^{'}_\mathit{ty} F {R^m}(x)^{'}_\mathit{ty} \in \mathit{st} \right) \wedge \\
%%%   \left( {W^j}(y)^{'}_\mathit{tx} F c_\mathit{tx} F {W^l}(y)^{'}_\mathit{ty} F {R^n}(y)^{'}_\mathit{ty} \in \mathcal{S}_t \right) \wedge \\
%%% \left( v_n^{'} = v_k^{'} \right) \wedge \left( v_m^{'} = v_i^{'} \right)  \big) \wedge \\
%%    \big( \not\exists {R}(x)^{'}_\mathit{tx}, {W}(x)^{''}_\mathit{ty}, {R}(x)^{'''}_\mathit{ty}, {R}(x)^{''''}_\mathit{ty}, {W}(x)^{'''''}_\mathit{tx}, {R}(x)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \\
%%     \big( \big( {R}(x)^{'}_\mathit{tx} F {W}(x)^{''}_\mathit{ty} F {R}(x)^{'''}_\mathit{ty} \in \mathcal{S}_t \big) \wedge \\
%%  \big(  {R}(x)^{''''}_\mathit{ty} F {W}(x)^{'''''}_\mathit{tx} F {R}(x)^{''''''}_\mathit{tx} \in \mathcal{S}_t \big)  \big)  \\
%%  \big(  \left( v^{''} = v^{'} \right) \wedge
%% \left( v^{'''''} = v^{''''} \right) \big) \big) \big)
%%%E = C = \forall i, j, k, l, o, \mathit{st}, \mathit{tx}, \mathit{ty} \big( \left( \mathit{tx} F \mathit{ty} \right) \wedge \left( R^i_\mathit{tx} F W^j_\mathit{tx} \in \mathit{st} \right) \\
%%%\wedge \left( R^k_\mathit{ty} F W^l_\mathit{ty} \in \mathit{st} \right)
%%%\\ \Rightarrow \; \exists S \left( R^i_\mathit{tx} F W^j_\mathit{tx} F c_\mathit{tx}  F R^k_\mathit{ty} F W^l_\mathit{ty} F c_\mathit{ty}\in S \right) \\
%%%\\ \wedge  \not\exists R^m_\mathit{tx} \in \mathit{st} \left( R^i_\mathit{tx} F W^j_\mathit{tx} F R^m_\mathit{tx} \in \mathit{st} \right)  \wedge \left( v^i = v^m \right) \\
%%%\wedge  \not\exists R^n_\mathit{ty} \in \mathit{st} \left( R^k_\mathit{ty} F W^l_\mathit{ty} F R^n_\mathit{ty} \in \mathit{st} \right) \wedge \left( v^k = v^n \right) \big)
%%\end{split}
%%  \end{align}
%%\subsection{Derivations of Rest of the ConSpec Specifications}\label{sec:restderive}
%  %Session Monotonic or Monotonic Read (also referred to as Session Causality or MR) consistency model is
% %another popular consistency model \cite{Chockler2000, Terry:1994:SGW:645792.668302}.
% \par  According to Chockler et al.,
% MR is expressed in terns of a correctness condition \begin{equation}\label{eqn:formdef}
%%\begin{split}$
%Condition 1 \Rightarrow Condition 2, \end{equation} %in Equation \ref{eqn:formdef}, %as: if the condition  (Condition 1) $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ holds for a given execution sequence $\sigma_i$,
% where both $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ are read operations.
%   %Equation \ref{eqn:formdef} is given as %$\begin{align}\label{eqn:formdef}
%%\begin{split}
% %$Condition 1 \Rightarrow Condition 2$,
% % \end{split}
% % \end{align}
%% and $\Rightarrow$ is the implies operator. %,
%  %there must exist a serialization ${S_p}$, comprising the
%   %operations $\mathit{o}^1$ and $\mathit{o}^2$, for which the condition (Condition 2)
%  %$\mathit{o}^1 \xrightarrow{S_p} \mathit{o}^2$ holds.
%   Following the same logic as that used in the derivation of RYW (refer to the ConSpec specification  Section in the ConSpec paper), % \ref{sec:list}),
%    the precedence relationships among operations $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ in Condition 1 can be directly
%  expressed in terms of an LTL expression
%    $ \square\; R^{'}(x) \rightarrow \lozenge R^{''}(x) $.   Similarly, the expression $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$ in Condition 2
%  can be expressed in terms of a valid partial order $\preccurlyeq_{\mathit{st}+w} $  over $\mathit{st}$   %LTL as $ \square\;  R^{'}(x) F_{S_p} R^{''}(x)$.
%    Further, similar to the derivation of RYW,  we can rewrite the expression %$ R^{'}(x)  R^{''}(x) $ in Condition 2
%    as  $R^{'}(x) \preccurlyeq_{\mathit{st}+w} R^{''}(x)$, thus reducing the above specification  into the MR  Equation in ConSpec paper. % \ref{eqn:MR}.
%%    Let us consider a sequence of consecutive read operations $R^i$ and $R^j$  in a given
%%    session trace $\mathit{st}$, i.e., the condition ${R^i}^{'} F {R^j}^{'} \in \mathit{st}$ holds. Further,
%%     consider that there exists two consecutive write operations $w^m$ and $w^n$ in the global session
%%    history, i.e., the condition ${W^m}^{''} F {W^n}^{''}  \in \mathcal{S}_t$ holds. According to the definition of MR,
%%     if the first read operation $r^i$ returns the
%%    result of the later write $w^n$, then either of the following conditions must hold: 1) the read $r^j$ that follows $r^i$ can not return the result
%%    written by an earlier read by the earlier write $w^m$, i.e., the condition $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right)$ holds, or 2) the read operation $r^j$ is directly followed by write
%%    operation $w^m$, i.e., the condition $\left( {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)$ holds.
%%    %The above condition can be expressed in terms of LTL
%%%    by the expression $\left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right)$.
%%    The above conditions can be combined together to the anomaly expression for MR, i.e.,
%%     $C = \not\exists \big( \left( {R^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge %\left( {\mathit{st}}^{'} \in \mathcal{S}_t \right) \wedge
%% \left( {W^m}^{''} F {W^n}^{''}  \in \mathcal{S}_t \right) \\ \big( %\left( {W^m}^{''} F {W^n}^{''} F {R^i}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\
%% \left( {v^i}^{'} = {v^n}^{''} \right) \wedge \big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \big( \left( {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \\ \left( \not\exists {W^m}^{'} F {W^p}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)$.
% %Thus, the ConSpec specification for MR is directly derived from the definition by Chockler et al.
%   %\begin{align}%\label{eqn:PL299}
%%\begin{split}
%%\big(\star \left( W^j(v_l)X^{o}R^k{v_m} \right) \\ \wedge \left( W^n(v_q) X^{o}R^s{v_t} \wedge ( R^k{v_m}F^{o}R^s{v_t} \right) \star \big)^\mathit{po}_{o}
%%\\ \Rightarrow \big(G\; \star \left( W^n(v_q) X^{o}R^s{v_t} \right)\oplus \\ \left(W^n(v_q) F^{o} W^u(v_x) X^{o} R^s{v_t} \right) \star \big)_{o}^\mathit{st}
%%\end{split}
%%\end{align}.  $W^n(v_q) X^{o}R^s{v_t}$ implies that the read operation $r^s(o){v_t}$ must return the value $v_x$ written by the write operation $w^n(, ov_q)$. This, in turn, implies $v_t = v_x$.
%  %Thus, the above expression can be again rewritten as \begin{align}%\label{eqn:PL299}
%%\begin{split}
%%\big(\star \left( w^j(v_l)X^{o}r^k{v_m} \right) \wedge \left( w^n(v_q)X^{o}r^s{v_t} \right) \star \big)^\mathit{po}_{o} \\
%%\Rightarrow \big(G\; \star \left( v_q \gets \left( R^k{v_m}F^{o}R^s{v_t} \right) \right)\oplus \\ \left( v_x \gets \left( W^n(v_q) F^{o} W^u(v_x) X^{o} R^s v_t \right) \right) \star \big)_{o}^\mathit{st}
%%\end{split}
%%\end{align}.
%% Additionally, we also consider a read operation $r^s(o){v_t}$ that reads values written by $w^n(o,v_q)$, i.e., \\ $w^n(o,v_q) X^{o} r^s(o){v_t}$. Then, without violating the above conditions, the above expression can be reduced to the ConSpec expression for MR, given as
%% Hence, the above equation can be directly reduced to the equivalent ConSpec expression for MR, which is
%% \begin{align}%\label{eqn:PL299}
%%\begin{split}
%%\forall i, j, k, l, m, n, q, r, s, t \big(\star ( W^j(v_l)X^{o}R^k{v_m} ) \\ \wedge ( W^n(v_q)X^{o}R^s{v_t} ) \wedge ( R^k{v_m}F^{o}R^s{v_t} ) \star \big)^\mathit{po}_{o} \\
%%\Rightarrow \big(G\; \star %\left( v_t = v_q \right) \wedge
%%  (v_t = v_q ) \oplus ( W^n(v_q) F^{o} W^u(v_x) X^{o} R^s{v_t} ) \star \big)_{o}^\mathit{st}.
%%\end{split}
%%\end{align}.
%%$\forall i, j, o, \mathit{st} \; \big( \mathit{Op}^i X \mathit{Op}^j \in \mathit{st}
%%\Rightarrow \exists S \left( \mathit{Op}^i X \mathit{Op}^j \in S \right) \\ \wedge
%%\forall \mathit{st}  \left( \mathit{Op}^j X^o R_k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right) \big)$
%%\par  Chockler et al. expresses WFR consistency as Equation \ref{eqn:formdef},  %as: if the condition (Condition 1)
%%  %$\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ holds for a given execution sequence $\sigma_i$
%%  where of a read operation
%%   $\mathit{o}^1(x)$ is followed by a write operation  $\mathit{o}^2(x)$ in an execution $\sigma_i$. %, there must exist a serialization ${S_p}$, comprising the
%%   %operations $\mathit{o}^1$ and $\mathit{o}^2$, for which the condition (Condition 2)
%%  %$\mathit{o}^1 \xrightarrow{S_p} \mathit{o}^2$ must hold.
%%   As in the case of of our derivations for sRYW and MR, the expressions $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$,
%%  and $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$ for Conditions 1 and 2  can be rewritten as LTL expressions. However, since write operations have no meaning unless we have a read operation on the same object succeeding it in the session trace; this translates into the LTL expression
%%   $R^{'}(x) F_\mathit{st} W^{''}(x) F_\mathit{st} R^{'}(x)$ and $R^{'}(x) F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$, respectively.  %, where a session trace $\mathit{st}$ is equivalent to $\sigma$ for the
%%    %means and purposes of this paper.
%% % Thus, the expressions $\left(\mathit{o}^1 \Rightarrow \mathit{o}^2\right)^\sigma$ can be rewritten as LTL formula
%%%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
%%   %Similarly, the expression $\mathit{o}^1 \xrightarrow{S} \mathit{o}^2$ in Condition 2
%%  %can be expressed in terms of LTL as $R^{'} F W^{''} \in S_p$$.
%%  Following from the reasoning of or derivations of  RYW and MR, the expression $R^{'}(x)  F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$ for Condition 2 can be rewritten in terms of ConSpec as  $R^{'}(x)  \preccurlyeq_{\mathit{st}+w} W^{''}(x) \preccurlyeq_{\mathit{st}+w} R^{'}(x)$,  thus reducing the WFR definition to Equation \ref{eqn:WFR}.
%  % Further,
%%   since WFR talks about a sequence comprising a read and a write operation, the propositional variable
%%   $\mathit{Op}^1$ and   $\mathit{Op}^2$ in both Condition 1 and Condition 2 can safely be  replaced  by new
%%   propositional variables  $R^i$ and $W^j$.
%%   Further, let us consider consecutive read operations $r^k$ and $r^j$ in a  given session trace, and a write operation $w^i$
%%   preceded by a write operation $w^l$.  According to WFR, under the above condition, if the earlier read $r^k$ returns the result of the later write
%%   $w^i$, then  one of the following conditions must
%%   hold: 1) a later read $r^j$ can not return the result of an earlier write $w^l$, i.e., $ {v^j}^{'} = {v^l}^{'}$, or
%%   2) the read $r^j$ must directly succeed the write $w^l$ in the global session history, i.e., $\left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right)$.
%%   Further, let us consider a session trace comprising a sequence of reads $r^i$ and $r^k$ that follows a write operation $w^j$, and a write
%%   operation $w^m$ precedes read $r^k$ in the global session history. If $r^i$ reads from $w^j$, $r^k$ reads from $w^m$, and
%%    a read operation $r^l$ reads from $w^j$, then one of the following conditions must hold: 1) $r^l$ reads from $w^m$, i.e.,
%%     ${v^l}^{''} = {v^j}^{''}$,  or 2) $w^m$ is directly succeeded by $r^l$, i.e., $ \left( {W^m}^{''} F { R^l}^{''} \in \mathcal{S}_t \right) \wedge
%%   \left(  \not\exists {W^m}^{''} F {W^n}^{''} F { R^l}^{''} \in \mathcal{S}_t  \right)$. %can be also expressed as: a read operation $r^n$ must not observe
%%%    a value that is written by  an earlier read $r^i$ instead of a later write operation $w^j$ in the
%%%    execution sequence. %The above condition can be expressed in terms of the LTL expression
%%    %$\not\exists  \mathit{st} \left( R^i F W^j F R^n \in \mathit{st} \right) \wedge \left( W^j F R^n \in \mathit{st} \right) \wedge \left( v^n = v^i \right)$.
%%     Combining the above
%%  conditions, we can derive the ConSpec expression for WFR $ C = \not\exists  \big( %\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%%\left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge \\
%%%\left(  \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) %\big) \\
%%\big( \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
%%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big) \wedge \\
%% \not\exists \big(  \left(  {W^j}^{''}  F  {R^i}^{''} F {R^k}^{''} \in \mathcal{S}_t \right) \wedge \left(  {W^m}^{''}  F  {R^k}^{''} \in \mathcal{S}_t \right) \wedge \\
%% \left( {v^j}^{''} = {v^i}^{''} \right) \wedge \left( {v^m}^{''} = {v^k}^{''} \right)  \wedge \left( {v^l}^{''} = {v^j}^{''} \right)  \big) \big( \left( {v^m}^{''} = {v^l}^{''} \right) \\
%%  \vee \big( \left( {W^m}^{''} F { R^l}^{''} \in \mathcal{S}_t \right) \wedge
%%   \left(  \not\exists {W^m}^{''} F {W^n}^{''} F { R^l}^{''} \in \mathcal{S}_t  \right)  \big)  \big)$
%%   (refer to Equation \ref{eqn:WFR}).
%%  \par Chockler et al. expresses the MW consistency model as Equation \ref{eqn:formdef}, where %: if the condition (Condition 1)   $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ holds for a given execution sequence $\sigma_i$ of
%% $\mathit{o}^1(x)$ and $\mathit{o}^2(x)$ are   write operations in an execution $\sigma_i$. %, there must exist a serialization ${S_p}$, comprising the
%%   %operations $\mathit{o}^1$ and $\mathit{o}^2$, for which the condition (Condition 2)
%%  %$\mathit{o}^1 \xrightarrow{S} \mathit{o}^2$ must hold.
%%  Following the same line of reasoning as that of our derivations for RYW, MR, and WFR, the expressions $\mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x)$,
%%  and $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$  can be rewritten as LTL expressions. However, since write operations have no meaning unless we have a read operation on the same object succeeding it in the session trace; this translates into the LTL expression
%%   $W^{'}(x) F_\mathit{st}  W^{''}(x) F_\mathit{st}  R^{'}(x)$ and $W^{'}(x) F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$, respectively.
%%  The above precedence relationships among operations $\mathit{o}^1$ and $\mathit{o}^2$ in Condition 1 can be directly
%%  expressed in terms of an LTL expression
%%    $\mathit{Op}^1 F \mathit{Op}^2 \in \mathit{st}$, where a session trace $\mathit{st}$ is equivalent to $\sigma$ for the
%%    means and purposes of this paper.
% % Thus, the expressions $\left(\mathit{o}^1 \Rightarrow \mathit{o}^2\right)^\sigma$ can be rewritten as LTL formula
%%  $\left(\mathit{Op}^1 X^{o} \mathit{Op}^2\right)_{o}^\mathit{po}$.
%%   The expression $\mathit{o}^1 \xrightarrow{Si} \mathit{o}^2$ in Condition 2
%%  can be expressed in terms of LTL as $\mathit{Op}^1 F \mathit{Op}^2 \in S_p$,  where
%%  $S_p$ is equivalent to $S_p$.  Further,
%%   since MW talks about a sequence of write operations, the propositional variable
%%   $\mathit{Op}^1$ and   $\mathit{Op}^2$ in both Condition 1 and Condition 2 can safely be  replaced  by new
%%   propositional variables  $W^{'}$ and $W^{''}$.
% %Exactly like our previous derivation, Chockler's expression for WFR and MW consistency models
% %$W^{'}(x)  F_{S_p} W^{''}(x) F_{S_p} R^{'}(x)$ for Condition 2  can be rewritten as  $W^{'}(x)  \preccurlyeq_{\mathit{st}+w} W^{''}(x) \preccurlyeq_{\mathit{st}+w} R^{'}(x)$,  thus
%% can be reduced to Equations \ref{eqn:WFR} and  \ref{eqn:MW}.
%%%Further, the definition of MW can be also expressed as: a read operation $r^n$ must not observe
%%    a value that is written by  an earlier write $w^i$ instead of a later write operation $w^j$ in the
%%    execution sequence. The above condition can be expressed in terms of the LTL expression
%%    $\not\exists  \mathit{st} \left( W^i F W^j F R^n \in \mathit{st} \right) \wedge \left( v^n = v^i\right)$.
%% Let us consider that there exists two consecutive write operations $w^i$ and $w^j$ in a given session
%%    trace, i.e., the condition ${W^i}^{''} F {W^j}^{''}  \in \mathit{st}$ holds. A read operation $r^m$
%%    cannot read the result of the earlier write operation $w^i$.
%% Further, let us consider a sequence of consecutive read operations $r^k$ and $r^l$  in a given
%%   global session history $\mathcal{S}_t$, i.e., the condition ${R^k}^{'} F {R^l}^{'} \in \mathcal{S}_t$ holds. According to
%%   the definition of MR, if the first read operation $r^k$ returns the
%%    result of the later write $w^j$, then the later read $r^l$ that follows $r^k$ can not return the result
%%    written by the earlier write $w^i$, i.e., the condition $\left( {v_k}^{''} = {v_j}^{'} \right) \wedge \left( {v_l}^{''} = {v_i}^{'} \right) $
%%    must hold. Further, let us consider the read operation $r^k$  reads the result of a preceding write $w^m$, and the read $r^n$ reads the
%%    result of a write $w^i$, the write $w^i(x)$ precedes $w^j(y)$ in the given session trace. Then, one of the following
%%    conditions must hold: 1) $r^n$ read the result of the write $w^m$, i.e., ${v_m}^{''} = {v_n}^{''}$ or 2) $r^n$ directly follows $w^m$ in the given
%%    session trace, i.e., $\left( {W^m}^{'} F {R^n}^{'} \in \mathcal{S}_t \right) \wedge \\
%%      \not\exists \left( {W^m}^{'} F {W^p}^{'} F {R^n}^{'} \in \mathcal{S}_t \right)$. Combining the above
%%  conditions, we can derive the anomaly expression for MW $C = \not\exists {W^j}^{'} F  {R^m}^{'} \in \mathit{st} \left( {v_m}^{'} = {v_i}^{'} \right)  \wedge \left( \not\exists  {R^k}^{''} F  {R^l}^{''} \in \mathcal{S}_t \right) \\
%%   \left( \left( {v_k}^{''} = {v_j}^{'} \right) \wedge \left( {v_l}^{''} = {v_i}^{'} \right) \right) \wedge \not\exists \big( \left( {W^m}(x)^{'} F {R^k}(x)^{'} \in \mathcal{S}_t  \right) \wedge \\
%%     \left( {v_m}^{''} = {v_k}^{'} \right) \wedge \left(  {W^i}(x)^{'} F {R^n}(x)^{'} \in \mathcal{S}_t \right) \wedge \left( {v_i}^{'} = {v_n}^{'} \right) \wedge \\
%%     \left( {W^i}(x)^{'} F  {W^j}(y)^{'} \in \mathit{st} \right) \wedge \left( {R^l}(y)^{'} F  {R^k}(x)^{'} \in \mathcal{S}_t \right) \big) \\
%% \big(  \left( {v_m}^{''} = {v_n}^{''} \right) \vee
%% \big( \left( {W^m}^{'} F {R^n}^{'} \in \mathcal{S}_t \right) \wedge \\
%%      \not\exists \left( {W^m}^{'} F {W^p}^{'} F {R^n}^{'} \in \mathcal{S}_t \right)  \big)$
%%      (refer to Equation \ref{eqn:MW}).
% %The postcondition of Chockler et al. implies that in any serialization order, a read operation $\mathit{o}^j$
%% must return the values written by the latest write operations that directly precedes it, namely $\mathit{o}^i$.
%% This, in turn, implies $v_l = v_m$ and
%% $v_l = v_m$, respectively.
%% However, subsequent write operations $\mathit{o}^p$ may alternatively overwrite the
%%  values  observed/written by operation $\mathit{o}^k$ . The above conditions may be specified by the
%% expressions $\mathit{Op}^j F^{o} \mathit{Op}^p X^{o} \mathit{Op}^k$. Thus, the expression for causal
%% consistency can be rewritten as
%%  \begin{align}
%%  \begin{split}
%%\forall i, j, k, l, m, n, p, q \big( \big( \left( \mathit{Op}^j = \left( W^j(v_l) \oplus R^j{v_l} \right) \right) \\
%%\wedge \left(   \mathit{Op}^k = \left( W^k(v_m) \oplus R^k{v_m} \right) \right) \wedge \left( \mathit{Op}^p = W^p(v_q)  \right) \big)
%% \\ \wedge \big( \left( \left( \mathit{Op}^j F^{o} \mathit{Op}^k \right) \oplus \left( \mathit{Op}^j X^{o} \mathit{Op}^k \right) \right)  \\
%% \vee \big( \left( \left( \mathit{Op}^j F^{o} \mathit{Op}^n \right) \oplus \left( \mathit{Op}^j X^{o} \mathit{Op}^n \right) \right)  \\
%%\wedge \left( \left( \mathit{Op}^n F^{o} \mathit{Op}^k \right) \oplus \left( \mathit{Op}^n X^{o} \mathit{Op}^j \right) \right) \big) \big) \big)_{o}^\mathit{po} \\
%%\Rightarrow \big(G\;  \left( v_l = v_m \right) \oplus \left( \mathit{Op}^j F^{o} \mathit{Op}^p X^{o} \mathit{Op}^k \right) \big)_{o}^\mathit{st}.
%%\end{split}
%% \end{align}
%%$\forall i, j, k, l, o, \mathit{st}_x, \mathit{st}_y \big( W^i F W^j \in \mathit{st}_x, \mathit{st}_y
%%\\ \Rightarrow  \exists S \left( W^i F W^j \in S \right) \wedge
%%\\ \wedge \not\exists R^m  \left( W^i F W^j F R^m \in \mathit{st}_x, \mathit{st}_y \right) \\
%%\wedge \big( \left( \left( v^m = v^i \in \mathit{st}_x  \right) \wedge \left( v^m = v^j \in \mathit{st}_y
%%\right) \right) \\
%% \vee \left( \left( v^m = v^j \in \mathit{st}_x  \right) \wedge \left( v^m = v^i \in \mathit{st}_y \right)
%% \right) \big) \big)
%%$
%\par In their definition of Causal consistency, Chockler uses the notion of a
%\emph{direct precedence relation} between operations $\mathit{o}(x)$
% and $\mathit{o}^{'}(x) $ in an execution order $\sigma_i$, denoted as $\xRightarrow{\sigma_i}$. The expression $\mathit{o}(x) \xRightarrow{\sigma_i} \mathit{o}^{'}(x) $
%  implies that either of the following properties must hold: Property 1) $\mathit{o}^{'}(x) $ is a read operation which returns the values written by a write operation $\mathit{o}(x)$, or Property 2)  %a precedence relationship
%%exists between $\mathit{o}$  and $\mathit{o}^{'} $  in the execution order $\sigma_i$ , i.e.,
% the precedence relation
%$\mathit{o}(x) \xrightarrow{\sigma_i} \mathit{o}^{'}(x) $  holds for a given execution $\sigma_i$. Causal consistency is expressed as Equation \ref{eqn:formdef}. Condition 1 specifies that a transitive closure  $\xRightarrow{\star}$ exists
%  over a direct precedence relation $\mathit{o}(x) \xRightarrow{\sigma_i} \mathit{o}^{'}(x)$ among a given pair of operations $\mathit{o}(x)$  and $\mathit{o}^{'}(x) $ in $\sigma_i$. %, i.e.,  must exist the precondition holds (i.e., if either Condition 1 or Condition 2 holds) for a given pair of operations $\mathit{o}$  and $\mathit{o}^{'} $ in every client in the system (i.e., for every process $p_i$),
%  %then $\mathit{o}$  and $\mathit{o}^{'} $ must satisfy the precedence relation $\mathit{o} \rightarrow \mathit{o}^{'}$ in an equivalent legal serialzation $S_p$ of a partial execution $\sigma |i + w$ comprising $\mathit{o}$  and $\mathit{o}^{'} $, i.e., the condition $\mathit{o} \xrightarrow{S_p}\mathit{o}^{'} $ must hold. % for each client in the system.
% %Condition 2 in Equation \ref{eqn:formdef} can be expressed in terms of LTL as  $\forall \mathit{st}.  \left(  \square\;  \mathit{Op}^{'}(x) \ \mathit{Op}^{''}(x) \right)$.  %The condition ${\mathit{Op}}^{'}  F_{S_p} {\mathit{Op}}^{''} $ denotes a partial order among ${\mathit{Op}}^{'} $ and ${\mathit{Op}}^{''} $ with respect to each client. Hence,
%  Following the same line of reasoning as that  used in our derivation for RYW, Condition 2 can be restated as: there must exist a partial order $\preccurlyeq$ which respects the order specified among the operations performed by each client, i.e., with respect to each observed session trace $\mathit{st}$, hence, with respect to the global session trace $\mathcal{S}_t$. Thus, Condition 2 reduces to the form ${\mathit{O}}^{'}(x)  \preccurlyeq {\mathit{O}}^{''}(x)  $, where $\preccurlyeq$ is a partial order with respect to operations in the global session trace.
%  As in previous cases, the expression $\mathit{o}(x) \xRightarrow{\sigma_i} \mathit{o}^{'}(x)$ in Condition 1 %by further Inspection, Condition 1 in the precondition
%  can be expressed in the
% form $ \square\;  {\mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x)$. %, since the special-purpose operator $F_\mathit{st}$ can be used to express the temporal relation among operations  quantified by the precedence operator $\xrightarrow{\sigma_i}$.
% However, Condition 2 implies that read operation $\mathit{o}(x){v}^{'}$, corresponding to the propositional variable ${\mathit{O}}(x)^{'} $, reads the value
% written by the write $\mathit{o}(x,v)^{''}$, corresponding to the propositional variable  ${\mathit{O}}^{''}(x)$. Thus, the precondition, comprising a logical disjunction over Condition 1 and 2, can be expressed as %$ \left( {\mathit{Op}}^{'} = {W}^{'} \right) \wedge \left( {\mathit{Op}}^{''} = {R}^{''} \right) \wedge
%  % \left( v = v^{'} \right)$.
%  $  \square\;  {\mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x) \vee
% \left( \left( {\mathit{O}}^{'}(x) = {W}^{'}(x) \right) \wedge \left( {\mathit{O}}^{''}(x) = {R}^{''}(x) \right) \wedge
%   \left( v_i = v_j \right) \right)$, where $ {R}^{''}(x)$ and $ {W}^{'}(x)$ are shortcut notations for   $\mathit{o}(x){v}^{'}$ and $\mathit{o}(x,v)^{''}$, respectively. For a given $\mathcal{S}_t$ to satisfy causal consistency,  a transitive closure
%must exist over the above condition. %, i.e.,
%%the condition $ {\mathit{Op}}^{'} F {\mathit{Op}}^{''} \vee
%% \left( \left( {\mathit{Op}}^{'} = {W}^{'} \right) \wedge \left( {\mathit{Op}}^{''} = {R}^{''} \right) \wedge
% %  \left( v_i = v_j \right) \right)$ must hold.
%  However, it directly follows from the Condition 1 in Definition \ref{def:form0} that if Condition 2 holds, i.e., if a valid $\preccurlyeq$ comprising $\mathit{o}(x)$  and $\mathit{o}^{'}(x) $ exists,  every operation in $ \preccurlyeq$ must reflect a result which is equivalent to that of executing the prior operations in $ \preccurlyeq$ according to a linear sequence. Hence, ${ \square\;  \mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x)$ implies that the transitivity condition holds over the expression $ \square\;  {\mathit{O}}^{'}(x) \rightarrow \lozenge {\mathit{O}}^{''}(x)$  in Condition 1. Hence, the precondition for Causality can simply be expressed as $ \square\;  {\mathit{O}}^{'}(x)  \rightarrow \lozenge  {\mathit{O}}^{''}(x)$. %, without any additional condition for imposing the transitivity constraint. % The precondition specifies that operations $\mathit{o}^j$  and $\mathit{o}^k$ are comprised in the execution
%%order $\sigma$.  The second precondition which claims
%% closure under transitivity of direct precedence relations, we can specify that if $\mathit{o}^i$ directly precedes
%% $\mathit{o}^k$, and $\mathit{o}^k$ directly precedes $\mathit{o}^j$, $\mathit{o}^i$ directly precedes
%% $\mathit{o}^j$.
%%Assuming the transitive closure property specified by the second precondition, the direct precedence
%% relation among operations $\mathit{o}^i$ and $\mathit{Op}^j$ can be expressed in terms of LTL as : $\big(\big(  \mathit{Op}^i F \mathit{Op}^j \vee \\
%% \exists \mathit{Op}^k \in  \mathit{st} \left( \mathit{Op}^i F \mathit{Op}^k  \wedge
%%\mathit{Op}^k F \mathit{Op}^j \right) \big) \\ \vee \big( \left( \mathit{Op}^i = W^i \right) \wedge
%%\left( \mathit{Op}^j = R^j \right) \wedge \\ \left( \left( v_i = v_j \right) \vee \exists \mathit{Op}^k \in  \mathit{st}
%%\left( \left( v_i = v_k \right)
%% \wedge \left( v_k = v_j \right) \right) \big) \right) \big)$.
%% The above expression matches the LHS of Equation \ref{eqn:Causal}.
% Thus, Chockler's definition of Causal Consistency reduces into the specification given in the Causal consistency Equation in ConSpec paper. %\ref{eqn:Causal}.
%% Additionally, the definition of  Causal consistency requires that the operation $\mathit{o}^j$ must not
%% read the result of an earlier write operations $w^m$  instead of $\mathit{o}^i$ such that either of the following
%%  conditions are satisfied. The first condition specifies that $r^j$ returns the result of $w^m$, i.e., the condition
%%   ${v^j}^{'} = {v^m}^{''}$ holds. The second condition specifies that $r^j$ follows the write $w^m$, such that
%%   the condition $\left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
%%\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right)$ holds. %The above condition can be expressed as
%%%  $\not\exists  \mathit{st} \left( W^m F \mathit{Op}^i F \mathit{Op}^j \in \mathit{st} \right)
%%%\wedge \left( v^j = v^m \right)$.
%%  We can combine the above expressions to form Equation \ref{eqn:Causal}, thus reducing it to the form of the anomaly condition, i.e.,
%%  $C = \not\exists \big( %\left( \mathit{st}^{'} \in \mathcal{S}_t \right) \wedge
%%   \left( {\mathit{Op}^i}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
%%   \left( {W^m}^{''} \in \mathcal{S}_t \right) \\
%%   \wedge \left( {\mathit{Op}^i}^{'} = {W^i}^{'} \right) \big)
%%\big( \left( {W^m}^{''} F {\mathit{Op}^i}^{'}  \in \mathcal{S}_t \right) \wedge
%%\big( \left( {v^j}^{'} = {v^m}^{''} \right) \vee \\
%% \big( \left( {W^m}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \wedge
%%\left( \not\exists {W^m}^{'} F {W^n}^{'} F {\mathit{Op}^j}^{'} \in \mathit{st} \right) \big) \big) \big)$
%%\par Causal+ consistency is defined by Lloyd et al. in prosaic form \cite{Lloyd:2011:DSE:2043556.2043593}. We formalise their definitions in terms of ConSpec  as follows. Valid partial orders $\preccurlyeq_{\mathit{st}+w}$ and  $\preccurlyeq_{\mathit{st}+w}$ comprising operations from
%%sessions $\mathit{st}$ and$ \mathit{st}^{'}$ must preserve the precedence order among pairs of  writes $w(x)$ and $ ws^{'} (x)$ on a common data object $x$.  We express the above definition in terms of LTL as follow.
%% $E^{s} = \forall \mathit{st}, \mathit{st}^{'}, \in \mathcal{S}_t, {\mathit{Op}}^{'}, {\mathit{Op}}^{''}, W^{'}(x),  W^{''} (x) \in \mathit{st} \big(  {\mathit{Op}}^{'} F _ \mathit{st} {\mathit{Op}}^{''}
%% \Rightarrow {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{'} (x) \Rightarrow W^{'}(x) \preccurlyeq_{{st}^{'}+w} W^{''} (x)  \big),
%% $ where $ \preccurlyeq_{\mathit{st}+w}$ is a partial order  restricted to  the elements of sessions $\mathit{st}$ and $\mathit{st}^{'}$ plus writes from other clients.  $ \preccurlyeq_{\mathit{st}+w}$ and $\preccurlyeq_{{st}^{'}+w}$ denote  partial orders  over operations on a given object $x$ restricted to  the elements of sessions $\mathit{st}$ and $\mathit{st}^{'}$ plus writes from other clients, respectively.
%% The above equation can be rewritten as $E^{s} = \forall \mathit{st}, \mathit{st}^{'}, \in \mathcal{S}_t, {\mathit{Op}}^{'}, {\mathit{Op}}^{''}, W^{'}(x),  W^{''} (x) \in \mathit{st} \big(  {\mathit{Op}}^{'} F _ \mathit{st} {\mathit{Op}}^{''}
%% \Rightarrow {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \preccurlyeq_{\mathit{st}+w}  W^{''} (x) \wedge W^{'} (x) \preccurlyeq_{{st}^{'}+w} W^{''}(x)  \big)$.  let ${\mathcal{W}_{St}}$ denotes the set comprising write operations  present in all session traces in $\mathcal{S}_t$.
%% Next, the partial order relations  ${\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''} $, $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (x)   \right)$, and $ \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{'} (x)  \right)$ can be expressed in terms of the corresponding partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, $\left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, and $\left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. By that reasoning, the condition $ {\mathit{Op}}^{'} \preccurlyeq_{\mathit{st}+w} {\mathit{Op}}^{''}  \wedge W^{'}(x) \preccurlyeq_{st+w} W^{''} (x) \wedge W^{'} (x) \preccurlyeq_{{st}^{'}+w} W^{''}(x)$ can be expressed in terms of an intersection $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'}_{st+w} \right)$ of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, $\left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$,  and $\left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$, where $ \preccurlyeq^{'}_{\mathit{st}+w} $ denotes the partial order relation  among elements of the new partial order set formed out of the intersection of $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, $\left( {\mathcal{W}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$, and $\left( {\mathcal{W}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. Thus, Causal+ can be rewritten into the form of Equation \ref{eqn:CausalC}.
%
%% Additionally, consider that a read operations $r^j$ follows a write operation $w^i$ in a given session
%% trace. Consider a read operation $r_k$ follows $r^j$ in the global session history. Strict serializability
%% requires that the later read $r^k$ can not read the result of the write $w^i$ if the earlier read $r^j$ did not observe it,
%% i.e., the condition $\left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \wedge
%% \left( {R^j}^{''} F {R^k}^{''} \in \mathcal{S}_t \right) \big)
%% \big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big)$ must hold.
%% Further, consider that a read operation $r^l$ follows the above sequence of write and reads in the global session history,
%% i.e., $ \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge
%%  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right)$. In that case,
%%  among the reads following $w^j$ the later read $r^l$ can not observe the result of $w^j$ if the earlier read $r^k$ did not
%%   observed it, i.e., \\ $\not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \\
%%  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \big)
%% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$.
%%  %must always observe the result
%%% of the latest operation preceding $r_k$. This condition can be expressed in terms of LTL as
%%% $\forall \mathit{st}  \left( \mathit{Op}^j X^o R^k \in \mathit{st} \right) \wedge \left( v^k = v^j  \right)$
%%  Combining the above
%%  conditions, we can derive the anomaly expression for strict serializability, i.e., $C = \not\exists \big( \left( {W^i}^{'} F {R^j}^{'} \in \mathit{st} \right) \\
%%   \wedge \left( {R^j}^{''} F {R^k}^{''} \in \mathcal{S}_t \right) \big)
%% \big(  \left( {v^k}^{''} = {v^i}^{'} \right) \wedge   \left( {v^j}^{'} \not= {v^i}^{'} \right) \big) \wedge \\
%% \not\exists \big(  \left( {\mathit{Op}^i}^{'} = {W^i}^{'}  \oplus {R^i}^{'}  \right) \wedge  \left( {\mathit{Op}^i}^{'}  F {W^j}^{'} F  {R^k}^{'} \in \mathit{st} \right) \wedge \\
%%  \left( {\mathit{Op}^i}^{'} F {W^j}^{''}   F  {R^k}^{'}  F  {R^l}^{'} \in \mathcal{S}_t \right) \big)
%% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{''} = {v^i}^{'} \right) \big)$ %\wedge
%%% \not\exists \big( \left( {\mathit{Op}}^{'} F {W^j}^{'} F {R^k}^{'} \in \mathit{st} \right) \wedge \\
%%% \left( {W^i}^{'} F {W^j}^{'} F {R^k}^{''} F {R^l}^{l'} \in \mathcal{S}_t \right) \big)
%%% \big(  \left( {v^l}^{''} = {v^j}^{'} \right) \wedge   \left( {v^k}^{'} \not= {v^i}^{'} \right) \big)$
%% (refer to Equation \ref{eqn:Strict}).
%%
% %\par %Goodman\textquotesingle s Processor consistency (PC) specifies that result of a preceding operation invoked from a given client must be observed in all processors (they refer to a client or a session as processor) before result of a
% %succeeding operation can be observed in any processor.  In other words, the order in which any pair of  writes, invoked from a particular client, are observed in session traces of all other clients must always respect the invocation order of the above operations. Reads against  write operations should
%  %view the results of the writes
%  %according to the invocation order of these writes in a client application.
%   %Following the same approach as before,
%   %Again, the ConSpec specification for Processor consistency (PC)  can be directly derived from the definition of Goodman\textquotesingle s PC provided by Ahamad et al. \cite{Ahamad:1993:PPC:165231.165264}.
% %PC talks about preserving the order of operations executed by individual processors (or client applications).
% %According to the above definition, there must exist a valid legal serialization for a partial execution  $\sigma |i + w$ of
% %comprising operations performed by
% %a processor $p_i$;  we denote  $\sigma |i + w$  as $S_p$.  The given execution of $p_i$ satisfies PC if and only if $S_p$ satisfies Condition 1 and 2.  Consider any pair of write operations $w(x,v)$ and $w^{'}(y,v^{'})$ invoked by  processor $p_i$. The Precedence order of $w(x,v)$ and $w^{'}(y,v^{'})$  in $S_p$ must echo the invocation order of $w(x,v)$ and $w^{'}(y,v^{'})$.  Ahamad et al. expresses Condition 1 as:
%% $\mathit{o}^1(x) \xrightarrow{\sigma_i} \mathit{o}^2(x)$ implies $\mathit{o}^1(x) \xrightarrow{S_p} \mathit{o}^2(x)$. Condition 2 states:  valid legal serializations of any given execution must order all write operations on a given object according to an identical precedence order. %In this paper, we refer to a processor  $p_i$ as a client $\mathit{Cl}_i$, and the session trace comprising the results observed by  $\mathit{Cl}_i$ is denoted as $\mathit{st}$. Hence, in our case, Condition 1 implies that the order among $w(x,v)$ and $ w^{'}(y,v^{'})$ invoked by in any valid legal serialization $S_p$ comprising operations performed by a  client $\mathit{Cl}_i$ must match the precedence order of $w(x,v)$ and  $w^{'}(y,v^{'})$ in a session trace $\mathit{st}$ observed by $\mathit{Cl}_i$.
%  %Following the same line of reasoning as in the previous derivations, we can express Condition 1 as follows.
%  %Using propositional variables  $W^{'}(x) $, and $W^{''} (y) $ to denote the events of execution of write operations $w(x,v)$ and  $w^{'}(y,v^{'})$ by processor $p_i$,
%%  As before, Condition 1 can be expressed as $ \square\; W^{'}(x) F_\mathit{st}  W^{''} (y) \Rightarrow  \square\;  W^{'}(x) F_\mathit{S_p}  W^{''} (y) $.
%  %Further, as explained in previous derivations, we can express a valid legal serialization $S_p$ for a processor $p_i$ in terms of a partial order $\preccurlyeq_{\mathit{st}+w}$. Thus, the above expression reduces to $ \square\; W^{'}(x) F_\mathit{st}  W^{''} (y) \Rightarrow W^{'}(x) \preccurlyeq_{\mathit{st}+w}  W^{''} (y) $.  % comprising all operations in a session trace $\mathit{st}$ for $p_i$ (referred to as a client $\mathit{Cl}_i$ in this paper) plus writes from all other processors (resp. clients).
%  %Imposing the restrictions of Condition 2 on a the above expression,  precedence relation $F_\mathit{st}$ among $w(x,v)$ and $w^{'}(y,v^{'})$ must be preserved in equivalent legal serializations for all processors in the system.
%  %Since $ \preccurlyeq$ %and $ \preccurlyeq_{{st}^{'}+w}$
%  %denotes a partial order over all operations in a global session trace $\mathcal{S}_t$, % observed for  a global execution comprising all processors executing in the system.  Then,
%  %Condition 2 can be restated as: there must exists a partial order $\preccurlyeq$ for a given $\mathcal{S}_t$, such that $W^{'}(x) \preccurlyeq  W^{''} (y)$ holds for all pairs of writes performed by any clients. Applying Condition 2, the expression for Condition 1 can be reduced to the form $ \forall \mathit{st} \in \mathit{S_t}: W_\mathit{st}^x \preccurlyeq_{\mathit{st}+w} W'^{x}_\mathit{st}  $.
%%  Further, Condition 2 implies that the effect of successive writes must be observed in an identical precedence order in valid legal serializations for all processors in the system. This, in turn, implies that the precedence order among successive reads by a process $p_i$ must be preserved in valid legal serializations for all processors. In other words, a partial order $\preccurlyeq$  for a given $\mathcal{S}_t$ must apply a pair of read operations $r(x){v}$ and $r(x){v}^{'}$ according to their mutual precedence order in the session trace $\mathit{st}$, i.e.,   $ \square\;  R'(x) \operatorname{\it F}_\mathit{st} R''(y)  \Rightarrow  R'(x) \preccurlyeq R''(y)$.
%  %The above expressions can be combined into the ConSpec specification given by Equation \ref{eqn:PC}. %It follows trivially from the definition of a session that the precedence order among $w(x,v)$ and  $w^{'}(y,v^{'})$ in a session trace $\mathit{st}$ observed by a client $\mathit{Cl}_i$ is equivalent to the invocation order of  $w(x,v)$ and  $w^{'}(y,v^{'})$ in $\mathit{Cl}_i$. In that light, the invocation order of a pair of writes  $w(x,v)$ and  $w^{'}(y,v^{'})$ invoked from a client $\mathit{Cl}_i$ can be expressed, in terms of LTL, as $W^{'}(x) F_\mathit{st}  W^{''} (y) $.
%% We denote $ \preccurlyeq$ %and $ \preccurlyeq_{{st}^{'}+w}$
% % as a partial order comprising all operations in a global session trace $\mathcal{S}_t$. % performed by clients $\mathit{Cl}_i$ and $\mathit{Cl}^{'}_i$ and writes from all other clients, respectively.
%  %Then, according to  Condition 1 and Condition 2, the precedence order among $w(x,v)$ and  $w^{'}(y,v^{'})$ in the partial order  $\preccurlyeq$ %and $ \preccurlyeq_{{st}^{'}+w}$
%  %must match the precedence order  $W^{'}(x) F_\mathit{st}  W^{''} (y) $.  %\\
%%E^{s} = C =   \forall \mathit{st} \in \mathcal{S}_t \not\exists \big( \left(  {W^i}^{'}, {W^j}^{'} \in \mathit{st}  \right)
%%\wedge \left( {R^k}^{'}, {R^l}^{'} \in \mathcal{S}_t \right) \big) \\
%%\big( \left( {W^i}^{'} F {W^j}^{'} \in \mathit{st} \right) \wedge
%%   \left( {R^k}^{'} F {R^l}^{'} \in \mathcal{S}_t \right) \wedge
%%  \left( v_k^{''} = v_j^{'} \right)  \wedge \\
%%  \left( v_l^{'} = v_i^{'} \right) \big) \wedge
%%  \not\exists \left( {W^i}^{'}, {R^j}^{'}, {R^k}^{'}, {W^l}^{'}  \in \mathit{st}  \right)
%%  \big( \left( {R^k}^{'} F {R^j}^{'} \in \mathit{st} \right) \\ \wedge
%%\left( {W^l}^{'} F {W^i}^{'} \in \mathcal{S}_t \right) \wedge
%% \left(  {v^k}^{'} = {v^i}^{'} \right) \wedge \big( \left( {v^j}^{'} = {v^l}^{'} \right) \vee \\
%%\big( \left( {W^l}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \wedge
%% \left( \not\exists {W^l}^{'} F {W^m}^{'} F {R^j}^{'} \in \mathcal{S}_t \right) \big) \big) \big)
%%E^s = \left( {\mathcal{O}_{St}}, \preccurlyeq \right),
%%$\forall x, y, \mathit{st} \in \mathcal{S}_t  \left( {\mathit{Op}}^{'}(x) F {\mathit{Op}}^{''} (y) \in \mathit{st} \right)  \Rightarrow \left( {\mathit{Op}}^{'}(x) \preccurlyeq {\mathit{Op}}^{''} (y) \right),$  where $ \preccurlyeq$ is a partial order over operations across all data objects with respect to a given global session trace $ \mathcal{S}_t$.
%%Thus, PC can be expressed as $ \forall \mathit{st} \in \mathcal{S}_t, \; R'(x), R''(y), W'(x), W''(y) \in \mathit{st}:  W'(x) \operatorname{\it F}_\mathit{st} W''(y)  \Rightarrow  W'(x) \preccurlyeq W''(y)  \wedge R'(x) \operatorname{\it F}_\mathit{st} R''(y)  \Rightarrow  R'(x) \preccurlyeq R''(y))$.
%%%The partial order relations $  \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right)$ and $ \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right)$ can be expressed in terms of the corresponding partial order sets $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$. By that reasoning, the condition $ \left( W^{'}(x) \preccurlyeq_{\mathit{st}+w} W^{''} (y)   \right) \wedge  \left( W^{'}(x)  \preccurlyeq_{{st}^{'}+w}  W^{''} (y)  \right) $ can be expressed in terms of an intersection $\left( {\mathcal{O}_{St}}, \preccurlyeq^{'} \right)$ of the partial order sets  $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$, where $ \preccurlyeq^{'} $ denotes the partial order relation  among elements of the new partial order set formed out of the intersection of $\left( {\mathcal{O}_{St}}, \preccurlyeq_{\mathit{st}+w} \right)$  and $\left( {\mathcal{O}_{St}}, \preccurlyeq_{{st}^{'}+w} \right)$.
%%  Thus, the definitions of Ahmad et al. directly reduces to the expression given in Equation \ref{eqn:PC}.
%   \par Chockler et al. states Sequential Consistency as: the precedence order among operations  in a valid legal serialization for a given global execution must match the precedence order of the operations in the local execution of each process, i.e.,  $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2 \Rightarrow \mathit{o}^1 \xrightarrow{S} \mathit{o}^2$, where $S$ in an equivalent legal serialization for the global session execution $\sigma$.  Following the same approach as in previous derivation, %the order  of execution among operations in an execution sequence $\sigma$,
% %can be given  in terms of a series of LTL expression that express the precedence of successive operations in the sequence.
%  the precedence relation $\mathit{o}^1 \xrightarrow{\sigma_i} \mathit{o}^2$ in the LHS of the above expression can be restated as
%   $ \square\;  \mathit{O}^{'} \rightarrow \lozenge  \mathit{O}^{''}$.  %Thus, the above condition can be expressed as: any two operations in an execution
%  % sequence must execute in an order that matches the precedence relation among these operations in a legal
%  % serialization of the above execution sequence. In other words, any two operations must occur in a session trace in an
%   %order that matches the precedence relation of these operations in a legal serialization of those operations.  Hence, this condition can be expressed in terms of LTL as
%  % $\mathit{Op}^{'} F \mathit{Op}^{''} \in \mathit{st}
%  %SC requires that an equivalent legal serialization must exist comprising operations performed by all clients in the system which matches the precedence among the operations $\mathit{o}$ and $\mathit{o}^{'}$.  We denote such a legal serialization as $S_c$, the subscript $c$ denotes that the serialization corresponds to a global execution restricted to operations from a given client. %(refer to the definition of $S_c$ in Equation \ref{def:clientser}).
%  % Similarly, the RHS can be expressed as $ \exists S \left(  \square\;  \mathit{Op}^{'}(x) F_{S} \mathit{Op}^{''}(x) \right)$. %, where $S_c$ denotes an equivalent legal serialization of a global execution restricted to operations from the given client (refer to the definition of $S_c$ in Equation \ref{def:clientser}).
%  As in our previous derivations, the above RHS can be rewritten as ${\mathit{O}}^{'}(x)  \preccurlyeq {\mathit{O}}^{''}(x)$, where $ \preccurlyeq$ is a partial order comprising all operations in $\mathcal{S}_t$. Thus, $ \preccurlyeq$ comprises all operations in the global execution $\sigma$.
%  Hence, the condition % $ \square\;  {\mathit{Op}}^{'}(x)  F_{S} {\mathit{Op}}^{''}(x) $
%   in the RHS implies a total order $\prec$ among each pair of operations $\mathit{o}^1 $ and $\mathit{o}^2$ comprised in $\mathcal{S}_t$. Thus, we can replace the partial order symbol $\preccurlyeq$ with $\prec$. This does not cause any loss of information since a total order is a special case of a partial order, i.e., ${\mathit{O}}^{'}(x)  \prec {\mathit{O}}^{''}(x)$  implies $\left( {\mathit{O}}^{'}(x) \preccurlyeq {\mathit{O}}^{''}(x) \right) \vee \left( {\mathit{O}}^{''}(x)  \preccurlyeq {\mathit{O}}^{'}(x)\right)$. Hence, we can rewrite the above RHS as  ${\mathit{O}}^{'}(x)  \prec {\mathit{O}}^{''}(x) $.
%  Thus, Chockler's definition of SC reduces into the specification given in the Sequential consistency  Equation in ConSpec paper.
 
\end{document} 
