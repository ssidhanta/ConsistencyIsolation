{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red26\green26\blue26;\red16\green60\blue192;}
\paperw11900\paperh16840\margl1440\margr1440\vieww25100\viewh12760\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 We sincerely thank the reviewers for the insightful comments and feedback. We made a significant effort to improve the paper by carefully addressing each comment. We list all of the feedback we received in the reviews (in bold) and inline how we modified the paper to address each feedback item.\
\pard\pardeftab720\sl300\partightenfactor0

\f1\b\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
\ul \ulc2 \
Reviewer: 1:
\b0 \
\
\pard\pardeftab720\sl300\partightenfactor0

\b \cf2 \ulnone 1) Many assumptions are left implicit which makes it difficult to grasp the actual power and generality of the approach.\
For example, the F_st operator is introduced in page 3 by giving an example how to link writes and reads in a session.\
Consider the following trace: w(x,1) w(x, 2) r(x),1 .\
In this trace, does it hold that w(x) F_st r(x) ?\
Yet, the expression w(x) F_st r(x) is seemingly assumed to hold true for the remainder of the paper (cf. also the evaluation).\
This assumption precludes formalizations of systems which apply versioning.\
Similarly, systems must have a sequential specification, which indirectly excludes systems whose semantics cover actual concurrent operations.
\b0 \
\
We addressed this comment by rewriting the definitions to completely remove the F_st operator, and instead resort to a smaller set of basic LTL operators. It should now be clear, in our new definitions, that the trace above meets the corresponding updated definition.\
\
Concerning formalizations that apply versioning, we believe (and our experience so far confirms) that it is possible to explain most consistency semantics without resorting to the notion of versioning, which is a concept very close to the actual implementation of the system.\
\
The reviewer is right that we cannot define specifications where concurrent operations lead to a result that would not be possible in a sequential execution. This decision has the advantage of simplifying our definitions. We have clarified this in the text.\
\
\

\b Though the paper makes the claim in the introduction that the formalism can abstract from implementation details, assumptions are stated regarding the protocols implementing a specific consistency semantics for the proof of a theorem.\
Now, it remains unclear where the assumptions actually come into play.\
\

\b0 The proof of the CAP theorem follows the same approach as that is taken in the original paper by Brewer.  We only assume network partition and a specific client execution flow in order to prove the theorem. We do not make any additional assumptions regarding our original consistency definitions or the equivalent valid partial order for a given consistency model. Thus the assumptions in Section 7 do not have any implications on any statement we made in the rest of the paper. \
\

\b The definition of causal consistency (p.4/5) supposedly only covers single-object causal consistency.\
Also, it is unclear how the definition tackles the transitivity of causal dependencies across sessions.\

\b0 \
We follow the standard definition of Causal consistency in several papers including Chockler\'92s. The definition of causal consistency can be trivially extended to cover multi-object causal consistency without any changes in the core assumptions regarding a valid partial order for a given global session trace. \
The transitivity of causal dependencies follows directly from the definition of a valid partial order for a given global session trace in Section 4. Also, we have shown how this transitivity is implied in our specification in the Appendix while showing the equivalence of our specification of Causal consistency with Chockler\'92s definition.\
\
I
\b n all examples, operation sequences always start with writes. Do these first writes represent initializations? Can these be concurrent?\
What is the semantics of traces that start with a read? \
\pard\pardeftab720\partightenfactor0

\f0\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \
To clarify, we have only included traces beginning with writes because a read at the beginning is not interesting for our analysis. This is because a starting read does not affect the result of any subsequent operation in a trace. However, of our analysis can be directly applied to traces with read in the beginning without any change. In fact one can add a read at the beginning of all of our example traces, and the result of our analysis will still be the same.  We simply omitted any precluding reads from our examples because they were not relevant to our discussion about consistency violations for given consistency models.  \
These starting writes can be considered initialisations, but we did not intend them to be that. Yes, they can be concurrent. But we did not consider concurrent writes in our examples because they did not help make our argument about  violations of the consistency models we were discussing in our examples. \
\
\pard\pardeftab720\sl300\partightenfactor0

\f1\b\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
Page 7: "it is always legal to remove orderings between operations across sessions" - But this ordering might be necessary to explain an outcome of a trace.\

\b0 \
We mentioned this statement while making the argument that weak consistency models do not impose restrictions on the order of operations from different sessions. This was not some generic statement that can be applied to explain outcome of all traces. \
\

\b 2) \'a0The formalisms are not applied with the mathematical rigor that I would expect from a paper with this kind of theoretical contributions.\
On page 3, the variables A and B denote both propositional variables and events.\
How are events and operations related?\
\

\b0 We stated in Page 3 that A and B are  propositional variables that denote the events of occurrences of operations a and b, respectively. We rewrote that portion in the paper to make that point clearer. \
\

\b Page 4ff: How is the variable x in the different variants of E quantified?\
\

\b0 In E, the variable x is quantified as a string; propositional variable op(x) denotes the event of occurrence of operation op on an object denoted by the string x. 
\f0\fs24 \cf0 \kerning1\expnd0\expndtw0 \
\

\f1\b\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
Page 6, Definition 2: The symbol between S_t and S_it at the end is never introduced.\
\

\b0 This is incorrect. S_t and S_it have been clearly defined in Section 3. \
\

\b Page 7, Proof of Theorem 7.1: The partial order enumeration is dependent on E^s, but this dependence does not seem to play a role in the proof. Why?\
\

\b0  Specification E^s of any consistency model is based on existence of a valid partial order for operations comprised in a given global session trace S_t. E^s imposes restrictions on the order of operations in a valid partial order for S_ts. In Theorem 7.1, we analyse if the occurrence of a partition has any implications on the existence of a  valid partial partial order for a given global session trace.  Thus, E^s does come to play a role in Theorem 7.1 through the restrictions on a valid partial order for S_t.  \
\

\b 3) The evaluation is only preliminary.\
Figure 3 shows the time to verify *a* global session trace. - Did you apply the tool only to one example??\
\
\pard\pardeftab720\sl300\partightenfactor0

\f0\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 We had applied the tool to verify a series of global session traces of increasing size collected using the YCSB benchmark suite.  Now, we have  also added new subsection 10.2 here we run the tool on traces collected from experiments with the TPC-C benchmark.\
\
\pard\pardeftab720\sl300\partightenfactor0

\f1\b\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
How many runs were evaluated? What is the variance of latency?
\f0\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \
\
In each of the experiments, we executed the tool 5 times on each global session trace. We have shown the variance of 5 repetitions of each verification step against every 30th global session trace. The variance is highlighted as text labels in the green coloured stacks in the stacked bar charts. \
\

\f1\b\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
How does this tool compare to other similar tools? Is the preprocessing part of the measurement?
\b0 \
\
We have added a new subsection 10.3 where we compare the performance of the tool with respect to Burkhardt\'92s definitions. We translated Burkhardt\'92s definitions into ConSpec format, and ran the tool on these specifications and global session traces collected using TPC-C.  We analyzed how Burkhardt\'92s definitions compare against ConSpec definitions in terms of performance as well as flexibility. \
Yes, preprocessing is part of the measurement, We have updated the evaluation section to clarify this and other details about the evaluation methodology used. \
\

\b It is very unsatisfactory as an explanation for the obviously unexpected scalability behavior that optimizations of Spin are a *possible* explanation.\
Which optimizations come into play here? Which property of the traces allow such optimizations?\
\

\b0 We have updated the subsection 10.1 discussing categorically which optimizations in Spin allowed for semi-linear scalability of the tool. \
\
\

\b Further comments:\
- p. 4: The explanation is difficult to follow: ... such that W'(x) <<_st+w R'(x) is holds (broken sentence?)
\f0\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \
\
Fixed the typo.\
\

\f1\b\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
- On a side note, in my opinion it should be left to the reader to judge whether a solution is "elegant".\
\

\b0 Removed that claim.\
\

\b - Fig. 2: The type setting of the formula is broken.
\f0\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \
\
Fixed the figure. \
\pard\pardeftab720\sl300\partightenfactor0

\b \cf0 \
\pard\pardeftab720\sl300\partightenfactor0

\f1\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
- p. 7: "specificaiton"
\b0 \
\
Corrected typo.\
\

\b - p. 8: "created by the statement Ser ser[2]" ? Does this array only have two entries? Or is it a literature reference?\

\b0 \
Corrected. It was supposed to be a variable.\
\

\b - p. 8: What is the formula E^s used in the example?
\b0 \
\
 Added reference to the RYW formula. \

\b \
- You should refer to the appendix in the text. This text would benefit from some structure. p. 11, lines 11-13: Shouldn't the condition be inv^i -> resp^i (for i = 1,2) and resp^1 -> inv^2?\

\b0 \
Updated that portion of the text. 
\f0\fs24 \cf0 \kerning1\expnd0\expndtw0 \
\
\pard\pardeftab720\sl300\partightenfactor0

\f1\b\fs25\fsmilli12800 \cf2 \expnd0\expndtw0\kerning0
\ul \
Reviewer: 2:\ulnone \
\
\
- It could be nice to add some names (of authors or of the systems) when citing references\
\
\pard\pardeftab720\sl300\partightenfactor0

\b0 \cf2 Updated the related work section.\
\

\b - The evaluation part is the less interesting, the results are quite predictable and the performance of the software tool does not seems to be an important problem.\
\

\b0 Added new subsections 10.2 where we describe results obtained with the TPC-C benchmark, and section 10.3 illustrating experiments performed with Burkhardt\'92s definitions against TPC-C  traces.\
\
\pard\pardeftab720\sl300\partightenfactor0

\b \cf2 \ul \
Reviewer: 3:\ulnone \
\pard\pardeftab720\sl300\partightenfactor0

\b0 \cf2 \

\b Another problem of the paper is the lack of comparison with recent work that has been carried out in the topic: for example,\
\
*the problem of specifying consistency models using temporal logic has also been assessed by Weber et al.,\
see\'a0{\field{\*\fldinst{HYPERLINK "https://link.springer.com/chapter/10.1007%2F978-3-319-60225-7_17"}}{\fldrslt \cf3 \expnd0\expndtw0\kerning0
\ul \ulc3 https://link.springer.com/chapter/10.1007%2F978-3-319-60225-7_17}}.
\b0 \
\
Added comparison with the paper by Weber et al. in related work section.\
\
*
\b *the authors reference the works of Burckhardt\'a0 et al. to model weak consistency [25,26,27]. Recently, Cerone et al. proposed a systematic way to define axioms in this\
framework to specify consistency guarantees ({\field{\*\fldinst{HYPERLINK "https://arxiv.org/abs/1702.06028"}}{\fldrslt \cf3 \expnd0\expndtw0\kerning0
\ul \ulc3 https://arxiv.org/abs/1702.06028}}). Although the work focuses on transactional consistency models of distributed databases, their approach can be adapted to model session guarantees and other weak consistency properties.\
\

\b0 Added comparison with the paper by Cerone et al. in related work section. Their paper have the same inherent problem as Burckhardt\'92s paper.\
\

\b * Weak consistency appears in the context of shared memory systems as well. In this field, there has been a lot of work regarding the implementation of tools that could determine whether a trace is allowed by a weak memory model. For example, Wickerson et al. recent work on the automatic comparison of weak memory models using the Alloy Analyzer: see\'a0{\field{\*\fldinst{HYPERLINK "https://johnwickerson.github.io/papers/memalloy.pdf"}}{\fldrslt \cf3 \expnd0\expndtw0\kerning0
\ul \ulc3 https://johnwickerson.github.io/papers/memalloy.pdf}}.
\b0 \
\
\
Added comparison to Alloy in related work. \
\

\b Technical comments:\
\
* the authors state that they use linear temporal logic (LTL) as a basis for their framework (page 3, line 47); afterwards, they make use of universal and existential quantifications in formal specifications: however, these operators, are not part of the standard LTL syntax (see Section 9.1. here:\'a0{\field{\*\fldinst{HYPERLINK "http://www.win.tue.nl/~jschmalt/teaching/2IX20/reader_software_specification_ch_9.pdf"}}{\fldrslt \cf3 \expnd0\expndtw0\kerning0
\ul \ulc3 http://www.win.tue.nl/~jschmalt/teaching/2IX20/reader_software_specification_ch_9.pdf}})
\b0 \
\
We have extended LTL by adding support for existential and universal quantifiers. Updated the relevant portion in Section 3. \
\
\

\b * In LTL, the finally/eventually operator corresponds to the diamond operator <> (see again the link above, section 9.3). The authors\'a0 define "finally" as the operator\'a0 (=> <>)\
(page 3, column 1, line 54). This may create some confusion to reader with a background in temporal logic.\
\

\b0 Fixed this in Section 3. It was a typo; we represented finally as <> and implies finally as =<> .
\b \

\b0 \

\b * At page 3, column 1, line 56, the authors state that (A => <> B) has the meaning that if A is true at some point in time, then B will eventually be true. This is false: the formula (A => <> B) states that if A is true at the beginning of a trace (i.e. A holds for the first operation of a trace), then B will eventually become true. I believe that the right formula that captures what the authors are trying to model is [](A =>\'a0 <> B), which is also known as "A leadsto B".
\b0 \
\
Fixed the relevant content in Section 3, Section 5, Section 6, and the Appendix. We used the expression [](A F B) or [](A =>\'a0 <> B) instead of A =>\'a0 <> B.\
\
*
\b  the syntactic operator F_\{st\}, introduced at Page 3,\'a0 \'a0is parametric in a denotational component, namely a session trace st. This is quite odd.\
\

\b0 As already stated, instead of classical LTL we extend LTL introducing special-purpose operators. F_st is one such special-purpose operator. We highlighted this in Section 3.
\b \
\
\
* Furthermore, the operator F_\{st\} is ill-defined: at page 3, column 2, line 3, it is stated that\
"A F_\{st\} B = \\exists A, B \\in st. A F B".\
One problem with this definition is that the predicates A, B are bound to an existential quantifier in the RHS, but are free in the LHS. Thus the definition of A F_\{st\} B does\
not depend from A, B at all. Another problem is that the existential quantification in the RHS requires that A,B are elements of the session trace st. But A, B are predicates, not elements of a trace. The obvious way to fix this problem (assuming LTL has been extended with existential quantification) would be "A F_\{st\} B = \\exists s_1,s_2 \\in st. A(s_1) /\\ B(s_2) \\wedge A F B", but this does not seem to express what the authors had in mind. Some clarification is necessary here.
\b0 \
\
Corrected the expression for F_st as:
\b  
\b0 \\exists A, B \\in st [] A F_\{st\} B \\equiv [] (A \\in st) F (B \\in st).\
\

\b * The operator F_\{st\} introduced by the authors is not associative: for this reason, the meaning of the second line of equation (3), Page 4, second column, is not clear. I believe that the operator F_\{st\} is right associative, but this should be stated somewhere (or explicit parentheses should be inserted).\
\

\b0 Yes, F_st is associative. We updated Section 3 as such.}